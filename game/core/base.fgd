//===================== Copyright (c) Valve Corporation. All Rights Reserved. ======================
//
// Defines entity classes common to most games.
//
//==================================================================================================


//--------------------------------------------------------------------------------------------------
// Auto vis groups
//--------------------------------------------------------------------------------------------------

@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolsclip.vmat"				group =	"Tool Brushes/Clip"					}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolsplayerclip.vmat"		group =	"Tool Brushes/Clip/Player Clip"		}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolsnpcclip.vmat"			group =	"Tool Brushes/Clip/NPC Clip"		}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolsnavclip.vmat"			group =	"Tool Brushes/Clip/Nav Clip"		}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolsteleportclip.vmat"		group =	"Tool Brushes/Clip/Teleport Clip"	}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolscontrolclip.vmat"		group =	"Tool Brushes/Clip/Control Clip"	}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolsnodraw.vmat"			group =	"Tool Brushes/Nodraw"				}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolsskybox.vmat"			group =	"Tool Brushes/Skybox"				}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolstrigger.vmat"			group =	"Tool Brushes/Trigger"				}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolsblocklight.vmat"		group =	"Tool Brushes/Block Light"			}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolssolidblocklight.vmat"	group =	"Tool Brushes/Block Light"			}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolslightmapres.vmat"		group =	"Tool Brushes/Lightmap Space"		}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "visblocker.vmat"			group =	"Tool Brushes/Vis Blocker"			}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "skyvisblocker.vmat"			group =	"Tool Brushes/Vis Blocker"			}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolsinvisible.vmat"		group =	"Tool Brushes/Invisible"			}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolsinvisibleladder.vmat"	group =	"Tool Brushes/Ladder"				}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolsmarkupvolumeai.vmat"	group =	"Tool Brushes/Markup Volume AI"		}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolsskip.vmat"				group =	"Tool Brushes/Skip"					}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolsoccluder.vmat"			group =	"Tool Brushes/Occluder"				}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolsprecipitation.vmat"	group =	"Tool Brushes/Precipitation"		}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolsblock_los.vmat"		group =	"Tool Brushes/Block LOS"			}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolsblockbullets.vmat"		group =	"Tool Brushes/Clip/Bullets"			}
@VisGroupFilter { filter_type = "toolsMaterial"		material = "toolsnavspaceclip.vmat"		group =	"Tool Brushes/Clip/Nav Space Clip"	}

@VisGroupFilter { filter_type = "entityTag"		tag = "Lighting"		group = "Entities/Lighting"				}
@VisGroupFilter { filter_type = "entityTag"		tag = "Sound"			group = "Entities/Sound"				}
@VisGroupFilter { filter_type = "entityTag"		tag = "Logic"			group = "Entities/Logic"				}
@VisGroupFilter { filter_type = "entityTag"		tag = "Filter"			group = "Entities/Logic"				}
@VisGroupFilter { filter_type = "entityTag"		tag = "Info"			group = "Entities/Info"					}
@VisGroupFilter { filter_type = "entityTag"		tag = "AI"				group = "Entities/AI"					}
@VisGroupFilter { filter_type = "entityTag"		tag = "NPC"				group = "Entities/NPCs"					}
@VisGroupFilter { filter_type = "entityTag"		tag = "Choreo"			group = "Entities/Choreo"				}
@VisGroupFilter { filter_type = "entityTag"		tag = "Trigger"			group = "Entities/Triggers"				}
@VisGroupFilter { filter_type = "entityTag"		tag = "NavMarkup"		group = "Entities/Nav Markup"			}
@VisGroupFilter { filter_type = "entityTag"		tag = "Particles"		group = "Entities/Particles"			}
@VisGroupFilter { filter_type = "entityTag"		tag = "Physics"			group = "Entities/Physics"				}
@VisGroupFilter { filter_type = "entityTag"		tag = "PropPhysics"		group = "Entities/Physics Props"		}
@VisGroupFilter { filter_type = "entityTag"		tag = "PropDynamic"		group = "Entities/Dynamic Props"		}
@VisGroupFilter { filter_type = "entityTag"		tag = "Overlay"			group = "Entities/Dynamic Overlays"		}
@VisGroupFilter { filter_type = "entityTag"		tag = "PostProcessing"	group = "Entities/Post Processing"		}
@VisGroupFilter { filter_type = "entityTag"		tag = "PlayerPosition"	group = "Entities/Player Positions"		}
@VisGroupFilter { filter_type = "entityTag"		tag = "PathVisible"		group = "Entities/Paths/Visible Paths"	}
@VisGroupFilter { filter_type = "entityTag"		tag = "PathLogical"		group = "Entities/Paths/Logical Paths"	}



//-------------------------------------------------------------------------
//
// PhysicsType Base Classes
// Inherit from these to indicate to the map builder that any meshes associated with the entity should have a different default physics type.
//
//-------------------------------------------------------------------------
@BaseClass = PhysicsTypeOverride_Mesh
[
]


@BaseClass = PhysicsTypeOverride_SingleConvex
[
]


@BaseClass = PhysicsTypeOverride_MultiConvex
[
]


//-------------------------------------------------------------------------
// Inherit from this class to indcate support for authored skeleton pose data
//-------------------------------------------------------------------------
@BaseClass = PosableSkeleton
[
]


//-------------------------------------------------------------------------
//
// Base Classes
//
//-------------------------------------------------------------------------
// FIXME: Source2 temp placeholder
@BaseClass = DXLevelChoice
[
]


@BaseClass = VScript
[
	vscripts(scriptlist) [ group="Misc" ] : "Entity Scripts" : "" : "Name(s) of script files that are executed after all entities have spawned."

	// Inputs
	input RunScriptFile(string) : "Load and execute a script file"
	input RunScriptCode(string) : "Execute a fragment of script code"
	input CallScriptFunction(string) : "Call a script function"
	input CallPrivateScriptFunction(string) : "Calls a script function from this entity's private script scope."
	input CallGlobalScriptFunction(string) : "Calls a script function in the global script scope."
]


@BaseClass base(VScript) = GameEntity
[
	input Kill(void) : "Removes this entity from the world."
	input KillHierarchy(void) : "Removes this entity and all its children from the world."
	input KillConstrained(void) : "Removes this entity, all its children, and anything constrained to it, from the world."

	// Inputs
	input AddOutput(string) : "Adds an entity I/O connection to this entity. Parameter format: outputname>targetname>inputname>parameter>delay>max times to fire (-1 == infinite). Very dangerous, use with care."
	input FireUser1(void) : "Causes this entity's OnUser1 output to be fired."
	input FireUser2(void) : "Causes this entity's OnUser2 output to be fired."
	input FireUser3(void) : "Causes this entity's OnUser3 output to be fired."
	input FireUser4(void) : "Causes this entity's OnUser4 output to be fired."

	// Outputs	
	output OnUser1(void) : "Fired in response to FireUser1 input."
	output OnUser2(void) : "Fired in response to FireUser2 input."
	output OnUser3(void) : "Fired in response to FireUser3 input."
	output OnUser4(void) : "Fired in response to FireUser4 input."
	
	output OnKilled(void) : "Fired when the entity is killed and removed from the game. Parameter is the inflictor."
] 


@BaseClass base(GameEntity) = Targetname 
[ 
	targetname(target_source) { sort_priority = 90 } : "Name" : : "The name that other entities refer to this entity by."
]


@BaseClass = Parentname
[ 
	parentname(target_destination) { group="Hierarchy" } : "Parent" : : "The name of this entity's parent in the movement hierarchy. Entities with parents move with their parent."
	parentAttachmentName(parentAttachment) { group="Hierarchy" } : "Parent Bone/Attachment Name" : : "The name of the bone or attachment to attach to on the entity's parent in the movement hierarchy. Use !bonemerge to use bone-merge style attachment. NOTE: If this is specified the Hammer transform will be disregarded, even if 'Use Local Transform' is NOT specified (in that case local transform will be identity)"
	
	useLocalOffset(boolean)
	{
		group="Hierarchy"
		bindable_command_buttons =
		[
			{
				target = "ToolSelection"
				command = "RepositionToMatchLocalOffset"
				icon = "tools/images/hammer/reposition_to_match_local_offset.png"
				desc = "Reposition the entity's Hammer transform to match its local offset hierarchy keys"
			},
			{
				target = "ToolSelection"
				command = "UpdateLocalOffset"
				icon = "tools/images/hammer/update_local_offset.png"
				desc = "Update the local offset hierarchy keys based on the entity's current Hammer transform"
			},
		]
	}
	: "Use Local Transform" : 0 : "Whether to respect the specified local offset when doing the initial hierarchical attachment to its parent."

	local.origin(vector) { group="Hierarchy" enabled={ variable="useLocalOffset" value="1" } } : "Local Origin" : : "Offset in the local space of the parent model's attachment/bone to use in hierarchy. Not used if you are not using parent attachment."
	local.angles(angle)  { group="Hierarchy" enabled={ variable="useLocalOffset" value="1" } } : "Local Angles" : : "Angular offset in the local space of the parent model's attachment/bone to use in hierarchy. Not used if you are not using parent attachment."
	local.scales(vector) { group="Hierarchy" enabled={ variable="useLocalOffset" value="1" } } : "Local Scale" : : "Scale in the local space of the parent model's attachment/bone to use in hierarchy. Not used if you are not using parent attachment."

	// Inputs
	input SetParent(target_destination) : "Changes the entity's parent in the movement hierarchy."
	input SetParentAttachment(string) : "Change this entity to attach to a specific attachment point on its parent. Entities must be parented before being sent this input. The parameter passed in should be the name of the attachment."
	input SetParentAttachmentMaintainOffset(string) : "Change this entity to attach to a specific attachment point on it's parent. Entities must be parented before being sent this input. The parameter passed in should be the name of the attachment. The entity will maintain it's position relative to the parent at the time it is attached."
	input ClearParent(void) : "Removes this entity from the the movement hierarchy, leaving it free to move independently."
	input FollowEntity(string) : "Bone merges this entity to a parent entity. Call again passing nothing to end the bone merge."
]


@BaseClass 
	metadata
	{
		api_classes = [ "basemodelentity" ]
	}
= Studiomodel
[
	model(studio) { report = true sort_priority = 80 } : "World Model"
	skin(materialgroup) [ group="Render Properties" ] : "Skin" : "default" : "Some models have multiple versions of their textures, called skins."
	bodygroups(bodygroupchoices) [ group="Render Properties" ] : "Body Groups" : ""
	
	disableshadows(choices) [ group="Render Properties" ] : "Cast Shadows" : 0 : "Used to disable shadow casting from this entity." = 
	[
		0: "Enabled"
		1: "No Shadows"
		2: "Only Realtime Shadows"
		3: "Only Baked Shadows"
	]

	// Inputs
	input Skin(integer) : "Changes the model skin to the specified number."
	input DisableShadow(void) : "Turn shadow off."
	input EnableShadow(void) : "Turn shadow on."
	input AlternativeSorting(bool) : "Used to attempt to fix sorting problems when rendering. True activates, false deactivates"
	input SetRenderAttribute(string) : "Set the value of a render attribute used in material dynamic expressions. Examples: $myfloat=0.25 $myfloat4=1.0,0.0,1.0,1.0"
	input ClearRenderAttribute(string) : "Remove a render attribute previously set by SetRenderAttribute, restoring it to its previous value."

	// Outputs
	output OnIgnite(void) : "Fired when this object catches fire."
	output OnDestructibleHitGroupDamageLevelChanged(api)

	add_attribute(string) : "Add Attribute" : "" : "Will add an additional attribute that AI/player entities can query when checking props for information (ex: 'DogToy' or 'GrabbableResource')"
	add_modifier(string) : "Add Modifier" : "" : "Will add this modifier when the entity spawns."
]

@BaseClass base( Studiomodel ) = BaseAnimGraph2
[
	animgraph2_identifier(animgraph2_identifier) : "AnimGraph2 Identifier" : "" : "Which animgraph should we use when spawning the entity? Animgraph identifiers are authored in modeldoc, see the AnimGraph2 reference node."
]

@BaseClass = BasePlat
[
	input Toggle(void) : "Toggles the platform's state."
	input GoUp(void) : "Tells the platform to go up."
	input GoDown(void) : "Tells the platform to go down."
]


@BaseClass = EnableDisable
[
	StartDisabled(boolean) : "Start Disabled" : 0

	// Inputs
	input Enable(void) : "Enable this entity."
	input Disable(void) : "Disable this entity."
]


@BaseClass = RenderFxChoices
[
	renderfx(choices) [ group="Render Properties" ] : "Render FX" : "kRenderFxNone" =
	[
		"kRenderFxNone" : "Normal"
		"kRenderFxPulseSlow" : "Slow Pulse"
		"kRenderFxPulseFast" : "Fast Pulse"
		"kRenderFxPulseSlowWide" : "Slow Wide Pulse"
		"kRenderFxPulseFastWide" : "Fast Wide Pulse"
		"kRenderFxStrobeSlow" : "Slow Strobe"
		"kRenderFxStrobeFast" : "Fast Strobe"
		"kRenderFxStrobeFaster" : "Faster Strobe"
		"kRenderFxFlickerSlow" : "Slow Flicker"
		"kRenderFxFlickerFast" : "Fast Flicker"
		"kRenderFxFadeSlow" : "Slow Fade Away"
		"kRenderFxFadeFast" : "Fast Fade Away"
		"kRenderFxSolidSlow" : "Slow Become Solid"
		"kRenderFxSolidFast" : "Fast Become Solid"
		"kRenderFxNoDissipation" : "Constant Glow"

		// FGDFIXME: why are these different from the ones above?
		15: "Distort"
		16: "Hologram (Distort + fade)"
		23: "Cull By Distance (TEST)"
		24: "Spotlight FX"
		26: "Fade Near"
	]
]


@BaseClass = RenderModeChoices
[
	rendermode(choices) [ group="Render Properties" ] :"Render Mode" : "kRenderNormal" : "Used to set a non-standard rendering mode on this entity. See also 'FX Amount' and 'FX Color'." =
	[
		"kRenderNormal" : "Normal"
		"kRenderTransColor" : "Color"
		"kRenderTransTexture" : "Texture"
		"kRenderGlow" : "Glow"
		"kRenderTransAlpha" : "Solid"
		"kRenderTransAdd" : "Additive"
		"kRenderTransAddFrameBlend" : "Additive Fractional Frame"
		"kRenderWorldGlow" : "World Space Glow"
		"kRenderNone" : "Dont Render"
		"kRenderDevVisualizer" : "Dev Visualizer"
	]
]


@BaseClass = Shadow
[
	disableshadows(choices) [ group="Render Properties" ] : "Cast Shadows" : 0 : "Used to disable shadow casting from this entity." = 
	[
		0: "Enabled"
		1: "No Shadows"
		2: "Only Realtime Shadows"
		3: "Only Baked Shadows"
	]

	input DisableShadow(void) : "Turn shadow off."
	input EnableShadow(void) : "Turn shadow on."
]


@BaseClass = Glow
[
	glowstate(choices) [ group="Glow Properties" ] : "Glow State" : 0 =
	[
		0: "OFF"
		1: "+use"
		2: "look-at"
		3: "ON"
	]
	glowrange(integer) [ group="Glow Properties" ] : "Glow Range" : 0 : "Range at which the glow becomes visible. (0 = always visible)"
	glowrangemin(integer) [ group="Glow Properties" ] : "Glow Range Min" : 0 : "Range at which the glow stops being visible. (0 = always visible)"
	glowcolor(color255) [ group="Glow Properties" ] : "Glow Color Override (R G B)" : "0 0 0" : "Change the render color of the glow."
	glowteam(integer) [ group="Glow Properties" ] : "Glow Team" : "-1" : "Change the team we glow for."

	input StartGlowing(void) : "Turn on a permanent glow effect for this prop."
	input StopGlowing(void) : "Turn off this prop's glow effect."
]

@BaseClass base(RenderFxChoices, RenderModeChoices) = RenderFields 
[
	renderamt(integer) [ group="Render Properties" ] : "FX Amount (0 - 255)" : 255 : "The FX amount is used by the selected Render Mode."
	rendercolor(color255) : "FX Color (R G B)" : "255 255 255" : "The FX color is used by the selected Render Mode."

	disablereceiveshadows(boolean) [ group="Render Properties" ] : "Disable Receiving Shadows" : 0

	input Alpha(integer) : "Set the sprite's alpha (0 - 255)."
	input Color(color255) : "Set the sprite's color (R G B)."

	fademindist(float) [ group="Render Properties" ] : "Start Fade Dist" : -1 : "Distance at which the overlay starts to fade (-1 = subtract from fademaxdist)."
	fademaxdist(float) [ group="Render Properties" ] : "End Fade Dist" : 0 : "Maximum distance at which the overlay is visible (0 = don't fade out)."

	object_culling(choices) [ group="Render Properties" ] : "Culling Behaviour" : 0 : "Modifies culling behaviour when the object is small / distant" =
	[
		0 : "Default"
		1 : "Smaller than default"
		2 : "Much smaller than default"
		3 : "When extremely small"
	]

	rendertocubemaps(boolean) [ group="Render Properties" ] : "Render to Cubemaps" : 0 : "If true, this geometry renders into baked cube maps"	
	lightmapstatic(choices) [ group="Render Properties" ] : "Lightmap Static" : 0 : "Determines if this geometry be considered static & cast shadows/bounce light when baking lightmaps?" =
	[
		0 : "No"
		1 : "Yes"
		2 : "Bounce Only"
	]
]


@BaseClass = Inputfilter
[
	InputFilter(choices) : "Input Filter" : 0 : "Used to specify which inputs this entity will accept." =
	[
		0 : "Allow all inputs"
		8 : "Ignore Touch/Untouch"
		16 : "Ignore Use"
		32 : "Ignore All"
	]
]

@BaseClass = Global 
[ 
	globalname(string) [ group="Misc" ] : "Global Entity Name" : "" : "Name by which this entity is linked to another entity in a different map. When the player transitions to a new map, entities in the new map with globalnames matching entities in the previous map will have the previous map's state copied over their state."
]

// Base class for env_global
@BaseClass base(Targetname) = EnvGlobal : 
	"An entity to control a global game state, with an optional associated counter, that persists across level transitions."
[
	initialstate(choices) : "Initial State" : 0 =
	[
		0 : "Off"
		1 : "On"
		2 : "Dead"
	]
	
	counter(integer) : "Counter" : 0 : "An integer counter value associated with this global."

	spawnflags(flags) =
	[
		1 : "Set Initial State" : 0
	]

	// Inputs
	input TurnOn(void) : "Set state of global to ON."
	input TurnOff(void) : "Set state of global to OFF."
	input Toggle(void) : "Toggles state of global between ON and OFF."
	input Remove(void) : "Set state of global to DEAD."
	input SetCounter(integer) : "Sets the counter value of this global."
	input AddToCounter(integer) : "Adds to the counter value of this global. Negative numbers subtract."
	input GetCounter(void) : "Causes the Counter output to be fired, passing the current counter value for this global."

	// Outputs
	output Counter(integer) : "Fired in response to the GetCounter input, passing the current value of the counter."
]

@BaseClass = DamageFilter
[ 
	damagefilter(target_destination) [ group="Misc" ] : "Damage Filter" : "" : "Name of the filter entity that controls which entities can damage us."
	input SetDamageFilter(string) : "Sets the entity to use as damage filter. Pass in an empty string to clear the damage filter."
]

@BaseClass = ResponseContext
[
	// Inputs
	input AddContext(string) : "Adds a context to this entity's list of response contexts. The format should be 'key:value'."
	input RemoveContext(string) : "Remove a context from this entity's list of response contexts. The name should match the 'key' of a previously added context."
	input ClearContext(void) : "Removes all contexts in this entity's list of response contexts."

	// Pre-defined contexts at server startup time (set by mapper)
	ResponseContext(string) : "Response Contexts" : "" : "Response system context(s) for this entity. Format should be: 'key:value,key2:value2,etc'. When this entity speaks, the list of keys & values will be passed to the response rules system."
]

@BaseClass base(Targetname, DamageFilter, Shadow) = Breakable
[
	ExplodeDamage(float) [ group="Breakable Properties" ] : "Explosion Damage" : 0 : "If non-zero, when this entity breaks it will create an explosion that causes the specified amount of damage. See also 'Explosion Radius'."
	ExplodeRadius(float) [ group="Breakable Properties" ] : "Explosion Radius" : 0 : "If non-zero, when this entity breaks it will create an explosion with a radius of the specified amount. See also 'Explosion Damage'."
	PerformanceMode(choices) [ group="Breakable Properties" ] : "Performance Mode" : "PM_NORMAL" : "Used to limit the amount of gibs produced when this entity breaks, for performance reasons." =
	[
		"PM_NORMAL" : "Normal"
		"PM_NO_GIBS" : "No Gibs"
	]

	NoInterpolate(boolean) [ group="Misc" ] : "Disable Client-Side Interpolation" : 0

	// Inputs
	input Break(void) : "Breaks the breakable."
	input SetHealth(integer) : "Sets a new value for the breakable's health. If the breakable's health reaches zero it will break."
	input AddHealth(integer) : "Adds health to the breakable. If the breakable's health reaches zero it will break."
	input RemoveHealth(integer) : "Removes health from the breakable. If the breakable's health reaches zero it will break."
	input SetMass(float) : "Set mass of this object."

	// Outputs	
	output OnStartDeath(void) : "Fired when this prop has begun dying (breaking) before other death-related callbacks." 
	output OnBreak(void) : "Fired when this breakable breaks."
	output OnHealthChanged(float) : "Fired when the health of this breakable changes, passing the new value of health as a percentage of max health, from [0..1]."
]

@BaseClass base(Breakable, Parentname, Global) = BreakableBrush
[
	spawnflags(flags) =
	[
		1 : "Only Break on Trigger" : 0
		2 : "Break on Touch" : 0
		4 : "Break on Pressure" : 0
		512: "Break immediately on Physics" : 0
		1024: "Don't take physics damage" : 0
		2048: "Don't allow bullet penetration": 0
		4096: "Don't allow hand physics damage" : 0
	]

	propdata(choices) : "Prop Data" : 0 : "Set to the best approximation of the size and material of this entity's brushes. If set, it will override this entity's health and damage taken from various weapons. See the propdata.txt file in the scripts directory of your MOD to get a detailed list of what each entry specifies." =
	[
		0 : "None"
		1 : "Wooden.Tiny"
		2 : "Wooden.Small"
		3 : "Wooden.Medium"
		4 : "Wooden.Large"
		5 : "Wooden.Huge"
		6 : "Metal.Small"
		7 : "Metal.Medium"
		8 : "Metal.Large"
		9 : "Cardboard.Small"
		10 : "Cardboard.Medium"
		11 : "Cardboard.Large"
		12 : "Stone.Small"
		13 : "Stone.Medium"
		14 : "Stone.Large"
		15 : "Stone.Huge"
		16 : "Glass.Small"
		17 : "Plastic.Small"
		18 : "Plastic.Medium"
		19 : "Plastic.Large"
		20 : "Pottery.Small"
		21 : "Pottery.Medium"
		22 : "Pottery.Large"
		23 : "Pottery.Huge"
		24 : "Glass.Window"
	]

	health(integer) : "Strength" : 1 : "Number of points of damage to take before breaking. 0 means don't break."
	material(choices) :"Material Type" : 0 : "Set to the material type of the brush. Used to decide what sounds to make when damaged, and what gibs to produce when broken." =
	[
		0: "Glass"
		1: "Wood"
		2: "Metal"		
		3: "Flesh"
		4: "CinderBlock"
		5: "Ceiling Tile"
		6: "Computer"
		7: "Unbreakable Glass"
		8: "Rocks"
		// 9: "Web(defunct)"
		10: "None"
	]
	explosion(choices) : "Gibs Direction" : 0 : "Used to decide which direction to throw gibs when broken." =
	[
		0: "Random"
		1: "Relative to Attack"
		2: "Use Precise Gib Dir"
	]

	nodamageforces(boolean) : "Damaging it Doesn't Push It" : 0 : "Used to determine whether or not damage should cause the brush to move."

	// Inputs
	input EnableDamageForces(void) : "Damaging the entity applies physics forces to it."
	input DisableDamageForces(void) : "Damaging the entity does *not* apply physics forces to it."

	spawnobject(choices) : "Spawn On Break" : 0 : "When broken, an entity of the selected type will be created." =
	[
		0:	""
		1:	"item_battery"				
		2:	"item_healthkit"			
		3:	"item_ammo_pistol"			
		4:	"item_ammo_pistol_large"	
		5:	"item_ammo_smg1"			
		6:	"item_ammo_smg1_large"	
		7:	"item_ammo_ar2"			
		8:	"item_ammo_ar2_large"	
		9:	"item_box_buckshot"		
		10:	"item_flare_round"			
		11:	"item_box_flare_rounds"		
		12:	"item_ml_grenade"		
		13:	"item_smg1_grenade"			
		14:	"item_box_sniper_rounds"	
		15:	"unused1"			
		16:	"weapon_stunstick"		
		17:	"weapon_ar1"				
		18:	"weapon_ar2"			
		19:	"unused2"				
		20:	"weapon_ml"					
		21:	"weapon_smg1"				
		22:	"weapon_smg2"				
		23:	"weapon_slam"				
		24:	"weapon_shotgun"			
		25:	"weapon_molotov"
		26:	"item_dynamic_resupply"							
	]
	explodemagnitude(integer) : "Explode Magnitude" : 0 : "If non-zero, when this entity breaks it will create an explosion that causes the specified amount of damage."
	pressuredelay(float) : "Pressure Delay" : 0 : "Delay, in seconds, after 'broken' by pressure before breaking apart (allows for sound to play before breaking apart)."
]

@BaseClass = CanBeClientOnly
[
	clientSideEntity(choices) [ group="Misc" ] : "Create Client-Only Entity" : 0 =
	[
		0 : "No"
		1 : "Yes"
	]
]

@BaseClass base(Breakable) vecline_local( burstlocation, 255, 200, 200, hideifzero, requires_breakable_model ) text_local( burstlocation, "  Burst Location", 255, 200, 200, hideifzero, requires_breakable_model )
	= BreakableProp
[
	spawnflags(flags) =
	[
		16 : "Break on Touch" : 0
		32 : "Break on Pressure" : 0
	]
	pressuredelay(float) [ group="Breakable Properties" ] : "Pressure Delay" : 0 : "Delay, in seconds, after 'broken' by pressure before breaking apart (allows for sound to play before breaking apart)."
	burstscale(float) [ group="Breakable Properties" ] : "Burst Force Scale" : 100 : "Radial force applied to our pieces when we break."
	burstlocation(local_point) [ group="Breakable Properties" ] : "Burst Force Location" : : "Location in local space where the burst force is applied."

	
	BreakableContentsType(choices) [ group="Break Contents" ] : "Contents Type" : "BC_DEFAULT" : "Set the type of contents inside this breakable." =
	[
		"BC_DEFAULT" : "Default"
		"BC_EMPTY" : "Empty"
		"BC_PROP_GROUP_OVERRIDE" : "Prop Group Override"
		"BC_PARTICLE_SYSTEM_OVERRIDE" : "Particle System Override"
	]
	BreakableContentsPropGroupOverride( vdata_choice:scripts/misc.vdata ) [ group="Break Contents" ] : "Breakable Contents Prop Group Override" : "" : "Prop Group to use when the prop is broken"
	BreakableContentsParticleOverride(particlesystem) [ group="Break Contents" ] : "Breakable Contents Particle Override" : ""

	// Outputs
	output OnTakeDamage(void) : "Fired each time this breakable takes any damage."
]

@BaseClass color(0 255 0) = PlayerClass []

@BaseClass color(180 10 180) = Light
[
	_light(color255) : "Brightness" : "255 255 255 1500"
	_lightHDR(color255) : "BrightnessHDR" : "-1 -1 -1 1"
	_lightscaleHDR(float) : "BrightnessScaleHDR" : "1" : "Amount to scale the light by when compiling for HDR."
	style(Choices) : "Appearance" : 0 =
	[
		0 : "Normal"
		10: "Fluorescent flicker"
		2 : "Slow, strong pulse"
		11: "Slow pulse, noblack"
		5 : "Gentle pulse"
		1 : "Flicker A"
		6 : "Flicker B"
		3 : "Candle A"
		7 : "Candle B"
		8 : "Candle C"
		4 : "Fast strobe"
		9 : "Slow strobe"
	]
	pattern(string) : "Custom Appearance" : "" : "Set a custom pattern of light brightness for this light. Pattern format is a string of characters, where 'a' is total darkness, 'z' fully bright. i.e. 'aaggnnttzz' would be a steppy fade in from dark to light."
	_constant_attn(string)	: "Constant" : "0"
	_linear_attn(string)	: "Linear" : "0"
	_quadratic_attn(string)	: "Quadratic" : "1"
	_fifty_percent_distance(string) : "50 percent falloff distance" : "0": "Distance at which brightness should fall off to 50%. If set, overrides linear constant and quadratic paramaters."
	_zero_percent_distance(string) : "0 percent falloff distance" : "0": "Distance at which brightness should fall off to negligible (1/256)%. Must set _fifty_percent_distance to use."
	_hardfalloff(integer) : "hard falloff" : 0 : "If set, causes lights to fall to exactly zero beyond the zero percent distance. May cause unrealistic lightijng if not used carefully."

	// Inputs
	input TurnOn(void) : "Turn the light on."
	input TurnOff(void) : "The the light off."
	input Toggle(void) : "Toggle the light's current state."
	input SetPattern(string) : "Set a custom pattern of light brightness for this light. Pattern format is a string of characters, where 'a' is total darkness, 'z' fully bright. i.e. 'aaggnnttzz' would be a steppy fade in from dark to light."
	input FadeToPattern(string) : "Fades from first value in old pattern, to first value in the new given pattern. Pattern format is a string of characters, where 'a' is total darkness, 'z' fully bright. i.e. 'aaggnnttzz' would be a steppy fade in from dark to light."
]

@BaseClass base(Targetname, Parentname, EnableDisable, Global) tags( Trigger )
	metadata
	{
		auto_apply_material = "materials/tools/toolstrigger.vmat"
		collision_group = "trigger"
		physics_only_model = true
	}
= TriggerOnce
[
	spawnflags(flags) = 
	[
		1: "Clients" : 1
		2: "NPCs" : 0
		4: "Projectiles": 0
		8: "Physics Objects" : 0
		16: "Only player ally NPCs" : 0
		32: "Only clients in vehicles" : 0
		64: "Everything (not including physics debris)" : 0
		512: "Only clients *not* in vehicles" : 0
		1024: "Physics debris" : 0
		2048: "Only NPCs in vehicles (respects player ally flag)" : 0
		4096: "Correctly account for object mass (trigger_push used to assume 100Kg) and multiple component physobjs (car, blob...)" : 1
		268435456: "Touch objects in the trigger's hierarchy" : 0
	]

	filtername(filterclass) : "Filter Name" : : "Filter to use to see if activator triggers me. See filter_activator_name for more explanation."

	// Inputs
	input Toggle(void) : "Toggles this trigger between enabled and disabled states."

	// Outputs
	output OnStartTouch(void) { is_activator_important = true } : "Fired when an entity starts touching this trigger. The touching entity must pass this trigger's filters to cause this output to fire."
]

@BaseClass base(Targetname, Parentname, EnableDisable, TriggerOnce)	= Trigger
[
	output OnStartTouchAll(void) { is_activator_important = true } : "Fired when an entity starts touching this trigger, and no other entities are touching it. Only entities that passed this trigger's filters are considered."
	output OnEndTouch(void) { is_activator_important = true } : "Fired when an entity stops touching this trigger. Only entities that passed this trigger's filters will cause this output to fire."
	output OnEndTouchAll(void) { is_activator_important = true } : "Fires when an entity stops touching this trigger, and no other entities are touching it. Only entities that passed this trigger's filters are considered."
]

@BaseClass = worldbase
[
	targetname(target_source) : "Name" : : "The name that other entities refer to this entity by."
	skyname(string) : "SkyBox Texture Name" : "sky_day01_01"
	startdark(boolean) : "Level Fade In" : 0
	startcolor(color255) : "Level Fade In Color (R G B)" : "0 0 0"

	pvstype(choices) : "Precomputed Visibility" : 10 : "" = 
	[
		0 : "Disabled"
		1 : "Test map (open space, no skybox)"
		10 : "Full visibility solve"
		11 : "Partitioned solve (large map volume)"
	]

	newunit(choices) : "New Level Unit" : 0 : "Used to clear out savegame data of previous levels to keep the savegame size as small as possible. Only set it to Yes if the player cannot return to any previous levels." = 
	[
		0 : "No, keep current"
		1 : "Yes, clear previous levels"
	]
	maxpropscreenwidth(float) : "Start Fade Pixels" : -1 : "Number of pixels wide at which all props in the level start to fade (<0 = use fademaxdist). This number is ignored if the prop has a specific fade distance specified."
	minpropscreenwidth(float) : "End Fade Pixels" : 0 : "Minimum number of pixels wide at which the prop is visible (0 = don't fade out). This number is ignored if the prop has a specific fade distance specified."
]

@PointClass base(Targetname, Parentname) tags( Sound ) iconsprite("editor/ambient_generic.vmat") sphere() = ambient_generic : "Universal ambient sound. Use it to play and control a single sound."
[
	message(sound) [report] : "Sound Name" : "" : "Name of the GameSound entry for the sound to play. Also supports direct .wav filenames."
	health(integer) : "Volume" : 10 : "Sound volume, expressed as a range from 0 to 10, where 10 is the loudest."
	preset(choices) :"Dynamic Presets" : 0 =						// NEEDHELP
	[
		0: "None"
		1: "Huge Machine"
		2: "Big Machine"
		3: "Machine"
		4: "Slow Fade in"  
		5: "Fade in"
		6: "Quick Fade in"
		7: "Slow Pulse"
		8: "Pulse"
		9: "Quick pulse"
		10: "Slow Oscillator"
		11: "Oscillator"
		12: "Quick Oscillator"
		13: "Grunge pitch"
		14: "Very low pitch"
		15: "Low pitch"
		16: "High pitch"
		17: "Very high pitch"
		18: "Screaming pitch"
		19: "Oscillate spinup/down"
		20: "Pulse spinup/down"
		21: "Random pitch"
		22: "Random pitch fast"
		23: "Incremental Spinup"
		24: "Alien"
		25: "Bizzare"
		26: "Planet X"
		27: "Haunted"
	]
	volstart(integer) : "Start Volume" : 0							// NEEDHELP
	fadeinsecs(integer) : "Fade in time in seconds (0-100)" : 0		// NEEDHELP
	fadeoutsecs(integer) : "Fade out time in seconds (0-100)" : 0	// NEEDHELP
	pitch(integer) : "Pitch" : 100 : "Sound pitch, expressed as a range from 1 to 255, where 100 is the sound's default pitch."
	pitchstart(integer) : "Start Pitch" : 100						// NEEDHELP
	spinup(integer) : "Spin up time (0-100)" : 0					// NEEDHELP
	spindown(integer) : "Spin down time (0-100)" : 0				// NEEDHELP
	lfotype(integer) : "LFO type 0)off 1)sqr 2)tri 3)rnd" : 0		// NEEDHELP
	lforate(integer) : "LFO rate (0-1000)" : 0						// NEEDHELP
	lfomodpitch(integer) : "LFO mod pitch (0-100)" : 0				// NEEDHELP
	lfomodvol(integer) : "LFO mod vol (0-100)" : 0					// NEEDHELP
	cspinup(integer) : "Incremental Spinup Count" : 0				// NEEDHELP
	radius(string) : "Max Audible Distance" : "1250" : "Maximum distance at which this sound is audible."
	spawnflags(flags) =
	[
		1: "Play everywhere" : 0
		16:"Start Silent": 1
		32:"Is NOT Looped": 1
	]
	SourceEntityName(target_destination) : "SourceEntityName" : : "If an entity is specified, sound will come from this named entity instead of the location of ambient_generic."

	// Inputs
	input Pitch(integer) : "Sets the sound pitch, expressed as a range from 1 to 255, where 100 is the sound's default pitch."
	input PlaySound(void) : "Starts the sound."
	input StopSound(void) : "Stops the sound if it is playing."
	input ToggleSound(void) : "Toggles the sound between playing and stopping."
	input Volume(integer) : "Sets the sound volume, expressed as a range from 0 to 10, where 10 is the loudest."
	input FadeIn(integer) : "Fades the sound up to full volume over a specified number of seconds, with a range from 0 to 100 seconds."
	input FadeOut(integer) : "Fades the sound to silence over a specified number of seconds, with a range from 0 to 100 seconds."
]

@PointClass base(Targetname, Parentname) tags( Sound ) iconsprite("editor/snd_event.vmat") = point_soundevent :
	"Plays a sound event from a point. The point can be this entity or a specified entity's position."
[
	soundName(sound) [report]: "Sound Event Name" : "" : "Name of the sound event to play"
	sourceEntityName(target_destination) : "Source Entity Name" : "" : "Name of the entity the sound should emit from."
	startOnSpawn(boolean) : "Start On Spawn" : "" : "Play the sound immediately upon spawning"
	toLocalPlayer(boolean) : "To Local Player" : "" : "Play the sound directly to the local player"
	stopOnNew(boolean) : "Re-trigger Stops Last" : 1 : "Stop a previously playing event when a new one is started"
	saveAndRestore(boolean) : "Save/Restore" : 0 : "This soundevent should be saved and restored."
	sourceEntityAttachment(string) : "Entity Attachment Name" : : "If set, will play the soundevent from this attachment point."
	entityIndexSelection(choices) :"Entity Index Selection" : 0 =	
	[
		0: "Use World Index"
		1: "Use Entity Index"
	]

	// Inputs
	input SetSourceEntity(string) : "Set the name of the entity to play the sound from. The sound will follow the entity as it moves."
	input SetSoundEventName(string) : "Set the name of the sound event to play"
	input StartSound(void) : "Start the sound event. If an entity name is provided, the sound will originate from that entity"
	input PauseSound(void) : "Pause the sound event."
	input UnPauseSound(void) : "UnPause the sound event."
	input StopSound(void) : "Stop the sound event"
	
	output SoundEventGuid(integer) : "Sound Event GUID"
	output OnSoundFinished(void) : "Fired when the sound finished playing"
]

@PointClass base(point_soundevent) tags( Sound ) iconsprite("editor/snd_event.vmat") = snd_event_point :
	"Plays a sound event from a point. The point can be this entity or a specified entity's position."
[
]

@PointClass base(point_soundevent) tags( Sound ) iconsprite("editor/snd_event.vmat") sphere(radius) = snd_event_sphere :
	"Plays a sound event from the closest point on a sphere to the player. The origin can be this entity or a specified entity's position."
[
	radius(float) : "Radius" : "5.0" : "Size of soundevent sphere"
]

@PointClass base(point_soundevent) tags( Sound ) iconsprite("editor/snd_event.vmat") box_oriented( box_mins, box_maxs ) = snd_event_alignedbox :
	"Plays a sound event from a point, passes along the min and max positions of its AABB. The point can be this entity or a specified entity's position."
[
	box_mins(vector) : "Box Mins" : "-64 -64 -64"
	box_maxs(vector) : "Box Maxs" : "64 64 64"
]

@PointClass base(point_soundevent) tags( Sound ) iconsprite("editor/snd_event.vmat") box_oriented( box_mins, box_maxs ) = snd_event_orientedbox :
	"Plays a sound event from a point closest to the player on the box."
[
	box_mins(vector) : "Box Mins" : "-64 -64 -64"
	box_maxs(vector) : "Box Maxs" : "64 64 64"
]

@PointClass base(Targetname, Parentname) tags( Sound ) iconsprite("editor/snd_event.vmat") = snd_event_path_corner :
	"Plays some number of soundevents (up to max) along segments of a path corner network"
[
	soundName(sound) [report]: "Sound Event Name" : "" : "Name of the sound event to play"
	startOnSpawn(boolean) : "Start On Spawn" : "" : "Play the sound immediately upon spawning"

	pathCornerEntity(target_destination) : "Path Corner Entity Name" : "" : "Name of the first path corner node in the chain"
	soundeventCountMax(integer) : "Max Soundevents" : "5" : "The max number of soundevents the path corner chain will emit"
	distanceMax(float) : "Max Distance" : "500" : "The distance beyond which a segment will not emit a soundevent"
	dotProductMax(float) : "Max Dot Product" : "1.1" : "For excluding soundevents that are close to eachother"

	//Inputs
	input StartSound(void) : "Start the sound event. If an entity name is provided, the sound will originate from that entity"
	input StopSound(void) : "Stop the sound event"
]

@PointClass base(Targetname, Parentname, point_soundevent) arc_range{ is_local_axis = true align_pie_to_local_forward = true is_enabled_key = true radius = "50" fov_key = "emitterAngle"} arc_range{ is_local_axis = true align_pie_to_local_forward = true is_enabled_key = true radius = "60" fov_key = "sweetSpotAngle" draw_triangle = false} tags( Sound ) iconsprite("editor/snd_event.vmat") editormodel("models/editor/cone_helper.vmdl") = snd_event_cone :
[
	parameterName(string) : "Attenuation Parameter Name" : "volume_atten" : "Name of the parameter to set"
	emitterAngle(float) [ min="0", max="359" ] : "Emitter Cone Angle" : "45" : "Angle of the emitter cone"
	sweetSpotAngle(float) [ min="0", max="359" ] : "Emitter Cone Sweet Spot" : "5" : "Angle of the 'sweet spot' in the emitter cone"
	attenMin(float) : "Minimum Attenuation Value" : "0.5" : "Attenuation Value when the player is outside of the cone"
	attenMax(float) : "Maximum Attenuation Value" : "1.0" : "Attenuation Value when the player is inside the sweet spot"
]

@PointClass base(Targetname) tags( Sound ) iconsprite("editor/snd_event.vmat") = snd_stack_save :
	"Save/Load the fields of a specific operator stack."
[
	stackToSave(string) : "Stack Name" : "" : "Name of the stack to save op fields."
]

@PointClass base(Targetname, Parentname) tags( Sound ) iconsprite("editor/snd_opvar_set.vmat") = snd_event_param :
	"Set a public parameter of a playing soundevent."
[
	parameterName(string) : "Parameter Name" : "" : "Name of the parameter to set"
	floatValue(float) : "Float Value" : "" : "Single float value to set on parameter."

	// Inputs
	input SetParamName(string) : "Set the name of the parameter to set on the soundevent."
	input SetFloatValue(float) : "Set the name of the sound event to play."
	input SetSoundEventGUID(integer) : "Start the sound event using a snd_event_point and pass its guid output to this."
]

@PointClass base(Targetname) tags( Sound ) iconsprite("editor/snd_opvar_set.vmat") = snd_opvar_set :
	"Sets an opvar value on a library stack"
[
	stackName(string) : "Stack Name" : "" : "The name of the stack the operator is in"
	operatorName(string) : "Operator Name" : "" : "The name of the operator the OpVar is in"
	opvarName(string) : "OpVar Name" : "" : "The name of the OpVar to change"
	opvarValueType(choices) : "Opvar Value Type" : "0" : "The interpreted type of value to be set on the opvar." =
	[
		0 : "Float"
		1 : "String"
	]	
	opvarValue(float) : "OpVar Float" : "1.0" : "Value to set the OpVar to"
	opvarValueString(string) : "OpVar String" : "null" : "String to set the OpVar to"
	opvarIndex(integer) : "OpVar Index" : "0" : "Index of the OpVar to set"
	setOnSpawn(boolean) : "Set on Spawn" : 0 : "Set the opvar upon spawning"
	
	// inputs
	input SetStackName(string) : "Change the target stack name"
	input SetOperatorName(string) : "Change the target operator name"
	input SetOpvarName(string) : "Change the target opvar name"	
	input SetOpvarIndex(integer) : "Change the target opvar index"	
	input ChangeOpvarValue(float) : "Change the value of the OpVar (does not set it in the stack)"
	input ChangeOpvarValueAndSet(float) : "Change the value of the OpVar and set it in the stack"
	input SetOpvar(void) : "Set the OpVar value in the stack"
	input SetSoundEventGUID(integer) : "Start the sound event using a snd_event_point and pass its guid output to this."
]

//@PointClass base( Targetname ) tags( Sound ) = snd_opvar_set_curve : "Drive a sound system opvar by a curve over time when activated."
//[
//	stackName(string) : "Stack Name" : "" : "The name of the stack the operator is in"
//	operatorName(string) : "Operator Name" : "" : "The name of the operator the OpVar is in"
//	opvarName(string) : "OpVar Name" : "" : "The name of the OpVar to change"
//	opvarIndex(integer) : "OpVar Index" : "0" : "Index of the OpVar to set"
//	curve( curve ) : "Curve" : "" : "X is time (in seconds), Y is attribute value."
//	
//	// inputs
//	input Start( void ) : "Activate the render attribute."
//	input SetStackName(string) : "Change the target stack name"
//	input SetOperatorName(string) : "Change the target operator name"
//	input SetOpvarName(string) : "Change the target opvar name"	
//	input SetOpvarIndex(integer) : "Change the target opvar index"	
//	input SetSoundEventGUID(integer) : "Start the sound event using a snd_event_point and pass its guid output to this."
//]

@BaseClass = SndOpvarSetPointBase
[ 
	stackName(string) : "Stack Name" : "" : "The name of the stack the operator is in"
	operatorName(string) : "Operator Name" : "" : "The name of the operator the OpVar is in"
	opvarName(string) : "OpVar Name" : "" : "The name of the OpVar to change"
	opvarUseAutoCompare(bool) : "Use Auto Compare" : "0" : "All entities that point to the same opvar and have this selected will automatically have their values compared and the largest set to the opvar value"
	opvarArrayIndex(integer){ enabled={ variable="opvarUseAutoCompare" value="0" } } : "OpVar Index" : "" : "Index of the OpVar array to set"
	distanceMapMin(float) : "Distance Map Minimum" : "0.0" : "Minimum value to map distance to"
	distanceMapMax(float) : "Distance Map Maximum" : "1.0" : "Maximum value to map distance to"
	occlusionRadius(float) : "Occlusion Radius" : "1.0" : "Size of the occlusion sphere"
	occlusionMin(float) : "Minimum Occlusion" : "1.0" : "Occlusion value when fully occluded"
	occlusionMax(float) : "Maximum Occlusion" : "1.0" : "Occlusion value when un-occluded"

	simulationMode(choices) : "Simulation Mode" : "0" : "Simulation Mode for occlusion check." =
	[
		0 : "Source 2"
		1 : "Steam Audio Raycast"
		2 : "Steam Audio Volumetric"
		3 : "Steam Audio Pathing"
		4 : "Steam Audio Dynamic Pathing"
	]	

	visibilitySamples(integer) : "Visibility Samples" : 8 : "Number of samples to use for volumetric occlusion or dynamic pathing."
	setToValueOnDisable(bool) : "Set OpVar value when disabled" : 0
	disabledValue(float) : "Set to value on disable" : "0.0" : "Value to set the OpVar index to when disabled"
	startDisabled(bool) : "Start Disabled" : 0
	autoDisable(bool) : "Disable when out of range" : 0
	entityUseFastRefreshRate(bool) : "Use Fast Refresh" : "0" : "Entity will run at a faster refresh rate when enabled.  Use sparingly."
	
	//Inputs
	input SetSoundEventGUID(integer) : "Start the sound event using a snd_event_point and pass its guid output to this."
	input SetStackName(string) : "Change the target stack name"
	input SetOperatorName(string) : "Change the target operator name"
	input SetOpvarName(string) : "Change the target opvar name"	
	input SetOpvarIndex(integer) : "Change the target opvar index"	
	input Enable(void) : "Enable the entity"
	input Disable(void) : "Disable the entity"
	input SetDisabledValue(void) : "Set the on-disable value for the player that causes this input"
	input SetDistanceMapMin(float) : "Set the min distance map value"
	input SetDistanceMapMax(float) : "Set the max distance map value"

	
	//Outputs
	output OnEnter(void) : "Fired when the player enters the outer distance."
	output OnExit(void) : "Fired when the player exits the outer distance."
]
@BaseClass = SndOpvarSetPointBaseAddition1
[ 
	distanceMin(float) : "Minimum Distance" : "5.0" : "Minimum distance to map the OpVar value to"
	distanceMax(float) : "Maximum Distance" : "25.0" : "Maximum distance to map the OpVar value to"
]

@BaseClass = SndOpvarSetPointBaseAddition2
[ 
	sourceEntityName(target_destination) : "Source Entity Name" : "" : "Name of the entity to check distance/occlusion from"	
	input SetSourceEntity(string) : "Set the name of the entity to check distance/occlusion from. This check will follow the entity as it moves."
]

@PointClass base( Targetname, Parentname, SndOpvarSetPointBaseAddition1, SndOpvarSetPointBaseAddition2, SndOpvarSetPointBase ) tags( Sound ) iconsprite("editor/snd_opvar_set.vmat") sphere(distanceMin) sphere(distanceMax) vecline_local( dynamicProxyPoint, 200, 255, 200 ) sphere(occlusionRadius, 255, 255, 0) = snd_opvar_set_point :
	"Sets an opvar value on a library stack"
[
	dynamicEntityName(target_destination) : "Dynamic Entity Name" : "" : "Name of the dynamic prop_door_rotating_physics entity to check for dynamic factor calculation."
	dynamicProxyPoint(local_point) : "Dynamic Proxy Point" : "" : "Position of a proxy point across a dynamic point to use for visiblity calculation. Make sure to set the Occlusion Radius such that it is entirely on one side of the dynamic object."
	dynamicMaximumOcclusion(float) : "Dynamic Maximum Occlusion" : "1.0" : "Value when the dynamic occlusion is considered fully unoccluded and return 1."
]

@PointClass base( Targetname, SndOpvarSetPointBase ) tags( Sound ) iconsprite("editor/snd_opvar_set.vmat") box_world_aligned( box_inner_mins, box_inner_maxs ) box_world_aligned( box_outer_mins, box_outer_maxs ) = snd_opvar_set_aabb :
	"Sets an opvar value on a library stack"
[
	AABBDirection(choices) : "Box Direction" : "0" : "Limit the evaluation of the box to a single axis" =
	[
		0 : "Any"
		1 : "X Only"
		2 : "Y Only"
		3 : "Z Only"
		4 : "No Z"
	]	
	box_inner_mins(vector) : "Box Inner Mins" : "-32 -32 -32"
	box_inner_maxs(vector) : "Box Inner Maxs" : "32 32 32"	
	box_outer_mins(vector) : "Box Outer Mins" : "-64 -64 -64"
	box_outer_maxs(vector) : "Box Outer Maxs" : "64 64 64"	
]
@PointClass base( Targetname, Parentname, snd_opvar_set_aabb ) tags( Sound ) iconsprite("editor/snd_opvar_set.vmat") box_oriented{ box_min = "box_inner_mins" box_max = "box_inner_maxs" draw_unselected_box = false} box_oriented{ box_min = "box_outer_mins" box_max = "box_outer_maxs" draw_unselected_box = false} = snd_opvar_set_obb :
[
]

@PointClass base( Targetname, SndOpvarSetPointBaseAddition1, SndOpvarSetPointBase ) tags( Sound ) iconsprite("editor/snd_opvar_set.vmat") = snd_opvar_set_path_corner:
[
	pathCornerEntityName(target_destination) : "Path Corner Starting Entity" : "" : "The name of the entity that is at the start of the path"
	useParentedPath(bool) : "Enable Path Corner Parenting" : "false" : "Enables the path corner entities to be parented to another entity and update their position accordingly"
]

@BaseClass = SndOpvarSetPointAutoRoomBase
[ 
	size(float) : "Size (radius)" : "25.0" : "Size of the room to analyze"
	height_tolerance(float) : "Height Tolerance (units)" : "50.0" : "If the player's height and the raycast height are within this many units, the difference is ignored when performing distance calculations"
]

@PointClass base( Targetname, SndOpvarSetPointAutoRoomBase, SndOpvarSetPointBaseAddition1, SndOpvarSetPointBase ) tags( Sound ) iconsprite("editor/snd_opvar_set.vmat") sphere(distanceMin) sphere(distanceMax) vecline_local( dynamicProxyPoint, 200, 255, 200 ) sphere(occlusionRadius, 255, 255, 0) sphere(size, 250, 101, 252)= snd_opvar_set_auto_room :
	"Analyzes a mostly enclosed space and defines walls and doorways within that space. Sets an opvar value on a library stack based on distance from the doorways"
[
]

@PointClass base( Targetname, Parentname ) tags( Sound ) iconsprite("editor/snd_opvar_set.vmat") box_oriented( box_mins, box_maxs ) = snd_opvar_set_wind_obb:
[
	stackName(string) : "Stack Name" : "" : "The name of the stack the operator is in"
	operatorName(string) : "Operator Name" : "" : "The name of the operator the OpVar is in"
	opvarName(string) : "OpVar Name" : "" : "The name of the OpVar to change"
	opvarUseAutoCompare(bool) : "Use Auto Compare" : "0" : "All entities that point to the same opvar and have this selected will automatically have their values compared and the largest set to the opvar value"
	opvarArrayIndex(integer){ enabled={ variable="opvarUseAutoCompare" value="0" } } : "OpVar Index" : "" : "Index of the OpVar array to set"
	wind_min(float) : "Minimum Wind Value" : "0.0" : "Minimum value of env_wind"
	wind_max(float) : "Maximum Wind Value" : "1.0" : "Maximum value of env_wind"
	wind_map_min(float) : "Minimum Wind Map Value" : "0.0" : "Minimum value to map env_wind to opvar"
	wind_map_max(float) : "Maximum Wind Map Value" : "1.0" : "Maximum value to map env_wind to opvar"
	box_mins(vector) : "Box Mins" : "-32 -32 -32"
	box_maxs(vector) : "Box Maxs" : "32 32 32"	
	
	// inputs
	input SetStackName(string) : "Change the target stack name"
	input SetOperatorName(string) : "Change the target operator name"
	input SetOpvarName(string) : "Change the target opvar name"	
	input SetOpvarIndex(integer) : "Change the target opvar index"	
	input SetSoundEventGUID(integer) : "Start the sound event using a snd_event_point and pass its guid output to this."
]

@BaseClass = SndSoundAreaBase
[ 
	soundAreaType(string) : "Sound Area Type" : "" : "Name of the type of Sound Area"
	startDisabled(bool) : "Start Disabled" : 0
	
	//Inputs
	input Enable(void) : "Enable the entity"
	input Disable(void) : "Disable the entity"
	
]

@PointClass base( Targetname, SndSoundAreaBase ) tags( Sound ) iconsprite("editor/snd_opvar_set.vmat") sphere(areaRadius) = snd_sound_area_sphere :
	"Creates a spherical Sound Area"
[
	areaRadius(float) : "Sound Area Radius" : "25.0" : "The radius of the Sound Area"
]

@PointClass base( Targetname, SndSoundAreaBase ) tags( Sound ) iconsprite("editor/snd_opvar_set.vmat") box_oriented( areaMin, areaMax ) = snd_sound_area_obb :
	"Creates a box Sound Area"
[
	areaMin(vector) : "Sound Area Min" : "-32 -32 -32"
	areaMax(vector) : "Sound Area Max" : "32 32 32"	
]

@PointClass base(Targetname) iconsprite("editor/env_texturetoggle.vmat") = env_texturetoggle : 
	"An entity that allows you to change the textures on other brush-built entities."
[
	target(target_destination) : "Target Brush(es)." 

	// Inputs
	input	IncrementTextureIndex(void) : "Increments target brush's current texture frame by one."
	input	SetTextureIndex(integer) : "Sets target brush's texture frame to the specified index."
]

@PointClass base(Targetname) box_oriented( anim_bounds_min, anim_bounds_max) model() = texture_based_animatable
[
	model(studio) : "Model" : ""
	fps(float) : "Frames Per Second" : "60"
	loop(boolean) : "Loop" : "0"
	texture_based_animation_preview_sequence(float) [ min="0.0", max="1.0" ] : "Preview Sequence"
	texture_based_animation_position_keys(resource:texture) : "Position Keyframes"
	texture_based_animation_rotation_keys(resource:texture) : "Rotation Keyframes"
	anim_bounds_min(vector) : "Animation Bounds Min" : "0 0 0" : "Minimum extents of the model throughout the whole animation" 
	anim_bounds_max(vector) : "Animation Bounds Max" : "0 0 0" : "Maximum extents of the model throughout the whole animation" 
	lightingorigin(target_destination) : "Lighting Origin" : "" : "Select an info_lighting to specify a location to sample lighting from, instead of its own origins."


	input Start(void) : "Starts the animation"
	input Stop(void) : "Stops the animation"
	StartDisabled(boolean) : "Start Disabled" : 0
	input Enable(void) : "Enable the Object."
	input Disable(void): "Disable the Object."
]


@PointClass base(Targetname) = env_splash : 
	"An entity that creates a splash effect at its origin. If the 'find water surface' spawnflag is set, it will instead trace down below itself to find the water surface on which to create splashes."
[
	scale(float) : "Scale of the splash" : "8.0"

	// Inputs
	input Splash(void) : "Create a splash effect."

	spawnflags(flags) =
	[
		1: "Automatically find water surface (place entity above water)" : 0
		2: "Diminish with depth (diminished completely in 10 feet of water)" : 1
	]
]

@PointClass base(Targetname) global( tonemap ) tonemap() iconsprite("materials/editor/env_tonemap_controller.vmat") = env_tonemap_controller :
	"An entity that controls the HDR tonemapping for the player. Think of it as a method of controlling the exposure of the player's eyes."
[
	MinExposure(float)   : "Minimum Auto Exposure"		: "0.25"
	MaxExposure(float)   : "Maximum Auto Exposure"		: "8.0"
	percent_bright_pixels(float) : "Target Bright Pixel Percentage" : "-1.0" : "Set a target for percentage of pixels above a certain brightness. (-1 for default engine behavior)"
	percent_target(float) : "Target Brightness Percent" : "-1.0" : "Set a custom brightness target to go along with 'Target Bright Pixel Percentage'. (-1 for default engine behavior)"
	rate(float) : "Rate" : "2.0"
	master(boolean) 	: "Master"	: 0 : "The master tonemap controller for the map presents the default values to use. Will be used initially and whenever active tonemaps are disabled." 

	input Enable(void) : "Enables this tonemap controller"
	input Disable(void) : "Enables this tonemap controller"
	input SetMinExposure(float) : "Sets min exposure for this tonemap controller"
	input SetMaxExposure(float) : "Sets max exposure for this tonemap controller"
	input SetPercentTarget(float) : "Sets percentage target for this tonemap controller"
	input SetPercentBrightPixels(float) : "Sets percentage bright pixels for this tonemap controller"
	input SetMinAverageLuminosity(float) : "Sets average luminosity for this tonemap controller"
	input SetRate(float) : "Sets rate of adjustment for this tonemap controller"
	input SetAccelerateExposureDown(float) : "Sets accelerate exposure down for this tonemap controller"
]


@PointClass base(Targetname) = game_ragdoll_manager : 
	"An entity to control the number of ragdolls in the world, for performance reasons." 
[
	MaxRagdollCount(integer) : "Max Ragdoll Count" : -1 : "Sets the max number of ragdolls that can be in the world at a time (if they are flagged to fade). Set to -1 if you want to use the default value (g_ragdoll_maxcount)."
	SaveImportant(boolean) : "Save Important Ragdolls" : 0 : "Should the ragdoll manager make sure ally ragdolls aren't deleted?"
	CanTakeDamage(boolean) : "Ragdolls Take Damage" : 0 : "Can ragdolls be damaged and eventually destroyed if they have health?"
	
	// Inputs
	input SetMaxRagdollCount(integer) : "Set the Max Ragdoll Count."
]

@PointClass base(Targetname) = game_gib_manager : "An entity to control the number of gibs in the world, for performance reasons." 
[
	maxpieces(integer)	: "Max Gib Count" : -1 : "Sets the max number of gib that can be spawned at a time. (-1=no limit)"
	allownewgibs(boolean)	: "Allow New Gibs To Spawn" : 0 : "If true, when the max gib count is reached, oldest gibs are removed as new gibs spawn. If false, new gibs will not be spawned once the gib limit is reached."
	
	input SetMaxPieces(integer)	: "Set the max gib count."
]

@PointClass base(Parentname) tags( Particles ) color(255 255 255) = env_smokestack : 
	"An entity that spits out a constant stream of smoke. See particlezoo.vmf for sample usage. You can place up to two env_particlelight entities near the smoke stack to add ambient light to its particles."
[
	targetname(target_source) : "Name" : : "The name that other entities refer to this entity by."

	InitialState(choices) : "Initial State" : 0 = 
	[
		0 : "Off"
		1 : "On"
	]

	BaseSpread(integer) : "Spread at the base" : 20 : "Amount of random spread in the origins of the smoke particles when they're spawned."
	SpreadSpeed(integer) : "Spread Speed" : 15 : "Amount of random spread in the velocity of the smoke particles after they're spawned."
	Speed(integer) : "Speed" : 30 : "The speed at which the smoke particles move after they're spawned."
	StartSize(integer) : "Particle start size" : 20 : "Size of the smoke particles when they're first emitted."
	EndSize(integer) : "Particle end size" : 30 : "Size of the smoke particles at the point they fade out completely."
	Rate(integer) : "Emission rate" : 20 : "Rate at which to emit smoke particles (i.e. particles to emit per second)."
	JetLength(integer) : "Length of smoke trail" : 180 : "Length of the smokestack. Lifetime of the smoke particles is derived from this & particle speed."
	WindAngle(integer) : "Wind X/Y Angle" : 0 : "This specifies the wind direction. It is an angle in the XY plane. WindSpeed specifies the strength of the wind."
	WindSpeed(integer) : "Wind Speed" : 0 : "The strength of the wind."
	SmokeMaterial(string) : "Particle material" : "particle/SmokeStack.vmat" : "Material of the smoke particles emitted by this stack."
	twist(integer) : "Twist" : 0 : "The amount, in degrees per second, that the smoke particles twist around the origin."
	roll(float)			: "Roll Speed": 0 : "Amount of roll in degrees per second."
	
	rendercolor(color255) : "Base Color (R G B)" : "255 255 255"

	renderamt(integer) : "Translucency" : 255
	
	// Inputs
	input TurnOn(void) : "Turn on the smokestack."
	input TurnOff(void) : "Turn off the smokestack."
	input Toggle(void) : "Toggles the smokestack between on and off state."
	input JetLength(integer): "Set the length of the smoke trail."
	input Rate(integer) : "Set the rate at which to emit smoke particles (particles per second)."
	input Speed(integer) : "Set the speed at which the smoke particles move after they're spawned."
	input SpreadSpeed(integer) : "Set the amount of random spread in the velocity of the smoke particles after they're spawned."
]

@PointClass base(Targetname) iconsprite("editor/env_fade") = env_fade : 
	"An entity that controls screen fades."
[
	spawnflags(flags) =
	[
		1: "Fade From" : 0
		2: "Modulate" : 0
		4: "Triggering player only" : 0
		8: "Stay Out" : 0
	]
	duration(string) : "Duration (seconds)" : "2" : "The time that it will take to fade the screen in or out."
	holdtime(string) : "Hold Fade (seconds)" : "0" : "The time to hold the faded in/out state."
	renderamt(integer) : "Fade Alpha" : 255 : "Alpha of the fade, where 0 = fully transparent and 255 = fully opaque." 
	rendercolor(color255) : "Fade Color (R G B)" : "0 0 0"
	
	// Inputs
	input Fade(void) : "Start the screen fade."

	// Outputs
	output OnBeginFade(void) : "Fired when the fade has begun."
]

@SolidClass base(Targetname) tags( Trigger ) = trigger_tonemap : "Changes tonemap controllers for players touching the trigger."
[
	TonemapName(target_destination) : "Tonemap Name" : : "The name of the tonemap controller entity associated with this trigger."
]

@PointClass base(Targetname, Parentname) tags( Info ) sweptplayerhull() = func_useableladder : 
	"A Half-Life 2 ladder. Handles player auto mount/unmount, as well as +use to get onto the ladder.<br><br>"+
	"See also 'info_ladder_dismount', used to specify ladder auto-dismount points.<br><br>"+
	"<b>Note:</b> This entity is non-functional in Counter-Strike: Source. Use func_ladder instead."
[
	spawnflags(flags) =
	[
		1: "Fake Ladder" : 0
	]

	point1(local_point) : "End" : : "Ladder end point."

	StartDisabled(boolean) : "Start Disabled" : 0

	AutoRideSpeed(float) : "Auto Ride Speed" : 0

	// Inputs
	input Enable(void) : "Enable this ladder."
	input Disable(void) : "Disable this ladder."

	output OnPlayerGotOnLadder(void) : "Fired whenever a player gets on this ladder."
	output OnPlayerGotOffLadder(void) : "Fired whenever a player gets off this ladder."
	ladderSurfaceProperties(string) : "Surface properties (optional)"
]

@PointClass base(Parentname) tags( Info ) size( -16 -16 0, 16 16 4 ) color(255 128 255)= info_ladder_dismount : 
	"An entity to handle endpoints for multiple ladders that are too close to each other."
[
	target(target_destination) : "LadderName" : : "If multiple ladders are near multiple endpoints, use this to stop them from interfering with each other."
]

@SolidClass base(Targetname, RenderFields, Global, Shadow)  sphere(fademindist) sphere(fademaxdist) = func_wall : 
	"Legacy support. Use func_brush instead." 
[
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
]

@SolidClass base(Targetname, Parentname, EnableDisable) = func_clip_interaction_layer : 
	"A brush entity that is conditionally solid based on the interaction layer specified." 
[
	InteractsAs(string) : "Interacts As" : "Default" : "Set the interacts as layer"
	InteractsWith(string) : "Interacts With" : "Default" : "Set the interacts with layer"
]

@SolidClass base(Targetname, Parentname, RenderFields, Global, Inputfilter, EnableDisable, Shadow) sphere(fademindist) sphere(fademaxdist) = func_brush : 
	"An brush built entity with various features." 
[
	spawnflags(flags) =
	[
		2: "Ignore player +USE" : 1
	]

	add_attribute(string) : "Add Attribute" : "" : "Will add an additional attribute that AI/player entities can query when checking props for information (ex: 'DogToy' or 'GrabbableResource')"

	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	Solidity(choices) : "Solidity" : 1 : "Used to control the solidity/collision of these brushes." =
	[
		0 : "Toggle"
		1 : "Never Solid"
		2 : "Always Solid"
	]
	excludednpc(string) : "NPC class excluded from collisions" : "" : "If an NPC classname is specified here, NPCs of that type won't collide with these brushes. In Episodic, you may also specify an individual entity's name."
	invert_exclusion(choices) : "Invert NPC class exclusion" : 0 : "If set, then the excluded NPC class will consider this brush solid, and all other NPC classes will consider it non-solid." =
	[
		0 : "No"
		1 : "Yes"
	]	

	interactAs(string) [ group="Physics Properties" ] : "interactAs" : "" : "comma-separated list of interaction layers"
	interactWith(string) [ group="Physics Properties" ] : "interactWith" : "" : "comma-separated list of interaction layers to interact with"
	interactExclude(string) [ group="Physics Properties" ] : "interactExclude" : "" : "comma-separated list of interaction layers to not collide with"
	solidbsp(boolean) : "Solid BSP" : 0 : "Set this if this brush is in hierarchy with a moving object of some kind, and the player can stand on this brush."
	ScriptedMovement(boolean) : "Scripted Movement" : 0 : "Set this to allow vscript code to move the brush via SetVelocity() calls."
	vrad_brush_cast_shadows(boolean) : "Shadows" : 0 : "Set this if this brush casts lightmap shadows."
	NoInterpolate(boolean) [ group="Misc" ] : "Disable Client-Side Interpolation" : 0
	
	input Alpha(integer) : "Sets the brush's alpha value."
	input SetExcluded( string ) : "Change the NPC class excluded from collisions"
	input SetInvert( integer ) : "Set the state of invversion for NPC class exclusion (0 or 1)"
	input SetSolid( void ) : "Enables all collisions with this func_brush."
	input SetNonsolid( void ) : "Disables all collisions with this func_brush."
	input Toggle(void) : "Toggle enable state."
]


//-------------------------------------------------------------------------
//
// A Vgui screen in 3D
//
//-------------------------------------------------------------------------
@BaseClass base(Targetname, Parentname) = VGUIScreenBase
[
	panelname(string) : "Panel Name"
	overlaymaterial(material) : "Overlay Material" : "" : "Name of a material to overlay over the top of the VGUI screen. NOTE: This material must write Z for the VGUI screen to work."
	width(integer) : "Panel Width in World" : 32 : "Width of the panel in units."
	height(integer) : "Panel Height in World" : 32 : "Height of the panel in units."

	// Inputs
	input SetActive(void) : "Make the vgui screen visible."
	input SetInactive(void) : "Make the vgui screen invisible."
]

@PointClass base(Targetname, Parentname) editormodel("models/editor/axis_helper_thick.vmdl") = vgui_slideshow_display : "Slideshow Display"
[
	displaytext(string) : "Display Text" : ""

	directory(string) : "Image Directory (materials/vgui/...)" : "slideshow"

	minslidetime(float) : "Min Slide Time" : "0.5" : "Minimum amount of random time that a slide is displayed."
	maxslidetime(float) : "Max Slide Time" : "0.5" : "Maximum amount of random time that a slide is displayed."

	cycletype(choices) : "Cycle Type" : 0 = 
	[
		0 : "Random"
		1 : "Forward"
		2 : "Backward"
	]

	nolistrepeat(choices) : "No List Repeat" : 0 = 
	[
		0 : "Allow List Repeats"
		1 : "No List Repeats"
	]

	width(integer) : "Panel width" : 256 : "Width of the panel in units."
	height(integer) : "Panel height" : 128 : "Height of the panel in units."

	input Enable(void) : "Make slideshow visible."
	input Disable(void) : "Make slideshow invisible."

	input SetDisplayText(string) : "Sets the display text."

	input RemoveAllSlides(void) : "Removes all slides from slideshow."
	input AddSlides(string) : "Adds slides by keyword."

	input SetMinSlideTime(float) : "Sets min random time between slides."
	input SetMaxSlideTime(float) : "Sets max random time between slides."

	input SetCycleType(integer) : "0 - random, 1 - forward, 2 - backward"
	input SetNoListRepeat(bool) : "Sets if lists can be randomly picked twice in a row."
]

@PointClass base(Targetname, Parentname) editormodel("models/editor/axis_helper_thick") = vgui_movie_display : "Movie Display"
[
	displaytext(string) : "Display Text" : ""
	moviefilename(string) : "Movie Filename" : "media/"
	groupname(string) : "Group Name" : ""

	looping(boolean) : "Loop Movie" : 0

	width(integer) : "Panel width" : 256 : "Width of the panel in units."
	height(integer) : "Panel height" : 128 : "Height of the panel in units."

	input Enable(void) : "Make movie visible."
	input Disable(void) : "Make movie invisible."

	input SetDisplayText(string) : "Sets the display text."
]

@PointClass base(Targetname, Parentname, RenderFxChoices, RenderFields, Studiomodel) model()
	metadata
	{
		model_archetypes = [  "animated_model" ]
		api_classes = [ "ai_base_actor" ]
	}
= func_orator : 
	"A very simple model entity that has animations and response rules."
[
	spawnflags(flags) =
	[
		1: "Not Solid" : 1
	]
	
	maxThenAnyDispatchDist(float) : "Max Followup Dist" : 0 : "A 'then ANY' followup on a response from this orator will dispatch to characters up to this many units away. Leave 0 to mean that even an infinitely distant character may respond."

	input SpeakResponseConcept(api)
]


//-------------------------------------------------------------------------
//
// Environmental effects
//
//-------------------------------------------------------------------------

@BaseClass base(Targetname, Parentname) = gibshooterbase
[
	angles(string) : "Gib Direction (Pitch Yaw Roll)" : "0 0 0" : "The direction the gibs will fly."
	m_iGibs(integer) : "Number of Gibs" : 3 : "Total number of gibs to shoot each time it's activated."
	delay(string) : "Delay between shots" : "0" : "Delay (in seconds) between shooting each gib. If 0, all gibs shoot at once."
	gibangles(string) : "Gib Angles (Pitch Yaw Roll)" : "0 0 0" : "The orientation of the spawned gibs."
	gibanglevelocity(string) : "Max angular velocity" : "0" : "How fast (degrees/sec) the gib pieces should spin. They will spin on x and y axis at between 10% and 100% of this speed."
	m_flVelocity(integer) : "Gib Velocity" : 200 : "Speed of the fired gibs"
	m_flVariance(string) : "Course Variance" : "0.15" : "How much variance in the direction gibs are fired."
	m_flGibLife(string) : "Gib Life" : "4" : "Time in seconds for gibs to live +/- 5%"
	lightingorigin(target_destination) : "Lighting Origin" : "" : "Select an entity to specify a location to sample lighting from for all gibs spawned by this shooter, instead of their own origins."

	spawnflags(Flags) = 
	[
		1 : "Repeatable"  : 0
	]

	// Inputs
	input Shoot(void) : "Force the gibshooter to create and shoot a gib."
]

@PointClass base(Targetname, Parentname, RenderFxChoices) size(-4 -4 -4, 4 4 4) line(255 255 255, targetname, LightningStart, targetname, LightningEnd) = env_beam : 
	"An entity that creates a visible beam between two points. The points can be attached to entities to make the beam move around."
[
	renderamt(integer) : "Brightness (1 - 255)" : 100
	rendercolor(color255) : "Beam Color (R G B)" : "255 255 255"
	Radius(integer) : "Radius" : 256 : "If the 'Random Strike' spawnflag is set, this radius determines the area within which the endpoints will randomly strike."
	life(string) : "Life (seconds 0 = infinite)" : "1" : "Amount of time before the beam dies. Setting to zero will make the beam stay forever."
	BoltWidth(float) : "Width of beam" : 2 : "Pixel width of the beam."
	NoiseAmplitude(float) : "Amount of noise (0-255)" : 0 : "The amount of noise in the beam. 0 is a perfectly straight beam."
	texture(sprite) : "Sprite Name" : "sprites/laserbeam.spr" : "The material used to draw the beam."
	TextureScroll(integer) : "Texture Scroll Rate (0-100)" : 35 : "Rate at which the beam texture should scroll along the beam."
	framerate(integer) : "Frames per 10 seconds" : 0 : "Framerate at which the beam texture should animate, if it has multiple frames."
	framestart(integer) : "Starting Frame" : 0 : "The frame to start the beam texture on."
	StrikeTime(string) : "Strike again time (secs)" : "1" : "Refire time between random strikes of the beam. Only used if the 'Random Strike' spawnflag is set."
	damage(string) : "Damage / second" : "0" : "How much damage this beam does per second to things it hits when it is continually on, or instantaneously if it strikes. For continuous damage, the value should be greater than 10 or it may not work."
	LightningStart(target_destination) : "Start Entity" : "" : "Entity that the beam starts at."
	LightningEnd(target_destination) : "Ending Entity" : "" : "Entity that the beam ends at."
	decalname(string) : "Decal Name" : "Bigshot" : "Decal to be applied at the end of the beam"
	HDRColorScale(float) : "HDR color scale." : "1.0" : "float value to multiply sprite color by when running in HDR mode."
	
	targetpoint(vecline) : "Endpoint handle" : "0 0 0" : "If a LightningEnd entity is not specified, use this point as the destination instead. If the env_beam moves, the destination point will move along with it."

	spawnflags(flags) = 
	[
		1 : "Start On" : 0
		2 : "Toggle" : 0
		4 : "Random Strike" : 0
		8 : "Ring" : 0
		16: "StartSparks" : 0
		32: "EndSparks" : 0
		64: "Decal End" : 0
		128: "Shade Start" : 0
		256: "Shade End" : 0
		512: "Taper Out" : 0
	]

	TouchType(choices) : "Touch Type (tripwire)" : 0 : "If you want the beam to fire an output when touched by entities, choose the entity type here." =
	[	
		0 : "Not a tripwire"
		1 : "Player Only"
		2 : "NPC Only"
		3 : "Player or NPC"
		4 : "Player or NPC or Physprop"
	]

	ClipStyle(choices) : "Beam clipping" : 0 : "Select whether you want the beam to clip against geometry or characters" =
	[	
		0 : "Do not clip (default)"
		1 : "Clip to geometry"
		2 : "Clip to everything solid"
	]

	filtername(filterclass) : "Filter Name" : : "Filter to use to see if activator triggers me. See filter_activator_name for more explanation."

	// Inputs
	input TurnOn(void) : "Turns the beam on."
	input TurnOff(void) : "Turns the beam off."
	input Toggle(void) : "Toggles the beam between on and off."
	input StrikeOnce(void) : "Causes the beam to strike once. It will stay on for its set Life and then turn off (it will never turn off if Life is set to zero)."
	input Alpha(integer) : "Sets the beam's alpha (0 - 255)."
	input Color(color255) : "Sets the beam's render color (R G B)."
	input ColorRedValue(float) : "Sets the red color channel's value (0 - 255)."
	input ColorGreenValue(float) : "Sets the green color channel's value (0 - 255)."
	input ColorBlueValue(float) : "Sets the blue color channel's value (0 - 255)."
	input Amplitude(float) : "Set the amplitude of beam noise (0 - 255)."
	input ScrollSpeed(float) : "Set the scroll speed in units per second (0 - 100)."
	input Width(float) : "Set the width of the beam, in pixels."

	// Outputs
	output OnTouchedByEntity(void) : "Fired when an entity touches the beam. Only fired if the entity passes the 'Touch Type' choice."
]

@PointClass base(Targetname, Parentname) size(-4 -4 -4, 4 4 4) = env_beverage : 
	"HL1 Legacy: Beverage Dispenser."
[
	health(integer) : "Capacity" : 10 : "Number of cans in the dispenser."
	beveragetype(choices) : "Beverage Type" : 0 = 
	[
		0 : "Coca-Cola"
		1 : "Sprite"
		2 : "Diet Coke"
		3 : "Orange"
		4 : "Surge"
		5 : "Moxie"
		6 : "Random"
	]

	input Activate(void) : "Enable this dispenser."
]

@PointClass base(Targetname, Parentname) size(-16 -16 -16, 16 16 16) color(255 0 0) = env_blood : 
	"An entity used to spawn blood effects." 
[
	spraydir(angle) : "Spray Direction (Pitch Yaw Roll)" : "0 0 0" : "The general direction that the blood should spray and the direction to trace to apply the decal."
	color(choices) : "Blood Color" : 0 =
	[
		0 : "Red (Human)"
		1 : "Yellow (Alien)"
	]
	amount(string) : "Amount of blood (damage to simulate)" : "100"
	spawnflags(flags) =
	[
		1: "Random Direction" : 0
		2: "Blood Stream" : 0
		4: "On Player" : 0
		8: "Spray decals" : 0
		// dvs: support these flags
		//16: "Cloud" : 0
		//32: "Drops" : 0
		//64: "Gore" : 0
	]

	// Inputs
	input EmitBlood(void) : "Triggers the blood effect."
]

@PointClass base(Targetname, Parentname, RenderModeChoices) iconsprite("editor/env_explosion.vmat") = env_explosion : 
	"An entity that creates an explosion at its origin." 
[
	iMagnitude(Integer) : "Magnitude" : 100 : "The amount of damage done by the explosion."
	// If no radius override, magnitude will determine radius.
	iRadiusOverride(Integer) : "Radius Override" : 0 : "If specified, the radius in which the explosion damages entities. If unspecified, the radius will be based on the magnitude."
	spawnflags(flags) =
	[
		1: "No Damage" : 0
		2: "Repeatable" : 0
		16: "No Decal" : 0
		64: "No Sound" : 0
		8192: "Damage above water surface only" : 0
		16384: "Generic damage" : 0
		32768: "Use Orientation for Custom Explosion" : 0
	]

	explosion_type(choices) : "Explosion Type" : "" : "" =
	[
		""					:	"Default"
		"grenade"			:	"Grenade"
		"molotov"			:	"Molotov"
		"fireworks"			:	"Fireworks"
		"gascan"			:	"Gasoline Can"
		"gascylinder"		:	"Pressurized Gas Cylinder"
		"explosivebarrel"	:	"Explosive Barrel"
		"electrical"		:	"Electrical"
		"emp"				:	"EMP"
		"shrapnel"			:	"Shrapnel"
		"smoke"				:	"Smoke Grenade"
		"flashbang"			:	"Flashbang"
		"tripmine"			:	"Tripmine"
		"ice"				:	"Ice"
		"none"				:	"None"
		"custom"			:	"Custom"
	]
	explosion_custom_effect(resource:particle) : "Custom Particle Effect"
	explosion_custom_sound(sound) : "Custom Sound Effect" : ""

	ignoredEntity(target_destination) : "Ignored Entity" : : "Do not harm or affect the named entity."
	ignoredClass(Integer) : "Ignored Class" : 0 : "Do not harm or affect this class."

	// Inputs
	input Explode(void) : "Triggers the explosion."
]

@PointClass base(Targetname, Parentname) color(200 50 0)  size(-8 -8 -8, 8 8 8) = env_smoketrail : 
	"An entity that creates a smoke trail." 
[
	opacity(float) : "Sprite Opacity" : "0.75" : "Opacity of the sprites (range from 0 - 1)."
	spawnrate(float) : "Spawn Rate" : "20" : "Number of particles to emit each second."
	lifetime(float) : "Particle Life Time" : "5.0" : "Number of seconds until each particle dies."
	startcolor(color255) : "Start Color" : "192 192 192" : "Starting color of the emitted particles."
	endcolor(color255) : "End Color" : "160 160 160" : "Ending color of the emitted particles."
	emittime(float) : "Emitter Life Time" : "0" : "Number of seconds until the env_smoketrail stops emitting particles. 0 means never stop emitting particles."
	minspeed(float) : "Minimum Random Speed" : "10" : "Minimum randomly-directed speed to use for emitted particles."
	maxspeed(float) : "Maximum Random Speed" : "20" : "Maximum randomly-directed speed to use for emitted particles."
	mindirectedspeed(float) : "Minimum Directed Speed" : "0" : "Minimum speed along the env_smoketrail's forward direction (x axis) to use for emitted particles."
	maxdirectedspeed(float) : "Maximum Directed Speed" : "0" : "Maximum speed along the env_smoketrail's forward direction (x axis) to use for emitted particles."
	startsize(float) : "Starting particle size" : "15" : "Starting particle size."
	endsize(float) : "Ending particle size" : "50" : "Ending particle size."
	spawnradius(float) : "Spawn radius" : "15" : "Distance from env_smoketrail at which particles are emitted."

	firesprite(sprite) : "Fire Sprite" : "sprites/firetrail.spr"
	smokesprite(sprite) : "Smoke Puff" : "sprites/whitepuff.spr"
]

@PointClass base(Targetname, Parentname) tags( Physics ) sphere() sphere(inner_radius) iconsprite("editor/env_physexplosion.vmat") = env_physexplosion : 
	"An entity that creates an explosion at its origin. If the no-damage spawnflag is set, the explosion won't be visible, but will apply force to any physics objects within its radius."
[
	magnitude(string) : "Magnitude" : "100" : "Amount of physics force applied by the explosion."
	damage(string) : "Damage" : "0" : "If specified, amount of damage to deal. If unspecified, magnitude is used as the damage."
	radius(string) : "Clamp Radius (0 = auto)" : "0" : "If specified, the radius in which the explosion damages entities. If unspecified, the radius will be based on the magnitude."
	targetentityname(target_destination) : "Limit to Entity" : "" : "If specified, the explosion will only affect the matching entity."
	explodeonspawn(boolean) : "Explode on spawn" : "Performs the physics explosion immediately upon spawning."

	spawnflags(flags) =
	[
		1 : "No Damage - Only Force" : 1
		2 : "Push players" : 0
		4 : "Push radially - not as a sphere" : 0
		8 : "Test LOS before pushing" : 0
		16 : "Disorient player if pushed" : 0
	]

	inner_radius(float) : "Inner radius" : "0" : "If not zero, the LOS is calculated from a point intersecting this sphere."

	pushscale(float) : "Physics push scale" : "1" : "Scale the applied physics force by this value."

	ConvertToDebrisWhenPossible(choices) : "Convert physics props to debris when possible" : "0" =
	[
		"0" : "No"
		"1" : "Yes"
	]

	AffectInvulnerableEnts(boolean) : "Affect Invulnerable Ents" : "1" : "If true, also push entities that do not take damage (like func_physbox)"

	// Inputs
	input Explode(void) : "Trigger the explosion."
	
	// Outputs
	output OnPushedPlayer(void) : "Fires when the player is pushed by the explosion."
]

@PointClass base(Targetname, Parentname) line(255 255 255, targetname, directionentityname) iconsprite("editor/env_physexplosion.vmat") = env_physimpact : 
	"An entity that will cause a physics impact on another entity."
[
	angles(string) : "Pitch Yaw Roll (Y Z X)" : "0 0 0" : "Direction to project the impact."
	magnitude(integer) : "Magnitude" : 100 : "Strength of the impact."
	distance(integer) : "Distance" : 0 : "How far to project the impact (if 0 uses a default value)."
	directionentityname(target_destination) : "Point to Entity" : "" : "If set, 'Distance' and Angle settings are ignored and the direction and distance to the target entity will be used."

	spawnflags(flags) =
	[
		1: "No fall-off" : 0
		2: "Infinite Length" : 0
		4: "Ignore Mass" : 0
		8: "Ignore Surface Normal When Applying Force" : 1
	]

	// Inputs
	input Impact(void) : "Trigger the impact"
]


//  This has been disabled until it can be reimplemented, destroyed, or renamed - jdw
//@PointClass base(Targetname, Parentname) size(-4 -4 -4, 4 4 4) = env_splash : 
//	"Can be used to create either a spash effect or a stream of falling or spurting liquid." +
//	"Will create a splash decal on the collided surface the same color as the liquid"
//[
//	spawnrate(float) : "SpawnRate"  : "10" : "How many particles some out"
//	startcolor(color255) : "StartColor" : "100 100 100" : "Color of particles when the are emitted"
//	endcolor(color255) : "EndColor" : "240 110 0" : "Color that particles approach"
//	speed(float) : "Speed" : 3 : "Averate speed of an emitted particles"
//	speedrange(float) : "SpeedRange" : 1 : "Speed range of an emitted particles"
//	widthmin(float) : "WidthMin" : 2 : "Width of smallest particle emitted"
//	widthmax(float) : "WidthMax" : 8 : "Width of largest particle emitted"
//	noise(float) : "Noise" : "0.1" : "Amount of directional noise in stream"
//	lifetime(float) : "Lifetime" : 5 : "Lifetime of particles (in secs)"
//	numdecals(integer) : "Num Decals" : 1 : "Number of decals used (keep small)"
//	startactive(boolean) : "Start On" : 1
//
//	// Inputs
//	input SetSpawnRate(float) : "Sets how many particles come out"
//	input SetSpeed(float) : "Sets speed of emitted particle"
//	input SetNoise(float) : "Sets noise of emitted particle (0-1)"
//	input SetLifetime(float) : "Sets lifetime of emitted particles (in seconds)"
//	input TurnOn(void) : "Turns particles on"
//	input TurnOff(void) : "Turns particles off"
//]

@PointClass base(Targetname, Parentname, EnableDisable) iconsprite("editor/env_fire") color(0 180 0) = env_fire : 
	"An entity that handles a single flame at its origin. The flame causes heat 'damage' to other env_fire entities around it, and will eventually ignite non-flaming env_fire entities nearby, causing the fire to spread."
[
	health(integer) : "Duration" : 30 : "Amount of time the fire will burn."
	firesize(integer) : "Size" : 64 : "Height (in world units) of the flame."
	fireattack(integer) : "Attack" : 4 : "Amount of time the fire takes to grow to full strength."
	firetype(choices) : "Type" : 0 =
	[
		0 : "Natural"
		1 : "Plasma"
	]
	spawnflags(flags) =
	[
		1:	"Infinite Duration" : 0
		2:	"Smokeless" : 0
		4:	"Start On" : 0
		8:	"Start Full" : 0
		16:	"Don't drop" : 0
		32: 	"No glow" : 0
		128: 	"Delete when out" : 0
		256: 	"Visible from above" : 0
	]

	ignitionpoint(float) : "Ignition Point" : 32 : "Amount of heat 'damage' to take before this flame should ignite."
	damagescale(float) : "Damage Scale" : "1.0" : "Multiplier of the burn damage done by the flame."

	// Inputs
	input StartFire(void) : "Start the fire."
	input Extinguish(float) : "Puts out the fire permanently in the number of seconds specified."
	input ExtinguishTemporary(float): "Puts out the fire temporarily in the number of seconds specified."

	// Outputs
	output OnIgnited(void) : "Fires when the fire is first ignited."
	output OnExtinguished(void) : "Fires when the fire is fully extinguished."
]

@PointClass base(Targetname, Parentname) iconsprite("editor/env_firesource") color(255 255 0) sphere(fireradius) = env_firesource : 
	"An entity that provides heat to all nearby env_fire entities. Cannot be extinguished."
[
	spawnflags(flags) =
	[
		1:	"Start On" : 0
	]

	fireradius(float) : "Radius" : 128 : "The radius around this entity in which to provide heat."
	firedamage(float) : "Intensity / Damage" : 10 : "Amount of heat 'damage' to apply to env_fire entities within the radius."

	// Inputs
	input Enable(void) : "Enable fire source."
	input Disable(void) : "Disable fire source."
]

@PointClass base(Targetname, Parentname) size(-4 -4 -4, 4 4 4) color(255 255 0) sphere(fireradius) = env_firesensor : 
	"An entity that detects changes in heat nearby."
[
	spawnflags(flags) =
	[
		1:	"Start On" : 1
	]

	fireradius(float) : "Radius" : 128 : "The radius around this entity in which to detect heat changes."
	heatlevel(float) : "Heat level" : 32 : "The target heat level to check for. Outputs are fired when the heat moves over this target level (increasing or decreasing)."
	heattime(float) : "Time at level" : 0 : "The amount of time the heat level must spend over the target level before the 'OnHeatLevelStart' output is fired."

	// Inputs
	input Enable(void) : "Enable fire sensor."
	input Disable(void) : "Disable fire sensor."
	output OnHeatLevelStart(void) : "Fires when the heat level has been sustained for the specified length of time."
	output OnHeatLevelEnd(void) : "Fires when the heat level drops below the target level."
]

@PointClass base(Targetname) size(-4 -4 -4, 4 4 4) color(0 180 0) = env_entity_igniter : 
	"An entity that catches a target entity on fire. If the entity is an animating model, it will have sprite flames attached to its skeleton. Otherwise the entity will emit particle flame puffs."
[
	target(target_destination) : "Entity to ignite" : : "Name of the entity to catch on fire."
	lifetime(float) : "Lifetime in seconds" : 10 : "Duration of flames."
	
	// Inputs
	input Ignite(void) : "Ignite the target entity."
]

@PointClass fog() base(Targetname) tags( Lighting ) iconsprite("materials/editor/env_fog_controller.vmat") global( fog ) color(255 255 255) = env_fog_controller : 
	"An entity that controls the fog and view distance in the map."
[
	// Inputs
	input SetStartDist(float) : "Set the fog start distance."
	input SetEndDist(float) : "Set the fog end distance."
	input TurnOn(void) : "Turn the fog on."
	input TurnOff(void) : "Turn the fog off."
	input SetColor(color255) : "Set the primary fog color."
	input SetColorSecondary(color255) : "Set the secondary fog color."
	input SetFarZ(integer): "Set the far clip plane distance."
	input SetAngles(string) : "Set the angles to use for the secondary fog direction."
	input Set2DSkyboxFogFactor(float) : "Set the current amount of fog to blend into the 2D skybox.  0 is no fog, 1 is fully fogged."
	input SetMaxDensity(float) : "Set the current max fog density."

	input SetColorLerpTo(color255) : "Set the primary fog color."
	input SetColorSecondaryLerpTo(color255) : "Set the secondary fog color."
	input SetStartDistLerpTo(float) : "Set the fog start distance."
	input SetEndDistLerpTo(float) : "Set the fog end distance."
	input Set2DSkyboxFogFactorLerpTo(float) : "Set the amount of fog to blend into the 2D skybox to lerp to.  0 is no fog, 1 is fully fogged."
	input SetMaxDensityLerpTo(float) : "Set the current max density to lerp to.  0 is no fog, 1 is fully fogged."
	input StartFogTransition(void) : "Start fog transition."

	// Starting fog parameters for the level. These are selectable per LOD.	
	fogenable(boolean) : "Fog Enable" : 1
	fogblend(boolean) : "Fog Blend" : 0
	use_angles(boolean) : "Use Angles for Fog Dir" : 0
	fogcolor(color255) : "Primary Fog Color" : "255 255 255"
	fogcolor2(color255) : "Secondary Fog Color" : "255 255 255"
	fogdir(string) : "Primary Fog Direction" : "1 0 0"
	fogstart(string) : "Fog Start" : "500.0"
	fogend(string) : "Fog End" : "2000.0"
	fogmaxdensity(float) : "Fog Max Density [0..1]" : "1"
	fogexponent(float) : "Fog Exponent [0..1]" : "2"

	foglerptime(float) : "Interpolate time" : "0"
	
	farz(string) : "Far Z Clip Plane" : "-1"

	HDRColorScale(float) : "HDR color scale." : "1.0" : "float value to multiply fog color by when running in HDR mode."

	spawnflags(flags) =
	[
		1 : "Master (Has priority if multiple env_fog_controllers exist)" : 0
	]
]

@PointClass base(Targetname) iconsprite("editor/postprocess_controller.vmat") color(255 255 255) = postprocess_controller : 
	"An entity that controls the postprocess settings in the map."
[
	// Inputs
	input SetFadeTime(float) : "Set the fade time between post process settings."
	input SetLocalContrastStrength(float) : "Set the local contrast strength."
	input SetLocalContrastEdgeStrength(float) : "Set the local contrast strength at the edge of the screen (controlled by vignette)."
	input SetVignetteStart(float) : "Set the vignette start distance (from screen center)."
	input SetVignetteEnd(float) : "Set the vignette end distance."
	input SetVignetteBlurStrength(float) : "Set the strength of the desaturated blur on the vignette."
	input SetFadeToBlackStrength(float) : "Set the fadeout strength."
	input SetGrainStrength(float) : "Set the film grain effect strength [0..1]"
	input SetTopVignetteStrength(float) : "Set top-of-screen vignette strength [0..1]"

	// Starting fog parameters for the level. These are selectable per LOD.	
	localcontraststrength(float) : "Local contrast strength [-1..x]" : "0"
	localcontrastedgestrength(float) : "Local contrast edge strength [0..1]" : "0"
	vignettestart(float) : "Vignette start distance [0..1]" : "1"
	vignetteend(float) : "Vignette end distance [0..x]" : "2"
	vignetteblurstrength(float) : "Vignette blur strength [0..1]" : "0"
	fadetoblackstrength(float) : "Fade to black strength [0..1]" : "0"
	grainstrength(float) : "Film grain strength [0..1]" : "1"
	topvignettestrength(float) : "Top-of-screen vignette strength [0..1]" : "1"
	fadetime(float) : "Fade-in time" : "2"
	
	spawnflags(flags) =
	[
		1 : "Master (Has priority if multiple postprocess_controllers exist)" : 0
	]
]


@PointClass base(Targetname, Parentname, RenderFxChoices) size(-4 -4 -4, 4 4 4) line(255 255 255, targetname, LaserTarget) = env_laser : 
	"An entity that creates a laser beam between itself and a given target."
[
	LaserTarget(target_destination) : "Target of Laser" : : "Name of entity, or entities, to strike at. The target is randomly chosen if there are multiple entities matching the given name."
	renderamt(integer) : "Brightness (1 - 255)" : 100
	rendercolor(color255) : "Beam Color (R G B)" : "255 255 255"
	width(float) : "Width of Beam" : 2 : "The width of the laser beam, in pixels."
	NoiseAmplitude(integer) : "Amount of noise (0-255)" : 0 : "The amount of noise in the beam. 0 is a perfectly straight beam."
	texture(sprite) : "Sprite Name" : "sprites/laserbeam.spr" : "The material used to draw the laser beam."
	EndSprite(sprite) : "End Sprite" : "" : "If specified, this sprite will be drawn at the end of the laser beam."
	TextureScroll(integer) : "Texture Scroll Rate (0-100)" : 35 : "Rate at which the beam texture should scroll along the beam."
	framestart(integer) : "Starting Frame" : 0 : "The frame to start the beam texture on."
	damage(string) : "Damage / second" : "100" : "How much damage this laser does. per second. to things it hits."
	dissolvetype(choices) : "Dissolve Type" : "None" =
	[
		-1 : "None"
		0 : "Energy"
		1 : "Heavy electrical"
		2 : "Light electrical"
	]
	spawnflags(flags) = 
	[
		1 : "Start On" : 0
		16: "StartSparks" : 0
		32: "EndSparks" : 0
		64: "Decal End" : 0
	]

	// Inputs
	input TurnOn(void) : "Turns the laser on."
	input TurnOff(void) : "Turns the laser off."
	input Toggle(void) : "Toggles the laser between on and off."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = env_message : 
	"An entity that draws a text message on player's HUDs."
[
	message(string) : "Message Text"
	spawnflags(flags) =
	[
		1: "Play Once" : 0
		2: "All Clients" : 0
	]
	messagesound(sound) : "Sound Effect" : "" : "When the message is shown, this sound effect will be played, originating from this entity."
	messagevolume(string) : "Volume 0-10" : "10" : "Volume of the sound effect."
	messageattenuation(Choices) : "Sound Radius" : 0 =
	[
		0 : "Small Radius"
		1 : "Medium Radius"
		2 : "Large  Radius"
		3 : "Play Everywhere"
	]
	
	// Inputs
	input ShowMessage(void) : "Shows the message and plays the sound."
	
	// Outputs
	output OnShowMessage(void) : "Fired when the message is activated."
]

@PointClass sphere() iconsprite("editor/env_shake.vmat") base(Targetname, Parentname) = env_shake : 
	"An entity to control screen shake on players." 
[
	spawnflags(flags) =
	[
		1: "GlobalShake" : 0
		4: "In Air" : 0		// shakes objects even if they are not onground
		8: "Physics" : 0	// shakes physically as well as the camera
		16: "Ropes" : 0		// shakes ropes too.
		32: "DON'T shake view (for shaking ropes or physics only)" : 0
		64: "DON'T Rumble Controller" : 0
		256: "Water" : 0	// shake water too.
	]

	limittoentity(target_destination) : "Limit to entity" : "" : "Limit the shake to entity or entities matching the name or class name."
	amplitude(float) : "Amplitude (0-16)" : "4" : "The amount of noise in the screen shake. Should be a range between 0 and 16."
	radius(float) : "Effect Radius" : "500" : "The radius around this entity in which to affect players."
	duration(float) : "Duration (seconds)" : "1" : "The length of time in which to shake the player's screens."
	frequency(float) : "Frequency" : "2.5" : "The frequency used to apply the screen shake. Should be a value between 0 and 255, where 0.1 = jerk, and 255.0 = rumble."

	// Inputs
	input Amplitude(string) : "Set the amplitude (0-16)"
	input Frequency(string) : "Set the frequence. Should be a value between 0 and 255, where 0.1 = jerk, and 255.0 = rumble."
	input StartShake(void) : "Start the shake."
	input StopShake(void) : "Stop the shake."
]

@PointClass sphere() editormodel("models/editor/axis_helper_thick") base(Targetname, Parentname) = env_tilt : 
	"An entity to control screen tilt on players." 
[
	spawnflags(flags) =
	[
		1: "GlobalTilt" : 0
		128: "Ease in/out" : 0
	]

	radius(float) : "Effect Radius" : "500" : "The radius around this entity in which to affect players."
	duration(float) : "Duration (seconds)" : "1" : "The length of time in which to tilt the player's screens."
	tilttime(float) : "Tilt time (seconds)" : "2.5" : "How long it takes to reach full tilt."

	// Inputs
	input StartTilt(void) : "Start the shake."
	input StopTilt(void) : "Stop the tilt."
]

@PointClass sphere() size(-4 -4 -4, 4 4 4) base(Targetname, Parentname) = env_viewpunch :
	"Causes a view punch on players." 
[
	spawnflags(flags) =
	[
		1: "Punch all players (ignore radius)" : 0
		2: "Punch players in the air" : 0
	]

	punchangle(angle) : "Punch angles" : "0 0 90" : "The punch angles to apply."
	radius(float) : "Effect Radius" : "500" : "The radius around this entity in which to affect players."

	// Inputs
	input ViewPunch(void) : "Performs the view punch."
]

@PointClass base(Targetname, Parentname) = env_rotorwash_emitter :
	"Creates rotorwash." 
[
	altitude(float) : "Altitude" : "1024" : "Altitude the rotorwash will show up."
]

@PointClass base(gibshooterbase) iconsprite("editor/gibshooter.vmat") = gibshooter : 
	"An entity that shoots out gibs. Style of body part depends on language type."
[
]

@PointClass base(gibshooterbase, RenderFields) iconsprite("editor/env_shooter.vmat") = env_shooter : 
	"An entity that shoots models, or sprites, out of its origin."
[
	shootmodel(studio) : "Model" : "" : "Thing to shoot out. Can be a .vmdl or a .vmat."
	shootsounds(choices) :"Material Sound" : -1 =
	[
		-1: "None"
		0: "Glass"
		1: "Wood"
		2: "Metal"
		3: "Flesh"
		4: "Concrete"  
	]
	simulation(choices) :"Simulate" : 0 =
	[
		0: "Point"
		1: "Physics"
		2: "Ragdoll"
	]

	skin(integer) : "Gib Skin" : 0 : "Some models have multiple versions of their textures, called skins. Set this to a number other than 0 to use that skin on all gibs produced by this shooter."

	spawnflags(flags) =
	[
		2 : "On fire" : 0
		4 : "strict remove after lifetime" : 0
	]

	nogibshadows(boolean) :"Disable Shadows on Gibs" : 0

	gibgravityscale(float) : "Gib gravity scale" : "1" : "ONLY WORKS FOR POINT GIBS. This field allows you to scale gravity so that gibs fall faster, slower, or not at all."
	
	massoverride(float) : "Mass override" : "0" : "EPISODIC ONLY. Specify an arbitrary mass for the gibs emitted by me."
]

@PointClass base(gibshooterbase, RenderFields) iconsprite("editor/env_shooter.vmat") = env_rotorshooter : 
	"An entity that creates gibs when it's within the influence of a helicopter's rotor wash."
[
	shootmodel(studio) : "Model" : "" : "Thing to shoot out.  Can be a .vmdl or a .vmat."
	shootsounds(choices) :"Material Sound" : -1 =
	[
		-1: "None"
		0: "Glass"
		1: "Wood"
		2: "Metal"
		3: "Flesh"
		4: "Concrete"  
	]
	simulation(choices) :"Simulate" : 0 =
	[
		0: "Point"
		1: "Physics"
		2: "Ragdoll"
	]

	skin(integer) : "Gib Skin" : 0 : "Some models have multiple versions of their textures, called skins. Set this to a number other than 0 to use that skin on all gibs produced by this shooter."

	spawnflags(flags) =
	[
		2 : "On fire" : 0
	]

	rotortime(float) : "Time Under Rotor" : "1" : "The average time it has to be under the rotor before it shoots a gib."
	rotortimevariance(float) : "Time variance" : "0.3" : "The random amount to vary the time it has to be under the rotor before it shoots a gib."
]

@PointClass base(Targetname,Parentname) tags( Sound ) sphere() iconsprite("editor/env_soundscape.vmat") = env_soundscape_proxy : 
	"An entity that acts like a soundscape but gets all of its sound parameters from another env_soundscape entity."
[
	MainSoundscapeName(target_destination) : "Soundscape Entity" : "" : "The soundscape to get all sound parameters from."

	radius(integer) : "Radius" : 128					// NEEDHELP: The datadesc doesn't include this entry. Probably not used.
]

@PointClass base(env_soundscape_proxy) tags( Sound ) sphere() iconsprite("editor/env_soundscape.vmat") = snd_soundscape_proxy : 
	"An entity that acts like a soundscape but gets all of its sound parameters from another env_soundscape entity."
[
]

@PointClass base(Targetname,Parentname,EnableDisable) tags( Sound ) sphere() iconsprite("editor/env_soundscape.vmat") line(255 255 255, targetname, position0) line(255 255 255, targetname, position1) line(255 255 255, targetname, position2) line(255 255 255, targetname, position3) line(255 255 255, targetname, position4) line(255 255 255, targetname, position5) line(255 255 255, targetname, position6) line(255 255 255, targetname, position7) = env_soundscape : 
	"An entity to control sound in an area. The active soundscape at any time is the last one that had line-of-sight to the player, and was within the radius."
[
	radius(integer) : "Radius" : 128 : "If set to -1, then the player can hear the soundscape as long as he can see it (regardless of distance to it)."
	soundscape(string) : "Soundscape" : "Nothing" : "The name of the soundscape to use. Corresponds to an entry in the soundscapes*.txt file in the scripts directory."
	enablesoundevent(boolean) : "Override soundscape with sound event" : 0
	soundevent(sound) : "Sound Event" : "" : "The name of the sound event to start from the soundscape entity."

	position0(target_destination) : "Sound Position 0" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position1(target_destination) : "Sound Position 1" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position2(target_destination) : "Sound Position 2" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position3(target_destination) : "Sound Position 3" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position4(target_destination) : "Sound Position 4" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position5(target_destination) : "Sound Position 5" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position6(target_destination) : "Sound Position 6" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."
	position7(target_destination) : "Sound Position 7" : "" : "A sound position that will be referenced inside the soundscape text file. Usually used to position a set of sounds within the world."

	// Inputs
	input ToggleEnabled(void) : "Toggle the soundscape enabled state."

	// Outputs
	output OnPlay(void) : "Fired when this soundscape becomes the active one."
]

@PointClass base(env_soundscape) tags( Sound ) sphere() iconsprite("editor/env_soundscape.vmat") line(255 255 255, targetname, position0) line(255 255 255, targetname, position1) line(255 255 255, targetname, position2) line(255 255 255, targetname, position3) line(255 255 255, targetname, position4) line(255 255 255, targetname, position5) line(255 255 255, targetname, position6) line(255 255 255, targetname, position7) = snd_soundscape : 
	"An entity to control sound in an area. The active soundscape at any time is the last one that had line-of-sight to the player, and was within the radius."
[
]

@PointClass base(env_soundscape) tags( Sound ) sphere() iconsprite("editor/env_soundscape.vmat") = env_soundscape_triggerable : 
	"An entity that works like env_soundscape except that it works in conjunction with trigger_soundscape to determine when a player hears it."
[
]

@PointClass base(env_soundscape_triggerable) tags( Sound ) sphere() iconsprite("editor/env_soundscape.vmat") = snd_soundscape_triggerable : 
	"An entity that works like env_soundscape except that it works in conjunction with trigger_soundscape to determine when a player hears it."
[
]

@PointClass base(Targetname, Parentname) tags( Particles ) iconsprite("editor/env_spark.vmat") = env_spark : 
	"An entity used to create sparks at its origin." 
[
	MaxDelay(string) : "Max Delay" : "0" : "The longest delay between sparks (in seconds)."
	SparkType(choices) : "Spark Type" : 1 : "What Type of Spark Effect" =
	[
		1 : "Electrical"
		2 : "Metal"
		3 : "base"
	]
	Magnitude(choices) : "Magnitude" : 1 : "The size of the sparks." =
	[
		1 : "Small"
		2 : "Medium"
		5 : "Large"
		8 : "Huge"
	]

	TrailLength(choices) : "Spark Trail Length" : 1 =
	[
		1 : "Short"
		2 : "Medium"
		3 : "Long"
	]

	spawnflags(flags) =
	[
		64: "Start ON" : 0
		128: "Glow" : 0
		256: "Silent" : 0
		512: "Directional" : 0
	]
	
	// Inputs
	input StartSpark(void) : "Start the spark effect."
	input StopSpark(void) : "Stop the spark effect."
	input ToggleSpark(void) : "Toggle the on/off state of the spark effect."
	input SparkOnce(void) : "Spark once."
]

@PointClass base(Targetname, Parentname, RenderFields) size(-2 -2 -2, 2 2 2) externalHelper( ToolObjects/env_sprite ) color(20 140 20) = env_sprite : 
	"An entity that controls the drawing of a sprite in the world." 
[
	framerate(string) : "Framerate" : "10.0" : "Rate at which the sprite should animate, if at all."
	model(sprite) : "Sprite Name" : "sprites/glow01.spr" : "Material of the sprite to be drawn."
	scale(string) : "Scale" : "" : "Scale multiplier of the sprite."
	spawnflags(flags) =
	[
		1: "Start on" : 0
		2: "Play Once" : 0
	]

	GlowProxySize(float) : "Size of Glow Proxy Geometry." : "2.0" : "Size of the glow to be rendered for visibility testing. Must be larger than the distance from the sprite center to empty space.  So if this glow is inside geometry (like a light bulb), set this value to be bigger than the bulb's radius. Any time a sphere of this radius would be visible (poking through any nearby geometry), the glow will be rendered."

	HDRColorScale(float) : "HDR color scale." : "0.7" : "float value to multiply sprite color by when running in HDR mode."
	
	// Inputs
	input ColorRedValue(float) : "Sets the red color channel's value (0 - 255)."
	input ColorGreenValue(float) : "Sets the green color channel's value (0 - 255)."
	input ColorBlueValue(float) : "Sets the blue color channel's value (0 - 255)."
	input SetScale(float) : "Set the sprite's scale (0 - 8.0)."
	input HideSprite(void) : "Hide the sprite. Won't be drawn until the 'ShowSprite' input is received."
	input ShowSprite(void) : "Show the sprite."
	input ToggleSprite(void) : "Toggle the sprite between hidden and shown."
]

@PointClass base(env_sprite) = env_sprite_oriented :
    "A env_sprite that allows orientation."
[
	framerate(string) : "Framerate" : "10.0" : "Rate at which the sprite should animate, if at all."
	model(sprite) : "Sprite Name" : "sprites/glow01.spr" : "Material of the sprite to be drawn."
	scale(string) : "Scale" : "" : "Scale multiplier of the sprite."
	spawnflags(flags) =
	[
		1: "Start on" : 0
		2: "Play Once" : 0
	]

	GlowProxySize(float) : "Size of Glow Proxy Geometry." : "2.0" : "Size of the glow to be rendered for visibility testing. Must be larger than the distance from the sprite center to empty space.  So if this glow is inside geometry (like a light bulb), set this value to be bigger than the bulb's radius. Any time a sphere of this radius would be visible (poking through any nearby geometry), the glow will be rendered."

	HDRColorScale(float) : "HDR color scale." : "1.0" : "float value to multiply sprite color by when running in HDR mode."
	
	// Inputs
	input ColorRedValue(float) : "Sets the red color channel's value (0 - 255)."
	input ColorGreenValue(float) : "Sets the green color channel's value (0 - 255)."
	input ColorBlueValue(float) : "Sets the blue color channel's value (0 - 255)."
	input SetScale(float) : "Set the sprite's scale (0 - 8.0)."
	input HideSprite(void) : "Hide the sprite. Won't be drawn until the 'ShowSprite' input is received."
	input ShowSprite(void) : "Show the sprite."
	input ToggleSprite(void) : "Toggle the sprite between hidden and shown."
]

@BaseClass base(Targetname) = BaseEnvWind 
[ 
	minwind(integer) { group="Wind" min="0" max="80" } : "Min normal speed" : 20 : "Minimum speed of the wind while idling."
	maxwind(integer) { group="Wind" min="0" max="200" } : "Max normal speed" : 50 : "Maximum speed of the wind while idling."

	mingust(integer) { group="Wind" min="0" max="200" } : "Min gust speed" : 100 : "Minimum speed of wind gusts."
	maxgust(integer) { group="Wind" min="0" max="400" } : "Max gust speed" : 200 : "Maximum speed of wind gusts."

	mingustdelay(integer) { group="Wind" } : "Min gust delay" : 10 : "Minimum time delay between random gusts."
	maxgustdelay(integer) { group="Wind" } : "Max gust delay" : 20 : "Maximum time delay between random gusts."
	gustduration(integer) { group="Wind" } : "Gust Duration" : 5 : "How long will the wind gust for."
	gustdirchange(integer) { group="Wind" } : "Max gust direction change (degrees)" : 20 : "Maximum amount that the wind's direction changes due to a gust."

	windradius(float) : "Radius" : -1 : "The radius this entity applies wind effects to.  -1 for global effect, other value to allow multiple or limited wind entities."

	output OnGustStart(void) : "Fired when a wind gust begins."
	output OnGustEnd(void) : "Fired when a wind gust ends."
]

@PointClass base(BaseEnvWind) iconsprite("editor/env_wind.vmat") sphere(windradius) = env_wind : 
	"An entity to control wind in the map."
[
]

@PointClass size(-1 -1 -1, 1 1 1) color(0 0 255) = sky_camera : 
	"An entity used to control the 3D Skybox. Its origin is used to determine the 3D Skybox's position relative to the map. Place this entity, in the 3D Skybox, at the point where the origin of the map should be."
[
	scale(integer) : "3D Skybox scale" : 16 : "Scale of the skybox."
	clip_3D_skybox_near_to_world_far(boolean) : "Clip 3D sky near plane to world far plane" : 0
	clip_3D_skybox_near_to_world_far_offset(string) : "3D sky near plane offset" : "0.0" : "Offset for the near clip plane for the 3D sky in world units.  This is only used if the above field is true.  Negative values to pull closer, etc."
	SkyboxSlot(string) : "SkyboxSlot" : "" : "Name of the skybox this camera belongs to."	
	fogenable(boolean) [ group = "Fog" ] : "Fog Enable" : 0
	fogblend(boolean) [ group = "Fog" ] : "Fog Blend" : 0
	use_angles(boolean) [ group = "Fog" ] : "Use Angles for Fog Dir" : 0
	fogcolor(color255) [ group = "Fog" ] : "Primary Fog Color" : "255 255 255"
	fogcolor2(color255) [ group = "Fog" ] : "Secondary Fog Color" : "255 255 255"
	fogdir(string) [ group = "Fog" ] : "Primary Fog Direction" : "1 0 0"
	fogstart(string) [ group = "Fog" ] : "Fog Start" : "500.0" : "Distance at which the skybox fog should start."
	fogend(string) [ group = "Fog" ] : "Fog End" : "2000.0" : "Distance at which the skybox fog should be fully opaque."
	fogmaxdensity(float) [ group = "Fog" ] : "Fog Max Density [0..1]" : "1"
	HDRColorScale(float) [ group = "Fog" ] : "HDR color scale." : "1.0" : "float value to multiply fog color by when running in HDR mode."
]

@BaseClass base(Targetname, ResponseContext) = BaseSpeaker
[
	delaymin(string) : "Min Delay Between Announcements" : "15"
	delaymax(string) : "Max Delay Between Announcements" : "135"
	spawnflags(flags) =
	[
		1: "Start Silent" : 0
		2: "Play Everywhere" : 0
	]
	rulescript(string) : "Context rule script" : "" : "Script file containing rules for playing appropriate sounds."
	concept(string) : "Concept name" : "" : "High level concept name used as primary search key."

	// Inputs
	input TurnOn(void) : "Turn on the random announcements."
	input TurnOff(void) : "Turn off the random announcements."
	input Toggle(void) : "Toggle the random announcements off and on."
]


//-------------------------------------------------------------------------
//
// Game Entities
//
//-------------------------------------------------------------------------
@PointClass base(Targetname) = game_weapon_manager : 
	"An entity used to limit the number of a particular weapon type in the world. Useful in places where NPCs are spawning rapidly, dying, and dropping weapons." 
[
	weaponname(string) : "Weapon Classname" : "" : "Classname of the weapon type to limit."
	maxpieces(integer) : "Max Allowed in Level"	: 0 : "The maximum amount of the specified weapon type allowed in the world."
	ammomod(float)	   : "Ammo modifier" : 1 : 	"Modifier for ammount of ammo dropped by a weapon."

	// Inputs
	input SetAmmoModifier(float): "Adjust the ammo modifier."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = game_player_equip : 
	"An entity that gives equipment to the player who activates it. To use, add new keys to this entity, where each key is the classname of a weapon/item, and the corresponding value is the number of those weapons/items to give to the player who uses this entity. If the 'Use Only' spawnflag isn't set, then players can just touch this entity to get the equipment."
[
	spawnflags(flags) =
	[
		1: "Use Only" : 0
		2: "Strip First" : 0
	]
	master(string) : "Team Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."	

	weapon0(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon1(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon2(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon3(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon4(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon5(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon6(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon7(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon8(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon9(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon10(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon11(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon12(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon13(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon14(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon15(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon16(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon17(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon18(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon19(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon20(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."
	weapon21(string)	 : "Weapon" : "" : "Classname of item to equip, eg 'weapon_ak47'."

	input TriggerForAllPlayers(void) : "This will force all connected players to take the weapon(s) specified."
	input TriggerForActivatedPlayer(string) : "This will force the player who activated to equip the specified weapon."
]

@PointClass base(Targetname) iconsprite("editor/game_text.vmat") = game_text : 
	"An entity that displays text on player's screens." 
[
	spawnflags(flags) =
	[
		1: "All Players" : 0
	]

	message(string) [report] : "Message Text" : "" : "Message to display onscreen."
	x(string) : "X (0 - 1.0 = left to right) (-1 centers)" : "-1" : "Horizontal position on the player's screens to draw the text. The value should be between 0 and 1, where 0 is the far left of the screen and 1 is the far right. -1 centers the text."
	y(string) : "Y (0 - 1.0 = top to bottom) (-1 centers)" : "-1" : "Vertical position on the player's screens to draw the text. The value should be between 0 and 1, where 0 is the top of the screen and 1 is the bottom. -1 centers the text."
	effect(Choices) : "Text Effect" : 0 =
	[
		0 : "Fade In/Out"
		1 : "Credits"
		2 : "Scan Out"
	]
	color(color255) : "Color1" : "100 100 100"
	color2(color255) : "Color2" : "240 110 0"
	fadein(string) : "Fade in Time (or character scan time)" : "1.5" : "The time it should take for the text to fully fade in."
	fadeout(string) : "Fade Out Time" : "0.5" : "The time it should take for the text to fade out, after the hold time has expired."
	holdtime(string) : "Hold Time" : "1.2" : "The time the text should stay onscreen, after fading in, before it begins to fade out."
	fxtime(string) : "Scan time (scan effect only)" : "0.25" : "If the 'Text Effect' is set to Scan Out, this is the time it should take to scan out all the letters in the text."
	channel(choices) : "Text Channel" : 1 : "You can have up to four individual game_text messages onscreen at once, stored in channels. Select which channel this text should be placed in, which will overwrite any active message already in that channel." =
	[
		1 : "Channel 1"
		2 : "Channel 2"
		3 : "Channel 3" 
		4 : "Channel 4"
	]
	master(string) : "Master" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."

	// Inputs
	input Display(void) : "Display the message text."
	input SetText(string) : "Set the text to display."
]

@PointClass base(Parentname) size(-2 -2 -2, 2 2 2) = point_enable_motion_fixup : 
	"An entity used to move a motion-disabled prop when it enables motion. Parent this entity to the prop, and when the prop has its motion enabled, it will immediately teleport to the origin of this entity."
[
]


@PointClass base(Targetname, Parentname) size(-8 -8 -8, 8 8 8) = point_message : 
	"An entity that displays a text message in the world, at its origin."
[
	spawnflags(flags) =
	[
		1: "Start Disabled" : 0
	]

	message(string) : "Entity Message"
	radius(integer) : "Show message radius" : 128 : "Distance the player must be within to see this message."
	developeronly(boolean) : "Developer Only?" : 0 : "If set, this message will only be visible when developer mode is on."

	// Inputs
	input Enable(void) : "Start displaying the message text, if the player is within the message radius."
	input Disable(void) : "Stop displaying the message text."
	input SetMessage(string) : "Sets the message text to display."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = point_clientcommand : 
	"An entity that issues commands to the client console, as if it was typed in by the player (if activator is a player, or the local player in single player)."
[
	// Inputs
	input Command(string) : "Command to execute."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = point_servercommand : 
	"An entity that issues commands to the server console."
[
	// Inputs
	input Command(string) : "Command to execute."
]

@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = point_broadcastclientcommand : 
	"An entity that issues commands to each valid client's console, as if it was typed in by that player locally."
[
	// Inputs
	input Command(string) : "Command to execute."
]

@PointClass base(Targetname) = point_entity_finder :
	"An entity that will find an entity and pass it along as the !Caller with the OutEntity output.  Requires using !Caller as the parameter on the input."
[
	filtername(filterclass) : "Filter Name" : : "Filter to use to narrow set of findable entities. See filter_activator_name for more explanation."
	referencename(target_destination) : "Reference Entity" : "" : "Name of the entity to use when evaluating criteria.  For example, when using 'Nearest', this is the entity that distance will be measured from.  If left blank will use the point_entity_finder."

	Method(choices) : "Search Method" : "0" =
	[
		0 : "Nearest"
		1 : "Farthest"
		2 : "Random"
	]
	
	// Inputs
	input FindEntity(void) : "Find an entity that meets the specified criteria.  Will fire OutEntity if found and pass the entity as !Caller."

	// Outputs
	output OnFoundEntity(void) : "Fired when FindEntity is input and an entity was found. Passes the found entity as !Caller."
]

@SolidClass base(Targetname, Parentname) = game_zone_player : 
	"An entity used to count the number of players within a zone."
[
	// Inputs
	input CountPlayersInZone(void) : "Count the number of players in the zone, and fire the corresponding outputs."

	// Outputs
	output OnPlayerInZone(void) : "Fired whenever a count finds a player inside the zone, with the player as the activator."
	output OnPlayerOutZone(void) : "Fired whenever a count finds a player outside the zone, with the player as the activator."
	output PlayersInCount(integer) : "Fired after a count, and contains the number of players found inside the zone."
	output PlayersOutCount(integer) : "Fired after a count, and contains the number of players found outside the zone."
]

//-------------------------------------------------------------------------
//
// Info Entities
//
//-------------------------------------------------------------------------

@PointClass base(Targetname, EnableDisable, PlayerClass) tags( Info, PlayerPosition ) editormodel("models/editor/playerstart.vmdl", fixedbounds) = info_player_start :
	"This entity indicates the position and facing direction at which the player will spawn. Any number of "+
	"info_player_start entities may be placed in a map for when working in cordoned-off portions of the map. "+
	"When multiple info_player_start entities are present in a map, set the 'Master' spawnflag on one of them "+
	"to indicate which one should be used when running the entire map."
[
	StartDisabled(boolean) : "Start Disabled" : 0
	IsMaster(boolean) : "Master" : 0 : "Master has priority if multiple info_player_starts exist"
	PawnSubclass( vdata_choice:scripts/player.vdata ) : "Pawn Subclass" : "" : "Subclass of the player pawn to spawn."

	input Toggle(void) : "Toggle the enable/disable state of this player spawn position."
]


@PointClass tags( Info ) size(-4 -4 -4, 4 4 4) color(0 180 0) = info_intermission : 
	"An entity that defines an intermission spot where dead players will float until they respawn."
[
	target(target_destination) : "Entity to look at" : : "Name of entity that dead players will face while in intermission at this spot."
]

@PointClass tags( Info ) base(Targetname) iconsprite("editor/info_landmark") = info_landmark : 
	"An entity that acts as a local coordinate frame for transitions to another level. There should be a corresponding info_landmark entity in the next map. "+
	"Entities will transition to the next level at the same relative offset from the info_landmark entity.<br><br>"+
	"Note that only entities in same the PVS as the info_landmark are considered for transitioning, so it should generally be placed inside the transition space."
[
	input SetPosition(vector) : "Set position of landmark."
]

@PointClass tags( Info ) base(Targetname) color(0 255 0) iconsprite("editor/info_target.vmat") = info_spawngroup_load_unload : "Logical entity that starts async loading or unloading a level."
[
	targetname(target_source) : "Name"
	mapname(string) : "Level to stream in/out"
	entityfiltername(string) : "Name of entity filter to apply"	
	landmark(string) : "The landmark (same landmark name should be in both maps) used to determine the offset of the second map to the first"
	timeoutInterval(float) : "Timeout Interval" : "0" : "The amount of seconds after which, if any client hasn't finished streaming the necessary assets, that client is disconnected and the spawngroup spawns anyways. 0 means use some reasonable default set in the code."
	autoactivate(boolean) : "Automatically activate and show streamed level" : 1 : "Automatically activates the spawn group once loaded."
	
	// Outputs
	output OnSpawnGroupLoadStarted(void) : "Fired when the level starts streaming in."
	output OnSpawnGroupLoadFinished(void) : "Fired when the level finishes streaming in."
	output OnSpawnGroupUnloadStarted(void) : "Fired when the level starts streaming out."
	output OnSpawnGroupUnloadFinished(void) : "Fired when the level finishes streaming out."

	input StartSpawnGroupLoad(void) : "Start loading the level."
	input ActivateSpawnGroup(void) : "Activate the loaded spawn group."
	input StartSpawnGroupUnload(void) : "Start unloading the level."
]

@PointClass tags( Info ) base(Targetname) size(-8 -8 -8, 8 8 8) = info_null : 
	"An entity that's immediately removed on spawning. Useful as a spotlight target."
[
]

@PointClass tags( Info ) base(Targetname, Parentname) editormodel("models/editor/info_target", nobounds ) = info_target : 
	"An entity that does nothing. Very useful as a positioning entity for other entities to refer to (i.e. the endpoint of an env_beam)"
[
	spawnflags( Flags ) =
	[
		1 : "Transmit to client (respect PVS)" : 0
		2 : "Always transmit to client (ignore PVS)" : 0
	]
]

@PointClass tags( Info ) base(Targetname, Parentname) editormodel("models/editor/info_target", nobounds ) = info_target_server_only : 
	"An entity that does nothing. Not networked."
[
]


@PointClass base(Targetname, Parentname) tags( Particles ) editormodel("models/editor/cone_helper.vmdl") = info_particle_target : 
	"An entity that is a target for particle system control points"
[
]


@PointClass base(Targetname, Parentname, CanBeClientOnly) tags( Particles ) editormodel("models/editor/cone_helper_xyz.vmdl", postocclusionquery) particle() line(255 255 255, targetname, cpoint1) line(255 255 255, targetname, cpoint2) line(255 255 255, targetname, cpoint3) line(255 255 255, targetname, cpoint4) line(255 255 255, targetname, cpoint5) line(255 255 255, targetname, cpoint6) line(255 255 255, targetname, cpoint7) line(255 255 255, targetname, cpoint8) line(255 255 255, targetname, cpoint9) line(255 255 255, targetname, cpoint10) line(255 255 255, targetname, cpoint11) line(255 255 255, targetname, cpoint12) line(255 255 255, targetname, cpoint13) line(255 255 255, targetname, cpoint14) line(255 255 255, targetname, cpoint15) line(255 255 255, targetname, cpoint16) line(255 255 255, targetname, cpoint17) line(255 255 255, targetname, cpoint18) line(255 255 255, targetname, cpoint19) line(255 255 255, targetname, cpoint20) line(255 255 255, targetname, cpoint21) line(255 255 255, targetname, cpoint22) line(255 255 255, targetname, cpoint23) line(255 255 255, targetname, cpoint24) line(255 255 255, targetname, cpoint25) line(255 255 255, targetname, cpoint26) line(255 255 255, targetname, cpoint27) line(255 255 255, targetname, cpoint28) line(255 255 255, targetname, cpoint29) line(255 255 255, targetname, cpoint30) line(255 255 255, targetname, cpoint31) line(255 255 255, targetname, cpoint32) line(255 255 255, targetname, cpoint33) line(255 255 255, targetname, cpoint34) line(255 255 255, targetname, cpoint35) line(255 255 255, targetname, cpoint36) line(255 255 255, targetname, cpoint37) line(255 255 255, targetname, cpoint38) line(255 255 255, targetname, cpoint39) line(255 255 255, targetname, cpoint40) line(255 255 255, targetname, cpoint41) line(255 255 255, targetname, cpoint42) line(255 255 255, targetname, cpoint43) line(255 255 255, targetname, cpoint44) line(255 255 255, targetname, cpoint45) line(255 255 255, targetname, cpoint46) line(255 255 255, targetname, cpoint47) line(255 255 255, targetname, cpoint48) line(255 255 255, targetname, cpoint49) line(255 255 255, targetname, cpoint50) line(255 255 255, targetname, cpoint51) line(255 255 255, targetname, cpoint52) line(255 255 255, targetname, cpoint53) line(255 255 255, targetname, cpoint54) line(255 255 255, targetname, cpoint55) line(255 255 255, targetname, cpoint56) line(255 255 255, targetname, cpoint57) line(255 255 255, targetname, cpoint58) line(255 255 255, targetname, cpoint59) line(255 255 255, targetname, cpoint60) line(255 255 255, targetname, cpoint61) line(255 255 255, targetname, cpoint62) line(255 255 255, targetname, cpoint63) = info_particle_system : 
	"An entity that spawns a particle system built using the particle editor."
[
	effect_name(particlesystem) [report] : "Particle System Name"
	start_active(boolean) : "Start Active?" : 1
	no_save(boolean) : "Don't Save" : 0

	snapshot_file(resource:vsnap) { enabled={ variable="snapshot_mesh" value="0" } } : "Particle Snapshot File" : "" : "Name of .VSNAP (Particle Snapshot File) to be loaded and used by this particle system (e.g. 'smoke_snapshot1')"
	snapshot_mesh(node_id) : "Particle Snapshot Node" : "" : "Id of a node in the map to be used to generate a particle snapshot, if specified Particle Snapshot File is ignored."

	data_cp(integer) : "Data Control Point (-1 unused)" : -1 : "What controlpoint to set data on.  -1 means this is not used."
	data_cp_value(vector) : "Data Control Point Value" : "0 0 0" : "Data Control Point Value to set."

	tint_cp(integer) : "Tint Control Point (-1 unused)" : -1 : "What controlpoint to set color on.  -1 means this is not used."
	tint_cp_color(color255) : "Tint CP Color" : "255 255 255" : "Color for the specified Control Point"

	cpoint0(target_destination) [ group="Control Points" ] : "Control Point 0" : : "If set, control point 0 of the effect will be at this entity's location. (Otherwise it is at the info_particle_system origin)"
	cpoint1(target_destination) [ group="Control Points" ]  : "Control Point 1" : : "If set, control point 1 of the effect will be at this entity's location."
	cpoint2(target_destination) [ group="Control Points" ]  : "Control Point 2" : : "If set, control point 2 of the effect will be at this entity's location. If control point 1 is not set, this will be ignored."
	cpoint3(target_destination) [ group="Control Points" ]  : "Control Point 3" : : "If set, control point 3 of the effect will be at this entity's location. If control point 2 is not set, this will be ignored."
	cpoint4(target_destination) [ group="Control Points" ]  : "Control Point 4" : : "If set, control point 4 of the effect will be at this entity's location. If control point 3 is not set, this will be ignored."
	cpoint5(target_destination) [ group="Control Points" ]  : "Control Point 5" : : "If set, control point 5 of the effect will be at this entity's location. If control point 4 is not set, this will be ignored."
	cpoint6(target_destination) [ group="Control Points" ]  : "Control Point 6" : : "If set, control point 6 of the effect will be at this entity's location. If control point 5 is not set, this will be ignored."
	cpoint7(target_destination) [ group="Control Points" ]  : "Control Point 7" : : "If set, control point 7 of the effect will be at this entity's location. If control point 6 is not set, this will be ignored."
	cpoint8(target_destination) [ group="Control Points" ]  : "Control Point 8" : : "If set, control point 8 of the effect will be at this entity's location. If control point 7 is not set, this will be ignored."
	cpoint9(target_destination) [ group="Control Points" ]  : "Control Point 9" : : "If set, control point 9 of the effect will be at this entity's location. If control point 8 is not set, this will be ignored."
	cpoint10(target_destination) [ group="Control Points" ]  : "Control Point 10" : : "If set, control point 10 of the effect will be at this entity's location. If control point 9 is not set, this will be ignored."
	cpoint11(target_destination) [ group="Control Points" ]  : "Control Point 11" : : "If set, control point 11 of the effect will be at this entity's location. If control point 10 is not set, this will be ignored."
	cpoint12(target_destination) [ group="Control Points" ]  : "Control Point 12" : : "If set, control point 12 of the effect will be at this entity's location. If control point 11 is not set, this will be ignored."
	cpoint13(target_destination) [ group="Control Points" ]  : "Control Point 13" : : "If set, control point 13 of the effect will be at this entity's location. If control point 12 is not set, this will be ignored."
	cpoint14(target_destination) [ group="Control Points" ]  : "Control Point 14" : : "If set, control point 14 of the effect will be at this entity's location. If control point 13 is not set, this will be ignored."
	cpoint15(target_destination) [ group="Control Points" ]  : "Control Point 15" : : "If set, control point 15 of the effect will be at this entity's location. If control point 14 is not set, this will be ignored."
	cpoint16(target_destination) [ group="Control Points" ]  : "Control Point 16" : : "If set, control point 16 of the effect will be at this entity's location. If control point 15 is not set, this will be ignored."
	cpoint17(target_destination) [ group="Control Points" ]  : "Control Point 17" : : "If set, control point 17 of the effect will be at this entity's location. If control point 16 is not set, this will be ignored."
	cpoint18(target_destination) [ group="Control Points" ]  : "Control Point 18" : : "If set, control point 18 of the effect will be at this entity's location. If control point 17 is not set, this will be ignored."
	cpoint19(target_destination) [ group="Control Points" ]  : "Control Point 19" : : "If set, control point 19 of the effect will be at this entity's location. If control point 18 is not set, this will be ignored."
	cpoint20(target_destination) [ group="Control Points" ]  : "Control Point 20" : : "If set, control point 20 of the effect will be at this entity's location. If control point 19 is not set, this will be ignored."
	cpoint21(target_destination) [ group="Control Points" ]  : "Control Point 21" : : "If set, control point 21 of the effect will be at this entity's location. If control point 10 is not set, this will be ignored."
	cpoint22(target_destination) [ group="Control Points" ]  : "Control Point 22" : : "If set, control point 22 of the effect will be at this entity's location. If control point 21 is not set, this will be ignored."
	cpoint23(target_destination) [ group="Control Points" ]  : "Control Point 23" : : "If set, control point 23 of the effect will be at this entity's location. If control point 22 is not set, this will be ignored."
	cpoint24(target_destination) [ group="Control Points" ]  : "Control Point 24" : : "If set, control point 24 of the effect will be at this entity's location. If control point 23 is not set, this will be ignored."
	cpoint25(target_destination) [ group="Control Points" ]  : "Control Point 25" : : "If set, control point 25 of the effect will be at this entity's location. If control point 24 is not set, this will be ignored."
	cpoint26(target_destination) [ group="Control Points" ]  : "Control Point 26" : : "If set, control point 26 of the effect will be at this entity's location. If control point 25 is not set, this will be ignored."
	cpoint27(target_destination) [ group="Control Points" ]  : "Control Point 27" : : "If set, control point 27 of the effect will be at this entity's location. If control point 26 is not set, this will be ignored."
	cpoint28(target_destination) [ group="Control Points" ]  : "Control Point 28" : : "If set, control point 28 of the effect will be at this entity's location. If control point 27 is not set, this will be ignored."
	cpoint29(target_destination) [ group="Control Points" ]  : "Control Point 29" : : "If set, control point 29 of the effect will be at this entity's location. If control point 28 is not set, this will be ignored."
	cpoint30(target_destination) [ group="Control Points" ]  : "Control Point 30" : : "If set, control point 30 of the effect will be at this entity's location. If control point 29 is not set, this will be ignored."
	cpoint31(target_destination) [ group="Control Points" ]  : "Control Point 31" : : "If set, control point 31 of the effect will be at this entity's location. If control point 30 is not set, this will be ignored."
	cpoint32(target_destination) [ group="Control Points" ]  : "Control Point 32" : : "If set, control point 32 of the effect will be at this entity's location. If control point 31 is not set, this will be ignored."
	cpoint33(target_destination) [ group="Control Points" ]  : "Control Point 33" : : "If set, control point 33 of the effect will be at this entity's location. If control point 32 is not set, this will be ignored."
	cpoint34(target_destination) [ group="Control Points" ]  : "Control Point 34" : : "If set, control point 34 of the effect will be at this entity's location. If control point 33 is not set, this will be ignored."
	cpoint35(target_destination) [ group="Control Points" ]  : "Control Point 35" : : "If set, control point 35 of the effect will be at this entity's location. If control point 34 is not set, this will be ignored."
	cpoint36(target_destination) [ group="Control Points" ]  : "Control Point 36" : : "If set, control point 36 of the effect will be at this entity's location. If control point 35 is not set, this will be ignored."
	cpoint37(target_destination) [ group="Control Points" ]  : "Control Point 37" : : "If set, control point 37 of the effect will be at this entity's location. If control point 36 is not set, this will be ignored."
	cpoint38(target_destination) [ group="Control Points" ]  : "Control Point 38" : : "If set, control point 38 of the effect will be at this entity's location. If control point 37 is not set, this will be ignored."
	cpoint39(target_destination) [ group="Control Points" ]  : "Control Point 39" : : "If set, control point 39 of the effect will be at this entity's location. If control point 38 is not set, this will be ignored."
	cpoint40(target_destination) [ group="Control Points" ]  : "Control Point 40" : : "If set, control point 40 of the effect will be at this entity's location. If control point 39 is not set, this will be ignored."
	cpoint41(target_destination) [ group="Control Points" ]  : "Control Point 41" : : "If set, control point 41 of the effect will be at this entity's location. If control point 40 is not set, this will be ignored."
	cpoint42(target_destination) [ group="Control Points" ]  : "Control Point 42" : : "If set, control point 42 of the effect will be at this entity's location. If control point 41 is not set, this will be ignored."
	cpoint43(target_destination) [ group="Control Points" ]  : "Control Point 43" : : "If set, control point 43 of the effect will be at this entity's location. If control point 42 is not set, this will be ignored."
	cpoint44(target_destination) [ group="Control Points" ]  : "Control Point 44" : : "If set, control point 44 of the effect will be at this entity's location. If control point 43 is not set, this will be ignored."
	cpoint45(target_destination) [ group="Control Points" ]  : "Control Point 45" : : "If set, control point 45 of the effect will be at this entity's location. If control point 44 is not set, this will be ignored."
	cpoint46(target_destination) [ group="Control Points" ]  : "Control Point 46" : : "If set, control point 46 of the effect will be at this entity's location. If control point 45 is not set, this will be ignored."
	cpoint47(target_destination) [ group="Control Points" ]  : "Control Point 47" : : "If set, control point 47 of the effect will be at this entity's location. If control point 46 is not set, this will be ignored."
	cpoint48(target_destination) [ group="Control Points" ]  : "Control Point 48" : : "If set, control point 48 of the effect will be at this entity's location. If control point 47 is not set, this will be ignored."
	cpoint49(target_destination) [ group="Control Points" ]  : "Control Point 49" : : "If set, control point 49 of the effect will be at this entity's location. If control point 48 is not set, this will be ignored."
	cpoint50(target_destination) [ group="Control Points" ]  : "Control Point 50" : : "If set, control point 50 of the effect will be at this entity's location. If control point 49 is not set, this will be ignored."
	cpoint51(target_destination) [ group="Control Points" ]  : "Control Point 51" : : "If set, control point 51 of the effect will be at this entity's location. If control point 50 is not set, this will be ignored."
	cpoint52(target_destination) [ group="Control Points" ]  : "Control Point 52" : : "If set, control point 52 of the effect will be at this entity's location. If control point 51 is not set, this will be ignored."
	cpoint53(target_destination) [ group="Control Points" ]  : "Control Point 53" : : "If set, control point 53 of the effect will be at this entity's location. If control point 52 is not set, this will be ignored."
	cpoint54(target_destination) [ group="Control Points" ]  : "Control Point 54" : : "If set, control point 54 of the effect will be at this entity's location. If control point 53 is not set, this will be ignored."
	cpoint55(target_destination) [ group="Control Points" ]  : "Control Point 55" : : "If set, control point 55 of the effect will be at this entity's location. If control point 54 is not set, this will be ignored."
	cpoint56(target_destination) [ group="Control Points" ]  : "Control Point 56" : : "If set, control point 56 of the effect will be at this entity's location. If control point 55 is not set, this will be ignored."
	cpoint57(target_destination) [ group="Control Points" ]  : "Control Point 57" : : "If set, control point 57 of the effect will be at this entity's location. If control point 56 is not set, this will be ignored."
	cpoint58(target_destination) [ group="Control Points" ]  : "Control Point 58" : : "If set, control point 58 of the effect will be at this entity's location. If control point 57 is not set, this will be ignored."
	cpoint59(target_destination) [ group="Control Points" ]  : "Control Point 59" : : "If set, control point 59 of the effect will be at this entity's location. If control point 58 is not set, this will be ignored."
	cpoint60(target_destination) [ group="Control Points" ]  : "Control Point 60" : : "If set, control point 60 of the effect will be at this entity's location. If control point 59 is not set, this will be ignored."
	cpoint61(target_destination) [ group="Control Points" ]  : "Control Point 61" : : "If set, control point 61 of the effect will be at this entity's location. If control point 60 is not set, this will be ignored."
	cpoint62(target_destination) [ group="Control Points" ]  : "Control Point 62" : : "If set, control point 62 of the effect will be at this entity's location. If control point 61 is not set, this will be ignored."
	cpoint63(target_destination) [ group="Control Points" ]  : "Control Point 63" : : "If set, control point 63 of the effect will be at this entity's location. If control point 62 is not set, this will be ignored."
	
	cpoint1_parent(integer) [ group="Control Points Parents" ] : "Control Point 1's Parent" : 0 : "If set and nonzero, control point 1 of the effect will use this point for its parent."
	cpoint2_parent(integer) [ group="Control Points Parents" ] : "Control Point 2's Parent" : 0 : "If set and nonzero, control point 2 of the effect will use this point for its parent."
	cpoint3_parent(integer) [ group="Control Points Parents" ] : "Control Point 3's Parent" : 0 : "If set and nonzero, control point 3 of the effect will use this point for its parent."
	cpoint4_parent(integer) [ group="Control Points Parents" ] : "Control Point 4's Parent" : 0 : "If set and nonzero, control point 4 of the effect will use this point for its parent."
	cpoint5_parent(integer) [ group="Control Points Parents" ] : "Control Point 5's Parent" : 0 : "If set and nonzero, control point 5 of the effect will use this point for its parent."
	cpoint6_parent(integer) [ group="Control Points Parents" ] : "Control Point 6's Parent" : 0 : "If set and nonzero, control point 6 of the effect will use this point for its parent."
	cpoint7_parent(integer) [ group="Control Points Parents" ] : "Control Point 7's Parent" : 0 : "If set and nonzero, control point 7 of the effect will use this point for its parent."

	// Inputs
	input Start(void) : "Tell the particle system to start emitting."
	input Stop(void) : "Tell the particle system to stop emitting."
	input Freeze(float) : "Tell the particle system to freeze, with optional transition time."
	input Thaw(float) : "Tell the frozen particle system to unfreeze, with optional transition time."
	input StopPlayEndCap(void) : "Tell the particle system to stop emitting and play its End Cap Effect."
	input DestroyImmediately(void) : "Destroy the particle system and remove all particles immediately."
	input SetControlPoint(string) : "Set a Control Point via format - CP: X Y Z"
	input SetDataControlPointX(float) : "Set X Component of Data Control Point"
	input SetDataControlPointY(float) : "Set Y Component of Data Control Point"
	input SetDataControlPointZ(float) : "Set Z Component of Data Control Point"
]


@PointClass base(Targetname, EnableDisable, Parentname) tags( Physics ) iconsprite("editor/info_target.vmat") sphere(radius) = phys_ragdollmagnet : 
	"An entity that acts like a magnet for ragdolls. Useful for crafting exaggerated ragdoll behavior (i.e. guys falling over rails on death). If the "+
	"Bar Magnet spawnflag is set, the magnet works like it was a cylindrical magnet i.e. it attracts ragdolls to the nearest point on a line."
[
	axis(vecline) : "Bar Magnet Axis"
	radius(float) : "Effective Radius" : "512" : "Radius in which ragdolls are affected around this entity's origin."
	force(float) : "Force" : "5000" : "Magnetic force to apply to ragdolls within the radius. Expressed as kilograms per inch per second. So a force of 1000 will add 10 inches/second to a 100kg man. It will add 100 inches per second to a 10kg headcrab."

	target(string) : "Entity to affect" : "" : "If specified, the phys_ragdollmagnet will only affect the target entity."

	spawnflags( Flags ) =
	[
		2 : "Bar Magnet (use axis helper)" : 0
	]
]

@PointClass base(Targetname) tags( Lighting ) iconsprite("editor/info_lighting.vmat")  = info_lighting : 
	"An entity that can be used to change the lighting origin of a prop_static. Set the prop_static's Lighting Origin to point at this entity to "+
	"make the prop_static light as if it was at the info_lighting's origin. Good for prop_static entities that are embedded in world geometry (like rocks/windows/etc)."
[
]

// This is obsolete, info_target is all you need now.
@PointClass base(Targetname, Parentname, PlayerClass) editormodel("models/editor/playerstart.vmdl", fixedbounds) = info_teleport_destination : 
	"An entity that does nothing itself, but can be used to specify the destination for a trigger_teleport entity. An info_target can be used instead."
[
]


//-------------------------------------------------------------------------
//
// Combat Character Hull Flags
//
//-------------------------------------------------------------------------
@BaseClass tags( AI ) = HullFlags
[
	aihull_human(boolean) : "Force human AI Hull" : 0
	aihull_small_centered(boolean) : "Force small_centered AI Hull" : 0
	aihull_wide_human(boolean) : "Force wide_human AI Hull" : 0
	aihull_tiny(boolean) : "Force tiny AI Hull" : 0
	aihull_medium(boolean) : "Force medium AI Hull" : 0
	aihull_tiny_centered(boolean) : "Force tiny_centered AI Hull" : 0
	aihull_large(boolean) : "Force large AI Hull" : 0
	aihull_large_centered(boolean) : "Force large_centered AI Hull" : 0
	aihull_medium_tall(boolean) : "Force medium_tall AI Hull" : 0
]


//-------------------------------------------------------------------------
//
// Lights
//
//-------------------------------------------------------------------------


@PointClass base(Targetname, Parentname) iconsprite("editor/light.vmat") sphere(distance) lightcone() size(-4 -4 -4, 4 4 4) = light_dynamic : 
	"An invisible lightsource that changes in some way over time." 
[
	target(target_destination) : "Entity to point at" : : "The name of an entity in the map that the dynamic light will point at."
	_light(color255) : "Light color" : "255 255 255 200"
	brightness(integer) : "Light brightness" : 0
	_inner_cone(integer) : "Inner (bright) angle" : 30
	_cone(integer) : "Outer (fading) angle" : 45
	distance(float) : "Maximum distance" : 120 : "This is the distance that light is allowed to cast, in inches."
	spotlight_radius(float) : "Spotlight end radius" : 80 : "This is the radius of the light, in inches, at the object that it is hitting."
	style(Choices) : "Appearance" : 0 =
	[
		0 : "Normal"
		10: "Fluorescent flicker"
		2 : "Slow, strong pulse"
		11: "Slow pulse, noblack"
		5 : "Gentle pulse"
		1 : "Flicker A"
		6 : "Flicker B"
		3 : "Candle A"
		7 : "Candle B"
		8 : "Candle C"
		4 : "Fast strobe"
		9 : "Slow strobe"
	]
	spawnflags(Flags) = 
	[ 
		1 : "Do not light world (better perf)" : 0 
		2 : "Do not light models" : 0
		4 : "Add Displacement Alpha" : 0
		8 : "Subtract Displacement Alpha" : 0
	]

	// Inputs
	input Color(color255) : "Set the light's render color (R G B)."
	input brightness(integer) : "Set the light brightness."
	input distance(float) : "Set the maximum light distance."
	input _inner_cone(integer) : "Set the inner (bright) angle."
	input _cone(integer) : "Set the outer (fading) angle."
	input spotlight_radius(float) : "Set the radius of the spotlight at the end point."
	input style(integer) : "Change the lightstyle (see Appearance field for possible values)."

	input TurnOn(void) : "Turn the light off."
	input TurnOff(void) : "Turn the light on."
	input Toggle(void) : "Toggle the light on/off."
]


//-------------------------------------------------------------------------
// Color correction control
//-------------------------------------------------------------------------
@PointClass base(Targetname, EnableDisable) sphere(minfalloff) sphere(maxfalloff) iconsprite("editor/color_correction.vmat") = color_correction : 
	"An entity to control the color correction in the map."
[
	minfalloff(float) : "Lookup Falloff Start Distance" : "0.0"   : "This is the distance to the start of the falloff region (-1 = everywhere)"
	maxfalloff(float) : "Lookup Falloff End Distance"   : "200.0" : "This is the distance to the end of the falloff region (-1 = everywhere)"
	maxweight(float)  : "Maximum Weight"				: "1.0"   : "This is the maximum weight for this lookup"
	filename(string)  : "Lookup Table Filename"			: ""	  : "This is the lookup table filename"
	fadeInDuration(float)   : "Lookup Fade In Duration"		: "0.0"	  : "Duration of fade in on when enabled."
	fadeOutDuration(float)   : "Lookup Fade out Duration"		: "0.0"	  : "Dration of fade out on when disabled."
	exclusive(boolean) : "Exlusive" : 0 : "An exclusive color_correction entity disables and fades out all other color corrections when it is enabled. There should only be one active exclusive color_correction ent at any time."

	// Inputs
	input SetFadeInDuration(float) : "Sets the 'fadeInDuration' variable, used to fade cc lookup usage when entity is enabled."
	input SetFadeOutDuration(float) : "Sets the 'fadeOutDuration' variable, used to fade cc lookup usage when entity is disabled."

	spawnflags(flags) =
	[
		1 : "Master (Default color correction when used with L4D fog_volume)" : 0
		2 : "Simulate client-side (Must be set when used with L4D fog_volume)" : 1
	]
]


//-------------------------------------------------------------------------
// Color correction volume control
//-------------------------------------------------------------------------
@SolidClass base(Targetname, EnableDisable ) = color_correction_volume : 
	"An entity to control the color correction in the map."
[
	fadeDuration(float) : "Lookup Fade Duration"  : "10.0" : "This is the duration for the lookup to fade in/out on extry/exit"
	maxweight(float)    : "Maximum Weight"		  : "1.0"  : "This is the maximum weight for this lookup"
	filename(string)    : "Lookup Table Filename" : ""     : "This is the lookup table filename"
]


//-------------------------------------------------------------------------
//
// Movement and Keyframing Entities
//
//-------------------------------------------------------------------------
@BaseClass = KeyFrame
[
	NextKey(target_destination) : "Next KeyFrame" : : "Name of the next keyframe along this keyframe path."

//	TimeModifier(choices) : "Time Modifier" : 0 =
//	[
//		0 : "Linear"
//		1 : "Accel"
//		2 : "Deaccel"
//		2 : "Accel/Deaccel (sine)"
//	]
	
	MoveSpeed(integer) : "Speed (units per second)" : 64					// NEEDHELP
//	NextTime(string) : "Time to get to next keyframe"
]

@BaseClass = Mover
[
	PositionInterpolator(choices) : "Position Interpolator" : 0 =
	[
		0 : "Linear"
		1 : "Catmull-Rom Spline"
	]
]

@SolidClass base(Targetname, Parentname, RenderFields) drawangles_local{ angles_key = "movedir" } = func_movelinear :
	"A brush entity that moves linearly along a given distance, in a given direction."
[
	movedir(angle) : "Move Direction (Pitch Yaw Roll)" : "0 0 0" : "The direction the brushes will move, when told to."
	spawnflags(flags) =
	[
		8 : "Not Solid" : 0
	]

	startposition(float) : "Start Position" : 0 : "Position of brush when spawned. The range is a value between 0.0 and 1.0, where 0 is the starting position and 1 is the starting position + (move direction * move distance)."	
	authoredposition(choices) : "Authored position" : 0 : "The entity may be authored in one of three positions for convenience." =
	[
		0 : "Start position (position = 'Start Position' key)"
		1 : "Open position (position = 1)"
		2 : "Closed position (position = 0)"
	]
	NoInterpolate(boolean) [ group="Misc" ] : "Disable Client-Side Interpolation" : 0
	MoveWithoutPushingBlockers(boolean) [ group="Misc" ] : "Move Without Pushing Blockers" : 0 : "Just moves the entity and anything attached to it, without going the expensive process of finding and pushing potentially blocking brush entities and NPCs. Will still push dynamic physics entities."

	speed(integer) : "Speed" : 100 : "The speed that the brush moves, in inches per second."
	movedistance(float) : "Move Distance" : 100 : "The distance from the starting point that the brush should move, in inches."
	blockdamage(float) : "Block Damage" : 0 : "The amount of damage to do to any entity that blocks the brushes, per frame."
	startsound(sound) : "Sound played when the brush starts moving."
	stopsound(sound) : "Sound played when the brush stops moving."
	CreateNavObstacle(boolean) : "Create Nav Obstacle" : "0" : "Create a navigation obstacle to assist NPC pathfinding"
	CreateMovableNavMesh(boolean) : "Create Movable Nav Mesh" : "0" : "Create a navigation mesh that moves with the brush."
	AllowMovableNavMeshDockingOnEntireEntity(boolean) : "Movable Nav Mesh, Allow Docking on Full Entity" : "0" : "If this entity creates a movable nav mesh, then allow docking test across the entire entity."
	// Inputs
	input Open(void) : "Move the brush to the end position (starting position + (move direction * move distance))."
	input Close(void) : "Move the brush to the starting position."
	input SetPosition(string) : "Move the brush to a specific position between 0.0 and 1.0, where 0 is the starting position and 1 is the starting position + (move direction * move distance)."
	input ResetPosition(float) : "Set a new start position for our current location."
	input SetSpeed(float) : "Set the speed and update immediately."
	input TeleportToTarget(target_destination) : "Teleport to this entity's origin."
	input SetMoveDistanceFromStart(float) : "Update the end position to be this distance from the start position."
	input SetMoveDistanceFromEnd(float) : "Update the start position to be this distance from the end position."

	// Outputs
	output OnFullyOpen(void) : "Fired when the brush reaches the end position (starting position + (move direction * move distance))."
	output OnFullyClosed(void) : "Fired when the brush reaches the starting position."
]

@SolidClass base(Targetname, Parentname, RenderFields, Shadow) = func_rotating : 
	"A rotating brush entity."
[
	maxspeed(integer) : "Max Rotation Speed" : 100 : "The maximum rotation speed of the brushes, in degrees per second."
	fanfriction(integer) : "Friction (0 - 100%)" : 20 : "The amount of rotational friction. Value must be between 0 and 100 %."
	message(sound) : "Rotating sound WAV" : : "Sound to play while rotating."
	volume(integer) : "Volume (10 = loudest)" : 10 : "The volume of the rotation sound."
	spawnflags(flags) =
	[
		1 : "Start ON"  : 0
		2 : "Reverse Direction" : 0
		4 : "X Axis"  : 0
		8 : "Y Axis"  : 0
		16: "Acc/Dcc" : 0
		32: "Fan Pain" : 0
		64: "Not Solid" : 0
		128: "Small Sound Radius" : 0
		256: "Medium Sound Radius" : 0
		512: "Large Sound Radius" : 1
		1024: "Client-side Animation" : 0
		2048: "Unblockable by Player" : 0
		4096: "Rotate in world space" : 0
	]
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	dmg(integer) : "Blocking Damage" : 0 : "Damage done to any entity that blocks the rotation, per frame."
	NoInterpolate(boolean) [ group="Misc" ] : "Disable Client-Side Interpolation" : 0
	MoveWithoutPushingBlockers(boolean) [ group="Misc" ] : "Move Without Pushing Blockers" : 0 : "Just rotates the entity and anything attached to it, without going the expensive process of finding and pushing potentially blocking brush entities and NPCs. Will still push dynamic physics entities."

	solidbsp(choices) : "Solid Type" : 0 =
	[
		0 : "VPhysics"	
		1 : "BSP"
	]

	// Inputs
	input SetSpeed(float) : "Sets the speed as a ratio of the specified Max Rotation Speed, where 0 is stopped and 1 is the Max Rotation Speed. Negative values rotate backwards. Any non-zero values with this call will cause rotating to start"
	input SnapToStartPos(void) : "Snap to the initial position and stop moving."
	input Start(void) : "Start the rotator rotating at maximum Speed"
	input Stop(void) : "Stop the rotator from rotating."
	input StopAtStartPos(void) : "Stop the rotator from rotating when it gets around to the start position again (on its rotation axis)."
	input SetStartPos(vector) : "Set angles that can be snapped back to."
	input StartForward(void) : "Start the rotator rotating forward at maximum speed."
	input StartBackward(void) : "Start the rotator rotating backward at maximum speed."
	input Toggle(void) : "Toggle the rotator between rotating and not rotating."
	input Reverse(void) : "Reverse the direction of rotation of the rotator, preserving the current speed."
	input EnableAccelDecel(void) : "Enables the acceleration and deceleration of this rotator"
	input DisableAccelDecel(void) : "Disables the acceleration and deceleration of this rotator (instantly starts/stops)"
	
	output OnStopped(void) : "Fired this brush has stopped moving."
	output OnStarted(void) : "Fired this brush has started moving"
	output OnReachedStart(void) : "Fired this brush has stopped moving."
]

@SolidClass base(Targetname, Parentname, RenderFields, BasePlat, Shadow) = func_platrot : 
	"A brush entity that moves vertically, and can rotate while doing so." 
[
	spawnflags(Flags) =
	[
		1: "Toggle" : 1
		64: "X Axis" : 0
		128: "Y Axis" : 0
	]
	noise1(sound) : "Movement Sound" : : "The sound to play when the brush moves."
	noise2(sound) : "Stop Sound" : : "The sound to play when the brush stops moving."
	speed(integer) : "Speed of Rotation" : 50 : "Speed at which the brush rotates, in degrees per second."
	height(integer) : "Travel Altitude" : 0 : "The vertical distance from the starting position that this platform moves. If negative, the platform will lower."
	rotation(integer) : "Spin amount" : 0 : "The amount this platform should rotate as it moves, in degrees."
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
]

@KeyFrameClass base(Targetname, Parentname, KeyFrame) size(-6 -6 -6, 6 6 6) color(255 200 0) keyframe() = keyframe_track : 
	"Animation KeyFrame"
[
]

@MoveClass base(Targetname, Parentname, KeyFrame, Mover) size(-8 -8 -8, 8 8 8) color(255 170 0) animator() = move_keyframed : 
	"Keyframed Move Behavior"
[
]

@MoveClass base(Targetname, Parentname, Mover, KeyFrame) size(-8 -8 -8, 8 8 8) color(255 0 0) animator() = move_track : 
	"Track Move Behavior"
[
	WheelBaseLength(integer) : "Distance between the wheels" : 50
	Damage(integer) : "Damage done to blocking entities" : 0
	NoRotate(boolean) : "Turn to face down path" : 0
]

//-------------------------------------------------------------------------
//
// Ropes and Cables
//
//-------------------------------------------------------------------------
@BaseClass = RopeKeyFrame
[
	spawnflags(Flags) = 
	[
		1 :  "Auto Resize" : 0
	]

	Slack(integer) : "Slack" : 25 : "How much extra length the rope has (by default it has the length between its two endpoints in the editor)."

	Type(choices) : "Type" : 0 =
	[
		0  : "Rope"
		1  : "Semi-rigid"
		2  : "Rigid"
	]

	Subdiv(integer) : "Subdivision" : 2 : "Number of subdivisions between each rope segment. Maximum value is 8. Higher values make smoother ropes, but are slower to render."
	Barbed(boolean) : "Barbed" : 0 : "Test effect that makes the rope look sharper and more barbed."

	Width(string) : "Width (1-64)" : "2" : "Width of the rope."
	TextureScale(string) : "Texture Scale" : "1" : "This changes the texture resolution. The default resolution is 4 pixels per inch. Larger values stretch the texture and smaller values scrunch it up."
	Collide(boolean) : "Collide with world" : 0
	Dangling(boolean) : "Start Dangling" : 0 : "Whether the rope starts out detached from its target endpoint."
	Breakable(boolean) : "Breakable" : 0 : "Whether the rope can be detached from either endpoint when shot."
	UseWind(boolean) : "Use Wind" : 0 : "Whether the rope be blown by the wind (enabling this is expensive!)"
	RopeMaterial(material) : "Rope Material" : "cable/cable.vmat" : "The material to use when rendering the rope."

	// Inputs
	input SetScrollSpeed(float) : "Set the speed at which the texture scrolls."
	input SetForce(string) : "Apply a force instantaneously to the rope. The parameter should be a vector containing the force to be applied (X Y Z)."
	input Break(void) : "Break the rope, if it's marked to do so."
]

@KeyFrameClass base(Targetname, Parentname, KeyFrame, RopeKeyFrame) editormodel("models/editor/axis_helper_thick.vmdl") keyframe() = keyframe_rope : 
	"A node entity that marks a point in a rope. The first node in the rope should be a move_rope, followed by 1 or more keyframe_ropes."
[
]

@MoveClass base(Targetname, Parentname, KeyFrame, RopeKeyFrame) editormodel("models/editor/axis_helper.vmdl") animator() = move_rope : 
	"The first node in set of nodes that are used to place ropes in the world. It should connect to 1 or more keyframe_rope entities."
[
	PositionInterpolator(choices) : "Position Interpolator" : 2 : "Curve Type. Currently only type 2 (Rope) is fully supported." =
	[
		0 : "Linear"
		1 : "Catmull-Rom Spline"
		2 : "Rope"
	]
]


//-------------------------------------------------------------------------
//
// Buttons
//
//-------------------------------------------------------------------------

@BaseClass = Button
[
	// Inputs
	input Lock(void) : "Lock the button, preventing it from functioning."
	input Unlock(void) : "Unlock the button, allowing it to function."
	input Disable(void) : "Disable the button, preventing entities from finding the button (removes all capabilities of the button)"
	input Enable(void) : "Enable the button, allowing entities to find the button again"
	input Press(void) : "Activate the button as if it was pressed."
	input PressIn(void) : "Activate the button as if it was pressed, sending it to the bottom position."
	input PressOut(void) : "Unpress the button, sending it to the top position."

	// Outputs
	output OnDamaged(void) : "Fired when the button is damaged."
	output OnPressed(void) : "Fired when the button is pressed."
	output OnUseLocked(void) : "Fired when the button is used while locked."
	output OnIn(void) : "Fired when the button reaches the in/pressed position."
	output OnOut(void) : "Fired when the button reaches the out/released position."

    displaytext(string) : "Display Text" : : "Place localization text here and it will be displayed in tooltips, etc."
]

@BaseClass = ButtonSounds
[
	use_sound(sound) : "Use sound" : ""  : "Sound event played when the button is successfully used."
	locked_sound(sound) : "Locked Sound" : "" : "Sound played when the player tries to use the button, and fails because it's locked."
	unlocked_sound(sound) : "Unlocked Sound" : "" : "Sound played when the button is unlocked."
]

@BaseClass base(Targetname, Parentname, RenderFields,DamageFilter, Button, ButtonSounds) = BaseFuncButton
[
	movedir(angle) : "Move Direction (Pitch Yaw Roll)" : "0 0 0" : "Specifies the direction of motion to move when the button is used."
	speed(integer) : "Speed" : 5 : "The speed that the button moves, in inches per second."
	glow(target_destination) : "Glow Entity" : : "The name of an entity that will get the +use glow for this button."
	wait(float) : "Delay Before Reset (-1 stay)" : 3 : "Amount of time, in seconds, after the button has been pressed before it returns to the starting position. Once it has returned, it can be used again. If the value is set to -1, the button never returns."
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."	
]

@SolidClass base(BaseFuncButton) drawangles_local{ angles_key = "movedir" } = func_button : 
	"A brush entity that's designed to be used for a player-useable button. When used by the player, it moves to a pressed position."
[
	lip(integer) : "Lip" : 0 : "The amount, in inches, of the button to leave sticking out of the wall it recedes into when pressed. Negative values make the button recede even further into the wall."
	master(string) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this button cannot be pressed."
	override_anticipation_name(string) : "Override Anticipation Action Name" : : "Specify an override for the GetUsePreviewAction for this button (the anticipation type)"
	forcenpcexclude(boolean) : "Force NPC Exclude" : "0" : "NPC movement and collision will ignore this button"

	spawnflags(flags) =
	[
		1: "Don't move" : 0
		2: "Starts Disabled" : 0
		32: "Toggle" : 0
		256: "Touch Activates": 0
		512: "Damage Activates": 0
		1024: "Use Activates" : 1
		2048: "Starts locked" : 0
		4096: "Sparks" : 0
		16384: "Non-solid" : 0
		32768: "Skip Player Animation" : 0	
	]
]

@SolidClass base(BaseFuncButton) drawangles_local{ angles_key = "movedir" } = func_physical_button : 
	"A brush entity that's designed to be used for a rotating player-useable button. When used by the player, it rotates to a pressed position."
[
	spawnflags(flags) =
	[
		32: "Toggle" : 0
		512: "Damage Activates": 0
		2048: "Starts locked" : 0
		4096: "Sparks" : 0
	]
]

@SolidClass base(Targetname, Parentname, Global, Button, ButtonSounds, EnableDisable) = func_rot_button : 
	"A brush entity that's designed to be used for a rotating player-useable button. When used by the player, it rotates to a pressed position."
[
	master(string) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this button cannot be used."
	speed(integer) : "Speed" : 50 : "The speed that the button rotates, in degrees per second."
	health(integer) : "Health (Obsolete)" : 0 : "Legacy method of specifying whether or not the button can be shot to activate it. Use the 'Damage Activates' spawnflag instead."
	wait(integer) : "Delay Before Reset (-1 stay)" : 3 : "Amount of time, in seconds, after the button has been pressed before it returns to the starting position. Once it has returned, it can be used again. If the value is set to -1, the button never returns."
	distance(integer) : "Distance (deg)" : 90 : "The amount, in degrees, that the button should rotate when it's pressed."
	// TODO: move spawnflags into Button base class?
	spawnflags(flags) =
	[
		1 : "Not solid" : 0
		2 : "Reverse Dir" : 0
		32: "Toggle" : 0
		64: "X Axis" : 0
		128: "Y Axis" : 0
		256: "Touch Activates": 0
		512: "Damage Activates": 0
		1024: "Use Activates": 0
		2048: "Starts locked" : 0
	]
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
]

@SolidClass base(Targetname, Parentname, RenderFields) = momentary_rot_button : 
	"A brush entity that's designed to be used for rotating wheels, where the player can rotate them to arbitrary positions before stopping."
[
	speed(integer) : "Speed (deg/sec)" : 50 : "The amount, in degrees, that the wheel turns per second."
	master(string) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this button cannot be used."
	glow(target_destination) : "Glow Entity" : : "The name of an entity that will get the +use glow for this button."
	sounds(choices) : "Sounds" : 0 = 
	[
		0: "None"
		1: "Big zap & Warmup"
		2: "Access Denied"
		3: "Access Granted"
		4: "Quick Combolock"
		5: "Power Deadbolt 1"
		6: "Power Deadbolt 2"
		7: "Plunger"
		8: "Small zap"
		9: "Keycard Sound"
		21: "Squeaky"
		22: "Squeaky Pneumatic"
		23: "Ratchet Groan"
		24: "Clean Ratchet"
		25: "Gas Clunk"
	]
	distance(integer) : "Distance" : 90 : "The maximum amount, in degrees, that the wheel is allowed to rotate."
	returnspeed(integer) : "Auto-return speed" : 0 : "If the 'Toggle' spawnflag is not set, the speed at which the wheel auto-returns when left alone, in degrees per second."
	spawnflags(flags) =
	[
		1: "Not Solid" : 1
		32: "Toggle (Disable Auto Return)" : 1
		64: "X Axis" : 0
		128: "Y Axis" : 0
		1024: "Use Activates" : 1
		2048: "Starts locked" : 0
		8192: "Jiggle when used while locked" : 0
	]
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	startposition(float) : "Start Position" : 0 : "Postion when spawned. The value is a range between 0.0 and 1.0, where 0 is the unrotated position and 1 is the rotated position + 'Distance'."
	startdirection(choices) : "Start Direction" : -1 =
	[
		-1 : "Forward"		 // Reverses upon USE, so are
		1 : "Backward"	 // reversed here.
	]
	solidbsp(boolean) : "Solid BSP" : 0

	// Inputs
	input Lock(void) : "Lock the button, preventing it from functioning."
	input Unlock(void) : "Unlock the button, allowing it to function."
	input Disable(void) : "Disable the button, preventing entities from finding the button (removes all capabilities of the button)"
	input Enable(void) : "Enable the button, allowing entities to find the button again"
	input SetPosition(string) : "Move to a position. The parameter must be a value between 0 and 1, where 0 is the unrotated position and 1 is the rotated position + 'Distance'."
	input SetPositionImmediately(string) : "Immediately teleport to a position. The parameter must be a value between 0 and 1, where 0 is the unrotated position and 1 is the rotated position + 'Distance'."

	// Outputs
	output Position(integer)   : "Fired whenever the button moves. The output is the position of button from 0 to 1, where 0 is the unrotated position and 1 is the rotated position + 'Distance'."
	output OnPressed(integer)  : "Fired when the button is first pressed."
	output OnUnpressed(integer): "Fired when the button is first released from being pressed."
	output OnFullyClosed(void) : "Fired when the button has reached position 1, the rotated position + 'Distance'."
	output OnFullyOpen(void)   : "Fired when the button has reached position 0, the unrotated starting position."
	output OnReachedPosition(void)   : "Fired whenever the button reaches a goal position: i.e. when it becomes open, becomes closed, or reaches the point specified by a 'SetPosition' input."
]


//-------------------------------------------------------------------------
//
// Doors
//
//-------------------------------------------------------------------------

@BaseClass base(Targetname, Parentname, RenderFields, Global, Shadow) = Door
[
	speed(float) : "Speed" : 100 : "The speed at which the door moves."
	master(string) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this button cannot be used."
	noise1(sound) : "Start Sound" : : "Sound to play when the door starts moving."
	noise2(sound) : "Stop Sound" : : "Sound to play when the door stops moving."
	startclosesound(sound) : "Start Close Sound" : : "(Optional) Sound to play when the door starts closing."
	closesound(sound) : "Stop Close Sound" : : "(Optional) Sound to play when the door stops closing."
	wait(integer) : "Delay Before Reset (-1 stay)" : 4 : "Amount of time, in seconds, after the door has opened before it closes. Once it has closed, it can be used again. If the value is set to -1, the door never closes itself."
	lip(integer) : "Lip" : 0 : "The amount, in inches, of the button to leave sticking out of the wall it recedes into when pressed. Negative values make the button recede even further into the wall."
	dmg(integer) : "Blocking Damage" : 0 : "Amount of damage done to entities that block the movement of this door, per frame."
	forceclosed(boolean) : "Force Closed" : 0 : "If set, this door will close no matter what. Useful for doors that have to close even if the player tries to block them with objects."
	ignoredebris(boolean) : "Ignore Debris" : 0 : "If set this will change the door's collision group to one that ignore collisions with debris objects (note that this is not compatible with the non-solid-to-player spawnflag)."

	message(string) : "Message If Triggered"		// NEEDHELP: Looks like this was removed
	health(integer) : "Health (shoot open)" : 0		// NEEDHELP: Looks like this was removed

	locked_sound(sound) : "Locked Sound" : "" : "Sound played when the player tries to use the door, and fails because it's locked."
	unlocked_sound(sound) : "Unlocked Sound" : "" : "Sound played when the door is unlocked."

	spawnpos(choices) : "Spawn Position" : 0 =
	[
		0 : "Closed"
		1 : "Open"
	]

	spawnflags(flags) =
	[
		1 : "Starts Open - OBSOLETE, use 'Spawn Position' key instead" : 0
		4 : "Non-solid to Player" : 0
		8: "Passable" : 0
		32: "Toggle" : 0
		256:"Use Opens" : 0
		512: "NPCs Can't Use" : 0
		1024: "Touch Opens" : 1
		2048: "Starts locked" : 0
		4096:	"Door Silent" : 0
	]
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	loopmovesound(boolean) : "Loop Moving Sound?" : 0 : "If set to true, the door's 'Start Sound' will be continually looped until the door finishes moving."

	// Outputs
	output OnClose(void) : "Fired when the door starts closing."
	output OnOpen(void) : "Fired when the door starts opening."
	output OnFullyOpen(void) : "Fired when the door reaches the fully open position. Reversed if 'Start Open' flag is set."
	output OnFullyClosed(void) : "Fired when the door reaches the fully closed position. Reversed if 'Start Open' flag is set."
	output OnBlockedClosing(void) : "Fired when the door is blocked while closing."
	output OnBlockedOpening(void) : "Fired when the door is blocked while opening."
	output OnUnblockedClosing(void) : "Fired when the door is unblocked while closing."
	output OnUnblockedOpening(void) : "Fired when the door is unblocked while opening."
	output OnLockedUse(void) : "Fired when the player uses the door, but it is locked."

	// Inputs
	input Open(void) : "Open the door, if it is not fully open."
	input Close(void) : "Close the door, if it is not fully closed."
	input Toggle(void) : "Toggle the door between open and closed."
	input Lock(void) : "Lock the door."
	input Unlock(void) : "Unlock the door."
	input SetSpeed(float) : "Set the door speed."
	input SetNoNPCs(boolean) : "Set whether NPCs can use this door or not."
]

@SolidClass base(Door) drawangles_local{ angles_key = "movedir" } = func_door : 
	"A brush entity for use as a player-useable door."
[
	movedir(angle) : "Move Direction (Pitch Yaw Roll)" : "0 0 0" : "The direction the door will move, when it opens."

	CreateNavObstacle(boolean) : "Create Nav Obstacle" : "1" : "Create a navigation obstacle to assist NPC pathfinding"

	filtername(filterclass) : "Block Filter Name" : : "Filter to use to determine entities that block the door. ( Half-Life: Source port only )"
]

@SolidClass base(Door) = func_door_rotating : 
	"A brush entity for use as a rotating player-useable door." 
[
	spawnflags(flags) =
	[
		2 : "Reverse Dir" : 0
		16: "One-way" : 0
		64: "X Axis" : 0
		128: "Y Axis" : 0
		65536: "New func_door +USE rules (NOT for prop_doors!!)" : 0
	]
	distance(integer) : "Distance" : 90 : "The amount, in degrees, that the button should rotate when it's pressed."

	solidbsp(choices) : "Solid Type" : 0 =
	[
		0 : "VPhysics"	
		1 : "BSP"
	]
]

@BaseClass = BaseFadeProp
[
	fademindist(float) [ group="Render Properties" ] : "Start Fade Dist" : -1 : "Distance at which the prop starts to fade (<0 = subtract from fademaxdist)."
	fademaxdist(float) [ group="Render Properties" ] : "End Fade Dist" : 0 : "Max fade distance at which the prop is visible (0 = don't fade out)"
	rendercolor(color255) : "Color (R G B)" : "255 255 255"
]


@BaseClass base(Targetname, Parentname, Global, Studiomodel, BaseFadeProp, Glow) = BasePropDoorRotating
[
	slavename(target_destination) : "Slave Name" : : "The name of any doors that should be slaved to this door (i.e. should open when this one opens, and close when this one closes)."
	
	ajarangle(float) : "Ajar Angle" : "0" : "If the door 'Spawn Position' is set to Ajar, this is the angle to spawn at, relative to the closed position."
	ajardoorshouldntalwaysopen(boolean) : "Ajar Shouldn't Always Open" : "0" : "By default, Ajar doors always open fully when +USEd. If this is set to true, Ajar doors will stop opening if they cross the close position."
	spawnpos(choices) : "Spawn Position" : 0 =
	[
		0 : "Closed"
		1 : "Open forward"
		2 : "Open back"
		3 : "Ajar (use Ajar Angle)"
	]
	
	distance(float) : "Rotation Distance (deg)" : 90 : "The amount, in degrees, that the door should rotate when opened."
	speed(integer) : "Speed" : 100 : "The speed at which the door moves."
	soundopenoverride(sound) : "Fully Open Sound" : : "Sound played when the door has finished opening."
	soundcloseoverride(sound) : "Fully Closed Sound" : : "Sound played when the door has finished closing."
	soundmoveoverride(sound) : "Moving Sound" : : "Sound played when the door starts to move."
	soundjiggleoverride(sound) : "Jiggle Sound" : : "Sound played when the player tries to move the door while the latch is engaged."
	returndelay(integer) : "Delay Before close (-1 stay open)" : -1 : "Amount of time, in seconds, after the door has opened before it closes. If the value is set to -1, the door never closes itself."
	dmg(integer) : "Damage Inflicted When Blocked" : 0 : "Amount of damage done to entities that block the movement of this door, per frame."
	health(integer) : "Health (0 = Unbreakable)" : 0			// NEEDHELP: Doesn't look like this is hooked up anymore?
	soundlockedoverride(sound) : "Locked Sound" : : "Sound played when the player tries to open the door, and fails because it's locked."
	soundunlockedoverride(sound) : "Unlocked Sound" : : "Sound played when the door is unlocked."
	soundlatchoverride(sound) : "Latch Sound" : : "Sound played when the door's latch is engaged."

	forceclosed(boolean) : "Force Closed" : 0 : "If set, this door will close no matter what. Useful for doors that have to close even if the player tries to block them with objects."

	rendertocubemaps(boolean) [ group="Render Properties" ] : "Render to Cubemaps" : 1 : "If true, this geometry renders into baked cube maps"
	lightmapstatic(choices) [ group="Render Properties" ] : "Lightmap Static" : 0 : "Determines if this geometry be considered static & cast shadows/bounce light when baking lightmaps?" =
	[
		0 : "No"
		1 : "Yes"
		2 : "Bounce Only"
	]

	spawnflags(flags) =
	[
		1 : "Starts Open" : 0
		512: "NPCs Can't Use" : 0
		2048: "Starts locked" : 0
		4096: "Door silent (No sound, and does not alert NPCs)" : 0
		8192: "Use closes" : 1
		16384 : "Door silent to NPCS (Does not alert NPCs)" : 0
		32768 : "Ignore player +USE" : 0
	]

	opendir(choices) : "Open Direction" : 0 : "Force the door to open only forwards or only backwards. Both directions is the standard door behavior." =
	[
		0 : "Open Both Directions"
		1 : "Open Forward Only"
		2 : "Open Backward Only"
	]

	// Outputs
	output OnClose(void) : "Fired when the door is told to close."
	output OnOpen(void) : "Fired when the door is told to open."
	output OnFullyOpen(void) : "Fired when the door reaches the fully open position."
	output OnAjarOpen(void) : "Fired when the door is ajar and told to open."
	output OnFullyClosed(void) : "Fired when the door reaches the fully closed position."
	output OnBlockedClosing(void) : "Fired when the door is blocked while closing."
	output OnBlockedOpening(void) : "Fired when the door is blocked while opening."
	output OnUnblockedClosing(void) : "Fired when the door is unblocked while closing."
	output OnUnblockedOpening(void) : "Fired when the door is unblocked while opening."
	output OnLockedUse(void) : "Fired when the player uses the door, but it is locked."

	// Inputs
	input Open(void) : "Open the door, if it is not fully open."
	input OpenAwayFrom(target_destination) : "Open the door away from the specified entity."
	input Close(void) : "Close the door, if it is not fully closed."
	input Toggle(void) : "Toggle the door between open and closed."
	input Lock(void) : "Lock the door."
	input Unlock(void) : "Unlock the door."
	input SetRotationDistance(float) : "Set the distance (in degrees) between Open and Closed."
	input SetSpeed(float) : "Set the speed at which the door rotates. 100 is default."
	input SetNoNPCs(boolean) : "Set whether NPCs can use this door or not."
]


@BaseClass tags( Particles ) = BModelParticleSpawner
[ 
	StartDisabled(boolean) : "Start Disabled" : 0

	Color(color255) : "Particle Color (R G B)" : "255 255 255"
	SpawnRate(integer) : "Particle Per Second" : 40 : "Number of particles to spawn, per second."
	SpeedMax(string) : "Maximum Particle Speed" : 13 : "Maximum speed that the particles can move after spawning."
	LifetimeMin(string) : "Minimum Particle Lifetime" : 3 : "Minimum number of seconds until each particle dies. Particles live for a random duration between this and 'Maximum Particle Lifetime'."
	LifetimeMax(string) : "Maximum Particle Lifetime" : 5 : "Maximum number of seconds until each particle dies. Particles live for a random duration between 'Minimum Particle Lifetime' and this."
	DistMax(integer) : "Maximum Visible Distance" : 1024 : "Maximum distance at which particles are visible. They fade to translucent at this distance."
	Frozen(boolean) : "Frozen" : 0 : "When set, this entity spawns the number of particles in SpawnRate immediately, and then goes inactive."

	// Inputs
	input TurnOn(void) : "Turn on."
	input TurnOff(void) : "Turn off."
]

@PointClass base( Targetname, Parentname ) tags( Particles ) size( -8 -8 -8, 8 8 8 ) = env_particlescript : 
	"An entity that has special animation events that can be fired by a model with an animation inside its .qc designed for"+
	"use by this entity."
[
	model(studio) : "Script Model" : "models/Ambient_citadel_paths.vmdl" : "Model to use for animation sequences."

	// Inputs
	input SetSequence(string) : "Sets the script model's sequence."
]


//-------------------------------------------------------------------------
//
// Logic Entities
//
//-------------------------------------------------------------------------

@PointClass base( Targetname ) tags( Logic ) iconsprite("editor/logic_auto.vmat")
	metadata
	{
		entity_tool_name = "Logic Auto"
		entity_tool_group = "Logic"
		entity_tool_tip = "Fire an output on map spawn"
	}
= logic_auto : 
	"Fires outputs when a map spawns. " +
	"If 'Remove on fire' flag is set the logic_auto is deleted after firing. " +
	"It can be set to check a global state before firing. This allows you to only fire events based on "+
	"what took place in a previous map."
[
	spawnflags(Flags) =
	[
		1 : "Remove on fire" : 1
	]
	
	globalstate(choices) : "Global State to Read" : : "If set, this specifies a global state to check before firing. The OnMapSpawn output will only fire if the global state is set." =
	[
		"" : "--- None ---"
		"gordon_precriminal" : "Gordon pre-criminal" 
		"antlion_allied" : "Antlions are player allies" 
//		"player_stealth" : "Player in APC is disguised as combine" 
		"suit_no_sprint" : "Suit sprint function not yet enabled" 
		"super_phys_gun" : "Super phys gun is enabled" 
		"friendly_encounter" : "Friendly encounter sequence (lower weapons, etc.)"
//		"citizens_passive" : "Citizens are *not* player allies (cannot be commanded)"
		"gordon_invulnerable" : "Gordon is invulnerable"
		"no_seagulls_on_jeep" : "Don't spawn seagulls on the jeep"
		"is_console" : "Game is running on a console"
		"is_pc" : "Game is running on a PC"
	]
	
	// Outputs
	output OnMapSpawn(void) : "Fired when the map is loaded for any reason."
	output OnNewGame(void) : "Fired when the map is loaded to start a new game."
	output OnLoadGame(void) : "Fired when the map is loaded from a saved game."
	output OnMapTransition(void) : "Fired when the map is loaded due to a level transition."
	output OnBackgroundMap(void) : "Fired when the map is loaded as a background to the main menu."
	output OnMultiNewMap(void) : "Fired only in multiplayer, when a new map is loaded."
	output OnMultiNewRound(void) : "Fired only in multiplayer, when a new round is started. Only fired in multiplayer games that use round-based gameplay."
	output OnDemoMapSpawn(void) : "Fired when the map is loaded in Demo Mode."
	output OnVREnabled(void) : "Fired when the map is loaded with a VR HMD active."
	output OnVRNotEnabled(void) : "Fired when the map is loaded without a VR HMD active."
]

@PointClass base(Targetname) tags( Logic ) iconsprite("editor/logic_compare.vmat") = logic_compare :
	"Compares an input value to another value. " +
	"If the input value is less than the compare value, the OnLessThan output is fired with the input value. " +
	"If the input value is equal to the compare value, the OnEqualTo output is fired with the input value. " +	
	"If the input value is greater than the compare value, the OnGreaterThan output is fired with the input value."
[
	// Keys
	InitialValue(float) : "Initial value" : : "Initial value for the input value."
	CompareValue(float) : "Compare value" : : "The value to compare against."
	
	// Inputs
	input SetValue(float) : "Set the value that will be compared against the compare value."
	input SetValueCompare(float) : "Set the value that will be compared against the compare value and performs the comparison."
	input SetCompareValue(float) : "Set the compare value."
	input Compare(void) : "Force a compare of the input value with the compare value."
	
	// Outputs
	output OnLessThan(float) : "Fired when the input value is less than the compare value. Sends the input value as data." 
	output OnEqualTo(float) : "Fired when the input value is equal to the compare value. Sends the input value as data." 
	output OnNotEqualTo(float) : "Fired when the input value is different from the compare value. Sends the input value as data." 
	output OnGreaterThan(float) : "Fired when the input value is greater than the compare value. Sends the input value as data."
]

@PointClass base(Targetname) tags( Logic ) iconsprite("editor/logic_branch.vmat")
	metadata
	{
		entity_tool_name = "Logic Branch"
		entity_tool_group = "Logic"
	}
= logic_branch :
	"Tests a boolean value and fires an output based on whether the value is true or false. " +
	"Use this entity to branch between two potential sets of events."
[
	// Keys
	InitialValue(integer) : "Initial value" : : "Initial value for the boolean value (0 or 1)."
	
	// Inputs
	input SetValue(bool) : "Set the boolean value without performing the comparison. Use this to hold a value for a future test."
	input SetValueTest(bool) : "Set the boolean value and test it, firing OnTrue or OnFalse based on the new value."
	input Toggle(void) : "Toggle the boolean value between true and false."
	input ToggleTest(void) : "Toggle the boolean value and tests it, firing OnTrue or OnFalse based on the new value."
	input Test(void) : "Test the input value and fire OnTrue or OnFalse based on the value."
	
	// Outputs
	output OnTrue(bool) : "Fired when the input value is true (nonzero)." 
	output OnFalse(bool) : "Fired when the input value is false (zero)." 
]


@PointClass base(Targetname) tags( Logic ) = logic_branch_listener :
	"Contains a list of logic_branch entities and fires outputs when the state of any of the logic_branches changes.<br><br>"+
	"This entity is used to fire an event when a set of conditions are all satisfied."
[
	Branch01(target_destination) : "Logic Branch 01" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch02(target_destination) : "Logic Branch 02" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch03(target_destination) : "Logic Branch 03" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch04(target_destination) : "Logic Branch 04" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch05(target_destination) : "Logic Branch 05" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch06(target_destination) : "Logic Branch 06" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch07(target_destination) : "Logic Branch 07" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch08(target_destination) : "Logic Branch 08" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch09(target_destination) : "Logic Branch 09" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch10(target_destination) : "Logic Branch 10" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch11(target_destination) : "Logic Branch 11" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch12(target_destination) : "Logic Branch 12" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch13(target_destination) : "Logic Branch 13" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch14(target_destination) : "Logic Branch 14" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch15(target_destination) : "Logic Branch 15" : : "The name of one or more logic_branches (wildcards allowed)."
	Branch16(target_destination) : "Logic Branch 16" : : "The name of one or more logic_branches (wildcards allowed)."

	input Test(void) : "Tests the state of all the logic_branches in the list and fires the appropriate output."

	output OnAllTrue(void) : "Fired when all the logic_branches in the list become true."
	output OnAllFalse(void) : "Fired when all the logic_branches in the list become false."
	output OnMixed(void) : "Fired when one of the logic branches in the list changes, but some are true and some are false."
]


@PointClass base(Targetname) tags( Logic ) iconsprite("editor/logic_case.vmat")
	metadata
	{
		entity_tool_name = "Logic Case"
		entity_tool_group = "Logic"
	}
= logic_case :
	"Compares an input to up to 32 preset values. If the input value is the same as " +
	"any of the preset values, an output corresponding to that value is fired.<br><br>" +
	"For example: if Case01 is set to 2 and Case02 is set to 5, and the input value is 5, " +
	"the OnCase02 output will be fired.<br><br>" +
	"This entity can also be used to select from a number of random targets via the " +
	"PickRandom input. One of the OnCase outputs that is connected to another entity will " +
	"be picked at random and fired."
[
	Case01(string) : "Case 01"
	Case02(string) : "Case 02"
	Case03(string) : "Case 03"
	Case04(string) : "Case 04"
	Case05(string) : "Case 05"
	Case06(string) : "Case 06"
	Case07(string) : "Case 07"
	Case08(string) : "Case 08"
	Case09(string) : "Case 09"
	Case10(string) : "Case 10"
	Case11(string) : "Case 11"
	Case12(string) : "Case 12"
	Case13(string) : "Case 13"
	Case14(string) : "Case 14"
	Case15(string) : "Case 15"
	Case16(string) : "Case 16"
	Case17(string) : "Case 17"
	Case18(string) : "Case 18"
	Case19(string) : "Case 19"
	Case20(string) : "Case 20"
	Case21(string) : "Case 21"
	Case22(string) : "Case 22"
	Case23(string) : "Case 23"
	Case24(string) : "Case 24"
	Case25(string) : "Case 25"
	Case26(string) : "Case 26"
	Case27(string) : "Case 27"
	Case28(string) : "Case 28"
	Case29(string) : "Case 29"
	Case30(string) : "Case 30"
	Case31(string) : "Case 31"
	Case32(string) : "Case 32"

	// Inputs
	input InValue(string) : "Compares the Input value to the case values, and fires the appropriate output, if any."
	input PickRandom(void) : "Fires a random OnCase output with at least one connection."
	input PickRandomShuffle(void) : "Fires a random OnCase output with at least one connection, with no repeats until all cases have been picked, at which point the shuffle starts over."
	input ResetShuffle(void) : "Starts the shuffle over so that the next PickRandomShuffle can select from all cases."
	
	// Outputs
	output OnDefault(void) : "Fired when the input value does not equal any of the Case values."
	output OnCase01(void) : "Fired when the input value equals the Case01 value."
	output OnCase02(void) : "Fired when the input value equals the Case02 value."
	output OnCase03(void) : "Fired when the input value equals the Case03 value."
	output OnCase04(void) : "Fired when the input value equals the Case04 value."
	output OnCase05(void) : "Fired when the input value equals the Case05 value."
	output OnCase06(void) : "Fired when the input value equals the Case06 value."
	output OnCase07(void) : "Fired when the input value equals the Case07 value."
	output OnCase08(void) : "Fired when the input value equals the Case08 value."
	output OnCase09(void) : "Fired when the input value equals the Case09 value."
	output OnCase10(void) : "Fired when the input value equals the Case10 value."
	output OnCase11(void) : "Fired when the input value equals the Case11 value."
	output OnCase12(void) : "Fired when the input value equals the Case12 value."
	output OnCase13(void) : "Fired when the input value equals the Case13 value."
	output OnCase14(void) : "Fired when the input value equals the Case14 value."
	output OnCase15(void) : "Fired when the input value equals the Case15 value."
	output OnCase16(void) : "Fired when the input value equals the Case16 value."
	output OnCase17(void) : "Fired when the input value equals the Case17 value."
	output OnCase18(void) : "Fired when the input value equals the Case18 value."
	output OnCase19(void) : "Fired when the input value equals the Case19 value."
	output OnCase20(void) : "Fired when the input value equals the Case20 value."
	output OnCase21(void) : "Fired when the input value equals the Case21 value."
	output OnCase22(void) : "Fired when the input value equals the Case22 value."
	output OnCase23(void) : "Fired when the input value equals the Case23 value."
	output OnCase24(void) : "Fired when the input value equals the Case24 value."
	output OnCase25(void) : "Fired when the input value equals the Case25 value."
	output OnCase26(void) : "Fired when the input value equals the Case26 value."
	output OnCase27(void) : "Fired when the input value equals the Case27 value."
	output OnCase28(void) : "Fired when the input value equals the Case28 value."
	output OnCase29(void) : "Fired when the input value equals the Case29 value."
	output OnCase30(void) : "Fired when the input value equals the Case30 value."
	output OnCase31(void) : "Fired when the input value equals the Case31 value."
	output OnCase32(void) : "Fired when the input value equals the Case32 value."
]

// NEEDHELP: Unused in HL2, not clear what it's useful for.
@PointClass base(Targetname) tags( Logic ) iconsprite("editor/logic_multicompare.vmat") = logic_multicompare :
	"Compares a set of inputs to each other. If they are all the same, fires an OnEqual output. " +
	"If any are different, fires the OnNotEqual output."
[
	// keys
	IntegerValue(integer) : "Integer Value (optional)"
	ShouldComparetoValue(boolean) : "Should use Integer Value" : 0

	// Inputs
	input InputValue(integer) : "Input value"
	input CompareValues(void) : "Compares the values and fires appropriate outputs"

	// Outputs
	output OnEqual(void) : "Fires if the values are equal"
	output OnNotEqual(void) : "Fires if the values are not equal"
]

@BaseClass = LogicNPCCounterPointBase
[ 
	startDisabled(bool) : "Start Disabled" : 0
	sourceEntityName(target_destination) : "Source Entity Name" : "" : "Name of the entity to check distance from"
	minCount(int) : "On Min Count All" : -1 : "The minimum count threshold of all npcs"
	maxCount(int) : "On Max Count All" : -1 : "The maximum count threshold of all npcs"
	minFactor(int) : "Min Factor All" : 0 : "The minimum count of all npcs for factor calculations"
	maxFactor(int) : "Max Factor All" : 0 : "The maximum count of all npcs for factor calculations"

	// npc type 1
	NPCType1(npcclass) : "Class name of NPC 1 to count"
	NPCState1(choices) : "NPC State 1" : "-1" : "Only match NPCs in this state" =
	[
		-1 : "Any"
		0 : "None"
		1 : "Idle"
		2 : "Alert"
		3 : "Combat"
		4 : "Script"
		5 : "Playdead"
		6 : "Prone"
		7 : "Dead"
	]
	invertState1(bool) : "Invert State" : 0
	minCount1(int) : "On Min Count 1" : -1 : "The minimum count threshold of npc 1"
	maxCount1(int) : "On Max Count 1" : -1 : "The maximum count threshold of npc 1"
	minFactor1(int) : "Min Factor 1" : 0 : "The minimum count of npc 1 for factor calculations"
	maxFactor1(int) : "Max Factor 1" : 0 : "The maximum count of npc 1 for factor calculations"
	defaultDist1(float) : "Default Dist 1" : 0 : "The default minimum player distance of npc 1"

	// npc type 2
	NPCType2(npcclass) : "Class name of NPC 2 to count"
	NPCState2(choices) : "NPC State 2" : "-1" : "Only match NPCs in this state" =
	[
		-1 : "Any"
		0 : "None"
		1 : "Idle"
		2 : "Alert"
		3 : "Combat"
		4 : "Script"
		5 : "Playdead"
		6 : "Prone"
		7 : "Dead"
	]
	invertState2(bool) : "Invert State" : 0
	minCount2(int) : "On Min Count 2" : -1 : "The minimum count threshold of npc 2"
	maxCount2(int) : "On Max Count 2" : -1 : "The maximum count threshold of npc 2"
	minFactor2(int) : "Min Factor 2" : 0 : "The minimum count of npc 2 for factor calculations"
	maxFactor2(int) : "Max Factor 2" : 0 : "The maximum count of npc 2 for factor calculations"
	defaultDist2(float) : "Default Dist 2" : 0 : "The default minimum player distance of npc 2"


	// npc type 3
	NPCType3(npcclass) : "Class name of NPC 3 to count"
	NPCState3(choices) : "NPC State 3" : "-1" : "Only match NPCs in this state" =
	[
		-1 : "Any"
		0 : "None"
		1 : "Idle"
		2 : "Alert"
		3 : "Combat"
		4 : "Script"
		5 : "Playdead"
		6 : "Prone"
		7 : "Dead"
	]
	invertState3(bool) : "Invert State" : 0
	minCount3(int) : "On Min Count 3" : -1 : "The minimum count threshold of npc 3"
	maxCount3(int) : "On Max Count 3" : -1 : "The maximum count threshold of npc 3"
	minFactor3(int) : "Min Factor 3" : 0 : "The minimum count of npc 3 for factor calculations"
	maxFactor3(int) : "Max Factor 3" : 0 : "The maximum count of npc 3 for factor calculations"
	defaultDist3(float) : "Default Dist 3" : 0 : "The default minimum player distance of npc 3"


	//Inputs
	input Enable(void) : "Enable the entity"
	input Disable(void) : "Disable the entity"
	input SetSourceEntity(string) : "Set the name of the entity to base this entities location on. This check will follow the entity as it moves."
	
	//Outputs
	output OnMinCountAll(void) : "Fired when the count of all npcs transitions to the min count or less."
	output OnMaxCountAll(void) : "Fired when the count of all npcs transitions to the max count or greater."
	output OnRangeFactorAll(float) : "Outputs the factor of the count of all npcs."
	output OnMinPlayerDistAll(float) : "Outputs distance to the NPC, of all NPCs, that is closest to player."
	// npc 1
	output OnMinCount1(void) : "Fired when the count of npc 1 transitions to the min count or less."
	output OnMaxCount1(void) : "Fired when the count of npc 1 transitions to the max count or greater."
	output OnRangeFactor1(float) : "Outputs the factor of the count of npc 1."
	output OnMinPlayerDist1(float) : "Outputs distance to the NPC, of NPCs 1, that is closest to player."
	// npc 2
	output OnMinCount2(void) : "Fired when the count of npc 2 transitions to the min count or less."
	output OnMaxCount2(void) : "Fired when the count of npc 2 transitions to the max count or greater."
	output OnRangeFactor2(float) : "Outputs the factor of the count of npc 2."
	output OnMinPlayerDist2(float) : "Outputs distance to the NPC, of NPCs 2, that is closest to player."
	// npc 3
	output OnMinCount3(void) : "Fired when the count of npc 3 transitions to the min count or less."
	output OnMaxCount3(void) : "Fired when the count of npc 3 transitions to the max count or greater."
	output OnRangeFactor3(float) : "Outputs the factor of the count of npc 3."
	output OnMinPlayerDist3(float) : "Outputs distance to the NPC, of NPCs 3, that is closest to player."

]

@PointClass base( Targetname, LogicNPCCounterPointBase ) tags( Logic ) iconsprite("editor/math_counter.vmat") sphere(distanceMax) = logic_npc_counter_radius :
	"Does calculations based on the number of a specified type of NPC in a specified region."
[
	distanceMax(float) : "Maximum Distance" : "25.0" : "Maximum distance to test for NPC"
]

@PointClass base( Targetname, LogicNPCCounterPointBase ) tags( Logic ) iconsprite("editor/math_counter.vmat") box_world_aligned( box_outer_mins, box_outer_maxs ) = logic_npc_counter_aabb :
	"Does calculations based on the number of a specified type of NPC in a specified region."
[	
	box_outer_mins(vector) : "Box Outer Mins" : "-64 -64 -64"
	box_outer_maxs(vector) : "Box Outer Maxs" : "64 64 64"	
]

@PointClass base( Targetname, logic_npc_counter_aabb ) tags( Logic ) iconsprite("editor/math_counter.vmat") box_oriented( box_outer_mins, box_outer_maxs ) = logic_npc_counter_obb :
"Does calculations based on the number of a specified type of NPC in a specified region."
[
]


@PointClass base(Targetname) tags( Logic ) iconsprite("editor/logic_script.vmat") = logic_script : "An entity that acts as a container for scripts"
[
	Group00(target_destination) : "EntityGroup[0]"
	Group01(target_destination) : "EntityGroup[1]"
	Group02(target_destination) : "EntityGroup[2]"
	Group03(target_destination) : "EntityGroup[3]"
	Group04(target_destination) : "EntityGroup[4]"
	Group05(target_destination) : "EntityGroup[5]"
	Group06(target_destination) : "EntityGroup[6]"
	Group07(target_destination) : "EntityGroup[7]"
	Group08(target_destination) : "EntityGroup[8]"
	Group09(target_destination) : "EntityGroup[9]"
	Group10(target_destination) : "EntityGroup[10]"
	Group11(target_destination) : "EntityGroup[11]"
	Group12(target_destination) : "EntityGroup[12]"
	Group13(target_destination) : "EntityGroup[13]"
	Group14(target_destination) : "EntityGroup[14]"
	Group15(target_destination) : "EntityGroup[15]"
]


@PointClass base(Targetname, EnableDisable) tags( Logic ) iconsprite("editor/logic_relay.vmat") 
	metadata
	{
		entity_tool_name = "Logic Relay"
		entity_tool_group = "Logic"
		entity_tool_tip = "Forwards events to other entities"
	}
= logic_relay :
	"A message forwarder. Fires an OnTrigger output when triggered, and " +
	"can be disabled to prevent forwarding outputs.<br><br>" +
	"Useful as an intermediary between one entity and another for turning " +
	"on or off an I/O connection, or as a container for holding a set of " +
	"outputs that can be triggered from multiple places."
[
	TriggerOnce(boolean) : "Trigger Once" : 0 : "Deletes the logic relay after firing an OnTrigger() or a connected OnSpawn() output"
	FastRetrigger(boolean) : "Fast Retrigger" : 0 : "Without this, the logic_relay will wait until all inputs connected to OnTrigger() have fired before retriggering"
	PassthroughCaller(boolean) : "Pass through caller" : 0 : "If set, this logic_relay will be ignored by !caller in downstream IO connections. Instead, the previous caller in the IO chain will be found by !caller."
	
	// Inputs
	input Trigger( api )
	input Toggle( api )
	input CancelPending( api )
	
	// Outputs
	output OnSpawn( api )
	output OnTrigger( api )
]


@PointClass base(Targetname, EnableDisable) tags( Logic ) iconsprite("editor/logic_timer.vmat") 
	metadata
	{
		entity_tool_name = "Logic Timer"
		entity_tool_group = "Logic"
		entity_tool_tip = "Fire an event on a timer"
	}
= logic_timer :
	"An entity that fires a timer event at regular, or random, intervals. It can also be set to oscillate between" + 
	"a high and low end, in which case it will fire alternating high/low outputs each time it fires."
[
	// Keys
	spawnflags(flags) =
	[
		1 : "Oscillator (alternates between OnTimerHigh and OnTimerLow outputs)" : 0
	]

	UseRandomTime(boolean) : "Use Random Time" : 0
	PauseAfterFiring(boolean) : "Pause After Firing" : 0
	
	LowerRandomBound(float) : "Minimum Random Interval" : : "If 'Use Random Time' is set, this is the minimum time between timer fires. The time will be a random number between this and the 'Maximum Random Interval'."
	UpperRandomBound(float) : "Maximum Random Interval" : : "If 'Use Random Time' is set, this is the maximum time between timer fires. The time will be a random number between the 'Minimum Random Interval' and this."
	RefireTime(float) : "Refire Interval" : : "If 'Use Random Time' isn't set, this is the time between timer fires, in seconds."
	InitialDelay(float) : "Initial delay before first fire" : 0 : "Time to wait after the timer is enabled before firing the first time. Negative values can be used to avoid "+
						  "waiting the lower random bound on spawn, or positive values to postpone the first event."

	// Inputs
	input RefireTime(float) : "Set a new Refire Interval."
	input ResetTimer(void) : "Reset the timer. It will fire after the Refire Interval expires."
	input FireTimer(void) : "Force the timer to fire immediately."
	input Toggle(void) : "Toggle the timer on/off."
	input LowerRandomBound(float) : "Set a new Minimum Random Interval."
	input UpperRandomBound(float) : "Set a new Maximum Random Interval."
	input AddToTimer(float) : "Add time to the timer if it is currently enabled.  Does not change the Refire Interval."
	input SubtractFromTimer(float) : "Subtract time from the timer if it is currently enabled.  Does not change the Refire Interval."
	input PauseTimer(void) : "Pauses the timer, maintaining its current remaining time."
	input UnpauseTimer(void) : "Unpauses the timer, continuing from where it left off when frozen."


	// Outputs
	output OnTimer(void) : "Fired when the timer expires."
	output OnTimerHigh(void) : "Fired every other time for an oscillating timer."
	output OnTimerLow(void) : "Fired every other time for an oscillating timer."
]


@PointClass base(Targetname) = hammer_updateignorelist :
	"Specifies entities that are to be ignored by the hammer_update_safe_entities console command. " + 
	"Enter the targetnames of entities that you want to exclude into the list of fields here. " +
	"Several of these may exist in a map."
[
	IgnoredName01(target_destination) : "IgnoredName 01" : "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName02(target_destination) : "IgnoredName 02" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName03(target_destination) : "IgnoredName 03" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName04(target_destination) : "IgnoredName 04" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName05(target_destination) : "IgnoredName 05" : ""  : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName06(target_destination) : "IgnoredName 06" : ""  : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName07(target_destination) : "IgnoredName 07" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName08(target_destination) : "IgnoredName 08" : ""  : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName09(target_destination) : "IgnoredName 09" : ""  : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName10(target_destination) : "IgnoredName 10" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName11(target_destination) : "IgnoredName 11" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName12(target_destination) : "IgnoredName 12" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName13(target_destination) : "IgnoredName 13" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName14(target_destination) : "IgnoredName 14" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName15(target_destination) : "IgnoredName 15" :  "" : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
	IgnoredName16(target_destination) : "IgnoredName 16" : ""  : "Do not send this entity's information back to hammer during hammer_update_safe_entities"
]


@PointClass base(Targetname) tags( Logic ) size(-4 -4 -4, 4 4 4) color(0 255 0) = logic_collision_pair : 
	"An entity that can be used to enables/disable vphysics collisions between two target entities."
[
	attach1(target_destination) : "Attachment 1" : "" : "First entity.  Must be a single entity unless \"Support multiple entities with same name\" is specified."
	attach2(target_destination) : "Attachment 2" : "" : "Second entity.  Must be a single entity unless \"Support multiple entities with same name\" is specified."

	support_multiple_entities_with_same_name(boolean) : "Support multiple entities with same name" : 0 : "If true, we affect all entities matching our attachment names. If false, we only affect the first entity found matching each attachment name."
	include_hierarchy(boolean) : "Include Hierarchy" : 0 : "Disable collision between the entire hierarchies of the two entities, instead of just the individual entities themselves."
	startdisabled(boolean) : "Start with collisions disabled" : 1

	// Inputs
	input EnableCollisions(void) : "Enable collisions between the first and second entity."
	input DisableCollisions(void) : "Disable collisions between the first and second entity."
	input DisableCollisionsWith(string) : "Disable collisions between the first entity and use the parameter to find the second entity."
]

@PointClass base(Targetname, EnableDisable ) = math_remap :
	"An entity that remaps a range of input values to a given range of output values."
[
	spawnflags(flags) = 
	[
		1 : "Ignore out of range input values" : 1
		2 : "Clamp out of range output values" : 1
	]

	in1(integer) : "Minimum Valid Input Value" : 0 : "Input values below this value will be ignored."
	in2(integer) : "Maximum Valid Input Value" : 1 : "Input values above this value will be ignored."
	out1(integer) : "Output Value When Input Is Min." : : "When the input value is equal to 'Minimum Valid Input Value', this is the output value."
	out2(integer) : "Output Value When Input Is Max." : : "When the input value is equal to 'Maximum Valid Input Value', this is the output value."

	// Inputs
	input InValue(float) : "Input value and fire the output with the remapped value."
	
	// Outputs
	output OutValue(float) : "Fired when the InValue input is received, with the remapped input value as the parameter."
	output OnRoseAboveMin(void) : "Fired when the InValue input rises above the minimum legal value."
	output OnRoseAboveMax(void) : "Fired when the InValue input rises above the maximum legal value."
	output OnFellBelowMin(void) : "Fired when the InValue input falls below the minimum legal value."
	output OnFellBelowMax(void) : "Fired when the InValue input falls below the maximum legal value."
]

@PointClass base(Targetname) = math_colorblend :
	"Used to create a blend between two colors for controlling the color of another entity."
[
	spawnflags(flags) = 
	[
		1 : "Ignore out of range input values" : 1
	]

	inmin(integer) : "Minimum Valid Input Value" : 0 : "Input values below this value will be ignored."
	inmax(integer) : "Maximum Valid Input Value" : 1 : "Input values above this value will be ignored."
	colormin(color255) : "Output RGB color when input is min." : "0 0 0" : "When the input value is equal to 'Minimum Valid Input Value', this is the output RGB color."
	colormax(color255) : "Output RGB color when input is max." : "255 255 255" : "When the input value is equal to 'Maximum Valid Input Value', this is the output RGB color."

	// Inputs
	input InValue(float) : "Input value and fire the output with the remapped value."
	
	// Outputs
	output OutColor(color255) : "Fired when the InValue input is received, with the remapped RGB color as the parameter."
]

@PointClass base(Targetname, EnableDisable) iconsprite("editor/math_counter.vmat") tags( Logic )
	metadata
	{
		entity_tool_name = "Math Counter"
		entity_tool_group = "Logic"
		entity_tool_tip = "Store a numeric value and perform arithmetic operations on it"
	}
= math_counter :
	"Holds a numeric value and performs arithmetic operations upon it. If either the minimum or maximum " +
	"legal value is nonzero, OutValue will be clamped to the legal range, and the OnHitMin/OnHitMax " +
	"outputs will be fired at the appropriate times. If both min and max are set to zero, no clamping is " +
	"performed and only the OutValue output will be fired."
[
	// Keys
	startvalue(integer) : "Initial Value" : 0 : "Starting value for the counter."
	min(integer) : "Minimum Legal Value" : 0 : "Minimum legal value for the counter. If min=0 and max=0, no clamping is performed."
	max(integer) : "Maximum Legal Value" : 0 : "Maximum legal value for the counter. If min=0 and max=0, no clamping is performed."

	// Inputs
	input Add(integer) : "Add an amount to the counter and fire the OutValue output with the result."
	input Divide(integer): "Divide the counter by an amount and fire the OutValue output with the result."
	input Multiply(integer): "Multiply the counter by an amount and fire the OutValue output with the result."
	input SetValue(integer): "Set the counter to a new value and fire the OutValue output with the result."
	input SetValueNoFire(integer): "Set the counter to a new value without firing any outputs."
	input Subtract(integer): "Subtract an amount from the counter and fire the OutValue output with the result."
	input SetHitMax(integer): "Set the upper bound of the counter and fire the OutValue output with the current value."
	input SetHitMin(integer): "Set the lower bound of the counter and fire the OutValue output with the current value."
	input GetValue(void): "Causes the counter fire its OnGetValue output with the current value of the counter. Used for polling the counter when you don't want constant updates from the OutValue output."

	// Outputs
	output OutValue(integer) : "Fired when the counter value changes."
	output OnHitMin(void) : "Fired when the counter value meets or goes below the min value. The counter must go back above the min value before the output will fire again."
	output OnHitMax(void) : "Fired when the counter value meets or exceeds the max value. The counter must go below the max value before the output will fire again."
	output OnChangedFromMin(void) : "Fired when the counter value changes from the minimum value."
	output OnChangedFromMax(void) : "Fired when the counter value changes from the max value."
	output OnGetValue(integer) : "Fired in response to the GetValue input. Used for polling the counter when you don't want constant updates from the OutValue output."
]

@PointClass base(Targetname) tags( Logic ) size(-8 -8 -8, 8 8 8) = logic_lineto : 
	"An entity that calculates and outputs a vector from one entity to another." 
[
	source(target_destination) : "Start entity" : : "Name of the entity the line should start from."
	target(target_destination) : "End entity" : : "Name of the entity that line should end at."
	
	// Outputs
	output Line(vector) : "Fired when the vector, from the start entity to the end entity, changes. Passes along the vector as a parameter."
]

@PointClass base(Targetname) tags( Logic ) size(-8 -8 -8, 8 8 8) = logic_navigation : 
	"An entity that is used to set navigation properties on other entities. Useful to make NPCs ignore physics props in their way that they can easily push." 
[
	target(target_destination) : "Navigation Entity" : "Name of the entity to set navigation properties on."
	spawnflags(flags) =
	[
		1 : "Start On" : 1
	]
	navprop(choices) : "Nav Property" : "Ignore" =
	[
		"Ignore" : "NPCs Ignore this when navigating (they'll bump into it)"
	]
	
	// Inputs
	input TurnOn(void) : "Turn on. The Navigation Entity will have its navigation properties set."
	input TurnOff(void) : "Turn off. The Navigation Entity will have its navigation properties returned to the default settings."
	input Toggle(void) : "Toggle on/off."
]

@PointClass base(Targetname) tags( Logic ) iconsprite("editor/logic_autosave.vmat") = logic_autosave :
	"An entity that is used to force an autosave."
[
	NewLevelUnit(boolean) : "Force New Level Unit" : 0 : "If set, the save will discard any savedata from previous levels, for the purpose of keeping savegame filesizes down. Can only be safely used if there is no way for the player to return to previous levels."
	
	MinimumHitPoints(integer): "Minimum Hit Points" : 0 : "Don't save dangerous when player has less than this many hitpoints."
	MinHitPointsToCommit(integer) : "Minimum Hit Points to Commit" : 0 : "Minimum hitpoints required to commit to save. The save will be made if you have at least Minimum Hit Points, but when the autosave timer expires, the autosave is only kept if you have at least Min Hitpoints to Commit."

	// Inputs
	input Save(void) : "Force an autosave."
	input SaveDangerous(float) : "Force an autosave as autosavedangerous.sav. If the player is alive after the passed number of seconds it replaces the standard auto save."
	input SetMinHitpointsThreshold(integer) : "Set MinimumHitPoints to this."
]

@PointClass base(Targetname) tags( Logic ) size(-8 -8 -8, 8 8 8) = logic_active_autosave :
	"An entity that is used to look for opportunities to autosave."
[
	MinimumHitPoints(integer): "Initiation Hit Points" : 30 : "Start looking for an opportunity to save if player drops below this hitpoint level."
	TriggerHitPoints(integer): "Trigger Hit Points" : 75 : "If started looking for an opportunity, save when hitpoints reach this level."
	TimeToTrigget(float): "Time to trigger" : 0 : "If > 0, how long to try and get a save off before giving up"
	DangerousTime(float): "Dangerous time" : 10 : "If 0, just autosave. Otherwise, do an autosavedangerous with this time threshold"
	
	// Inputs
	input Enable(void) : "Enable the entity"
	input Disable(void) : "Enable the entity"
]

@PointClass base( Targetname ) tags( Info ) iconsprite("editor/info_world_layer.vmat") = info_world_layer :
[
	layerName(string) : "World layer name" : "" : "Name of the world layer which this entity will control"
	
	spawnflags(flags) =
	[
		1 : "Visible on spawn" : 0
	]

	childSpawnGroup(choices) : "Spawn Type" : 0 : "If you select Child Spawn Group, it means the world layer is dependent on resources in the parent map that defines the info_worldlayer. For example, the dota world layers containing the dire and radiant bases refer to the tree maps of the main dota map. They would need to be set as Child spawn groups." =
	[
		0 : "Default"
		1 : "World Layer is Child Spawn Group"
	]

	// Inputs
	input ShowWorldLayer(void) : "Show the world geometry the target layer, but not the associated entities"
	input HideWorldLayer(void) : "Hide the world geometry of the target layer, but not the associated entities"
	input SpawnEntities(void) : "Spawn the entities associated with the layer, but don't change the visiblity of the world geometry"
	input DestryEntities(void) : "Destroy the entities spawned by the world layer, but don't change the visibilty of the world geometry"
	input ShowWorldLayerAndSpawnEntities(void) : "Show the world geometry of the target layer and spawn the associated entities"
	input HideWorldLayerAndDestroyEntities(void) : "Hide the world goemtry of the target layer and destory the associated entities"

	// Outputs
	output OnEntitiesSpawned(void) : "Fired when the entities associated with the layer have been spawned."
]

@PointClass base( Targetname, Parentname, CanBeClientOnly ) tags( Logic ) 
	selected_line( 255 255 255, targetname, Template01 )
	selected_line( 255 255 255, targetname, Template02 )
	selected_line( 255 255 255, targetname, Template03 )
	selected_line( 255 255 255, targetname, Template04 )
	selected_line( 255 255 255, targetname, Template05 )
	selected_line( 255 255 255, targetname, Template06 )
	selected_line( 255 255 255, targetname, Template07 )
	selected_line( 255 255 255, targetname, Template08 )
	selected_line( 255 255 255, targetname, Template09 )
	selected_line( 255 255 255, targetname, Template10 )
	selected_line( 255 255 255, targetname, Template11 )
	selected_line( 255 255 255, targetname, Template12 )
	selected_line( 255 255 255, targetname, Template13 )
	selected_line( 255 255 255, targetname, Template14 )
	selected_line( 255 255 255, targetname, Template15 )
	selected_line( 255 255 255, targetname, Template16 )
	selected_line( 255 255 255, targetname, Template17 )
	selected_line( 255 255 255, targetname, Template18 )
	selected_line( 255 255 255, targetname, Template19 )
	selected_line( 255 255 255, targetname, Template20 )
	selected_line( 255 255 255, targetname, Template21 )
	selected_line( 255 255 255, targetname, Template22 )
	selected_line( 255 255 255, targetname, Template23 )
	selected_line( 255 255 255, targetname, Template24 )
	selected_line( 255 255 255, targetname, Template25 )
	selected_line( 255 255 255, targetname, Template26 )
	selected_line( 255 255 255, targetname, Template27 )
	selected_line( 255 255 255, targetname, Template28 )
	selected_line( 255 255 255, targetname, Template29 )
	selected_line( 255 255 255, targetname, Template30 )
	selected_line( 255 255 255, targetname, Template31 )
	selected_line( 255 255 255, targetname, Template32 )
	selected_line( 255 255 255, targetname, Template33 )
	selected_line( 255 255 255, targetname, Template34 )
	selected_line( 255 255 255, targetname, Template35 )
	selected_line( 255 255 255, targetname, Template36 )
	selected_line( 255 255 255, targetname, Template37 )
	selected_line( 255 255 255, targetname, Template38 )
	selected_line( 255 255 255, targetname, Template39 )
	selected_line( 255 255 255, targetname, Template40 )
	selected_line( 255 255 255, targetname, Template41 )
	selected_line( 255 255 255, targetname, Template42 )
	selected_line( 255 255 255, targetname, Template43 )
	selected_line( 255 255 255, targetname, Template44 )
	selected_line( 255 255 255, targetname, Template45 )
	selected_line( 255 255 255, targetname, Template46 )
	selected_line( 255 255 255, targetname, Template47 )
	selected_line( 255 255 255, targetname, Template48 )
	selected_line( 255 255 255, targetname, Template49 )
	selected_line( 255 255 255, targetname, Template50 )
	selected_line( 255 255 255, targetname, Template51 )
	selected_line( 255 255 255, targetname, Template52 )
	selected_line( 255 255 255, targetname, Template53 )
	selected_line( 255 255 255, targetname, Template54 )
	selected_line( 255 255 255, targetname, Template55 )
	selected_line( 255 255 255, targetname, Template56 )
	selected_line( 255 255 255, targetname, Template57 )
	selected_line( 255 255 255, targetname, Template58 )
	selected_line( 255 255 255, targetname, Template59 )
	selected_line( 255 255 255, targetname, Template60 )
	selected_line( 255 255 255, targetname, Template61 )
	selected_line( 255 255 255, targetname, Template62 )
	selected_line( 255 255 255, targetname, Template63 )
	selected_line( 255 255 255, targetname, Template64 )
	iconsprite("editor/point_template.vmat")
	metadata
	{
		create_entity_template_lumps = 
		[
			{
				lumpMode = "PointTemplate"
				targetWorldKey = "worldName"
				targetLumpKey = "entityLumpName"
			}
		]
	}
= point_template : 
	"Turns an entity, or set of entities, into a single template that can be instanced anywhere, and multiple times. "+
	"If there are interdependencies (entity I/O, hierarchy, or other name references) between the entities "+
	"in the template, the entities in the template will have their names changed and the interdependencies will "+
	"be reconnected to the changes names. The name change format is as follows: '<original name>&0000', where the 0000 "+
	"will be replaced with the current global template instance, so wildcard searches for '<original name>*' will still find them.<br><br>"+
	"If you don't want the name fixup to happen because you're only spawning the template once, or you want inputs to "+
	"trigger all instances of the template, check the 'Preserve entity names' spawnflag.<br><br>"+
	"To spawn the template in other places, use an env_entity_maker."
[
	spawnflags(flags) =
	[
		1 : "Don't remove template entities" : 0
		2 : "Preserve entity names (Don't do name fixup)" : 1
	]

	asynchronous(boolean) : "Asynchronous Spawn" : 0 : "Allows you to asynchronously spawn the entities referred to by the point template, which will happen at some point later after all dependent resources are downlaoded from UGC servers + asynch streamed in. Asynch point templates have the benefit that they don't precache resources that we never spawn."

	timeoutInterval(float) : "Timeout Interval" : "0" : "The amount of seconds after which, if any client hasn't finished streaming the necessary assets, that client is disconnected and the template spawns anyways. Only used in asynchronous point_templates. 0 means use some reasonable default set in the code."

	entityFilterName(string) : "Entity Filter Name" : "" : "Name of an entity filter that can be run on the entities in the template to modify, add, or remove the entities. These filters can be defined in code or in script."

	spawnGroupType(choices) : "Spawn Group Type" : "INSERT_INTO_POINT_TEMPLATE_SPAWN_GROUP" =
	[
		"INSERT_INTO_POINT_TEMPLATE_SPAWN_GROUP" : "Spawn into point_template's spawn group"
		"INSERT_INTO_CURRENTLY_ACTIVE_SPAWN_GROUP" : "Spawn into the currently active spawn group"
		"INSERT_INTO_NEWLY_CREATED_SPAWN_GROUP" : "Spawn into a newly created spawn group"
	]

	clientOnlyEntityBehavior(choices) : "Client Only Entity Behavior" : "CREATE_FOR_CURRENTLY_CONNECTED_CLIENTS_ONLY" : "This controls the behavior of client only entities spawned by the point_template. Either you can create them only for clients that are currently connected at the point the point_template is spawned (good for transient things like explosions), or you can create them for clients who connect after the point_template is spawned. This behavior only affects point_templates that create their own spawn groups." =
	[
		"CREATE_FOR_CURRENTLY_CONNECTED_CLIENTS_ONLY" : "Only create for clients connected at the time at which point_template spawns its contents"
		"CREATE_FOR_CLIENTS_WHO_CONNECT_LATER" : "Create for clients who connect after the point_template spawns its contents"
	]

	Template01(target_destination) : "Template 1"
	Template02(target_destination) : "Template 2"
	Template03(target_destination) : "Template 3"
	Template04(target_destination) : "Template 4"
	Template05(target_destination) : "Template 5"
	Template06(target_destination) : "Template 6"
	Template07(target_destination) : "Template 7"
	Template08(target_destination) : "Template 8"
	Template09(target_destination) : "Template 9"
	Template10(target_destination) : "Template 10"
	Template11(target_destination) : "Template 11"
	Template12(target_destination) : "Template 12"
	Template13(target_destination) : "Template 13"
	Template14(target_destination) : "Template 14"
	Template15(target_destination) : "Template 15"
	Template16(target_destination) : "Template 16"
	Template17(target_destination) : "Template 17"
	Template18(target_destination) : "Template 18"
	Template19(target_destination) : "Template 19"
	Template20(target_destination) : "Template 20"
	Template21(target_destination) : "Template 21"
	Template22(target_destination) : "Template 22"
	Template23(target_destination) : "Template 23"
	Template24(target_destination) : "Template 24"
	Template25(target_destination) : "Template 25"
	Template26(target_destination) : "Template 26"
	Template27(target_destination) : "Template 27"
	Template28(target_destination) : "Template 28"
	Template29(target_destination) : "Template 29"
	Template30(target_destination) : "Template 30"
	Template31(target_destination) : "Template 31"
	Template32(target_destination) : "Template 32"
	Template33(target_destination) : "Template 33"
	Template34(target_destination) : "Template 34"
	Template35(target_destination) : "Template 35"
	Template36(target_destination) : "Template 36"
	Template37(target_destination) : "Template 37"
	Template38(target_destination) : "Template 38"
	Template39(target_destination) : "Template 39"
	Template40(target_destination) : "Template 40"
	Template41(target_destination) : "Template 41"
	Template42(target_destination) : "Template 42"
	Template43(target_destination) : "Template 43"
	Template44(target_destination) : "Template 44"
	Template45(target_destination) : "Template 45"
	Template46(target_destination) : "Template 46"
	Template47(target_destination) : "Template 47"
	Template48(target_destination) : "Template 48"
	Template49(target_destination) : "Template 49"
	Template50(target_destination) : "Template 50"
	Template51(target_destination) : "Template 51"
	Template52(target_destination) : "Template 52"
	Template53(target_destination) : "Template 53"
	Template54(target_destination) : "Template 54"
	Template55(target_destination) : "Template 55"
	Template56(target_destination) : "Template 56"
	Template57(target_destination) : "Template 57"
	Template58(target_destination) : "Template 58"
	Template59(target_destination) : "Template 59"
	Template60(target_destination) : "Template 60"
	Template61(target_destination) : "Template 61"
	Template62(target_destination) : "Template 62"
	Template63(target_destination) : "Template 63"
	Template64(target_destination) : "Template 64"

	// Inputs
	input ForceSpawn(api)
	input DeleteCreatedSpawnGroups(api)

	// Outputs
	output OnEntitySpawned(api)
]

@PointClass base(Targetname,Parentname) = env_entity_maker : 
	"Spawns the specified entity template at its origin. If set to auto-spawn, it will spawn the template whenever there's room and the player "+
	"is looking elsewhere." 
[
	spawnflags(Flags) =
	[
		1 : "Enable AutoSpawn (will spawn whenever there's room)" : 0
		2 : "AutoSpawn: Wait for entity destruction" : 0
		4 : "AutoSpawn: Even if the player is looking" : 0
		8 : "ForceSpawn: Only if there's room" : 0
		16 : "ForceSpawn: Only if the player isn't looking" : 0
	]

	EntityTemplate(target_destination) : "Point_template To Spawn" : "" : "Name of the point_template to spawn here. If there is an offset between the point_template and its spawned entities in hammer, that offset will be maintained when spawning happens relative to the env_entity_maker."

	PostSpawnSpeed(float) : "PostSpawn Movement Speed" : "0" : "If specified, all the entities created in the template will move this fast in the specified PostSpawn Movement Direction."
	PostSpawnDirection(angle) : "PostSpawn Movement Direction" : "0 0 0" : "If a PostSpawn Movement Speed is specified, this angle will be added to the movement direction all the entities created by the template."
	PostSpawnDirectionVariance(float) : "PostSpawn Direction Variance" : "0.15" : "This variance is applied to the PostSpawn Movement Direction for each spawned entity in the template. Use it to apply some randomness to the directions."
	PostSpawnInheritAngles(boolean) : "PostSpawn Inherit Angles" : 0 : "If checked, uses the parent's forward vector as the spawn direction. Otherwise uses the entity maker's forward."

	// Inputs
	input ForceSpawn(void)				: "Spawn an instance of the template at this origin and angle."
	input ForceSpawnAtEntityOrigin(target_destination) : "Spawn an instance of the template that the same origin and angle as the specified entity (specify by targetname in parameters)"

	// Outputs
	output OnEntitySpawned(void) : "Fired when an instance of the entity template has been spawned."
	output OnEntityFailedSpawn(void) : "Fired when a ForceSpawn input failed to spawn the template, either due to lack of space or being in player's view, depending on the spawnflags."
]


//-------------------------------------------------------------------------
//
// Activator Filters
//
//-------------------------------------------------------------------------

@BaseClass base(Targetname, CanBeClientOnly) = BaseFilter
[
	Negated(choices) : "Filter mode" : 0 : "If set to Allow, only entities who match the criteria will pass the filter. "+
		"If set to Disallow, only entities who do NOT match the criteria will pass the filter." =
	[
		0 : "Allow entities that match criteria"
		1 : "Disallow entities that match criteria"
	]

	// Inputs
	input TestActivator(void) : "Test the activator against the filter and fires OnPass or OnFail output."

	// Outputs
	output OnPass(void) : "Fired in response to TestActivator input if the activator passes the filter."
	output OnFail(void) : "Fired in response to TestActivator input if the activator fails to pass the filter."
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_multiple.vmat") = filter_multi :
	"A filter that tests the activator against multiple filters. This allows you to build more complex filters, such as"+
	"'Allow anyone on Team 1 who is also class engineer', or 'Allow everyone except classes npc_zombie and npc_headcrab'."
[
	filtertype(choices) : "Logic Type" : 0 =
	[
		0 : "AND (all filters must pass)"
		1 : "OR (any filter must pass)"
	]

	Negated(choices) : "Negate Outcome" : 0 : "Whether to negate the result of the subfilters, after combining them using the Logic Type chosen.<br>"+
		"Negating the outcome using the AND logic type means that any subfilter must fail for this filter to pass.<br>"+
		"Negating the outcome using the OR logic type means that all subfilters must fail for this filter to pass." =
	[
		0 : "No"
		1 : "Yes"
	]

	Filter01(filterclass) : "Filter 1" : : "Activator filter to test."
	Filter02(filterclass) : "Filter 2" : : "Activator filter to test."
	Filter03(filterclass) : "Filter 3" : : "Activator filter to test."
	Filter04(filterclass) : "Filter 4" : : "Activator filter to test."
	Filter05(filterclass) : "Filter 5" : : "Activator filter to test."
	Filter06(filterclass) : "Filter 6" : : "Activator filter to test."
	Filter07(filterclass) : "Filter 7" : : "Activator filter to test."
	Filter08(filterclass) : "Filter 8" : : "Activator filter to test."
	Filter09(filterclass) : "Filter 9" : : "Activator filter to test."
	Filter10(filterclass) : "Filter 10" : : "Activator filter to test."

	input AddFilter(api)
	input RemoveFilter(api)
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_name.vmat") = filter_activator_name :
	"A filter that filters by the name of the activator."
[
	filtername(target_destination) : "Filter Name" : : "The name to filter by. If the filter mode is Allow, only entities whose "+
		"name matches the given string will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose name matches the string will pass the filter."
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_model.vmat") = filter_activator_model :
	"A filter that filters by the model of the activator."
[
	model(studio) : "Filter Model" : : "The model to filter by. If the filter mode is Allow, only entities whose "+
		"model matches the given string will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose model matches the string will pass the filter."
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_name.vmat") = filter_activator_context :
	"A filter that filters by a context on the activator."
[
	ResponseContext(string) : "Filter Context" : : "The context to filter by. If the filter mode is Allow, only entities that "+
		"have a context matching the given string, of any value, will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose context matches the string will pass the filter."
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_class.vmat") = filter_activator_class :
	"A filter that filters by the class name of the activator."
[
	filterclass(string) : "Filter Classname" : : "The class name to filter by. If the filter mode is Allow, only entities whose "+
		"class name matches the given string will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose class name matches the given string will pass the filter."
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_class.vmat") = filter_activator_mass_greater :
	"A filter that filters by the mass of the activator."
[
	filtermass(float) : "Filter Mass" : : "The mass to filter by. If the filter mode is Allow, only entities whose "+
		"mass is greater than the give float will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose mass is greater than the given float will pass the filter."
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_type.vmat") = filter_damage_type :
	"A damage filter that filters by the type of damage inflicted. This can only be used as a damage filter, not as an activator filter."
[
	damagetype(choices) : "Damage type" : 64 : "The damage type to filter by. If the filter mode is Allow, only damage types that "+
		"match will pass the filter. If the filter mode is Disallow, all damage types EXCEPT those who match will pass the filter." =
	[
		0 : "GENERIC"
		1 : "CRUSH"
		2 : "BULLET"
		4 : "SLASH"
		8 : "BURN"
		16 : "VEHICLE"
		32 : "FALL"
		64 : "BLAST"
		128 : "CLUB"
		256 : "SHOCK"
		512 : "SONIC"
		1024 : "ENERGYBEAM"
		16384: "DROWN"
		32768 : "PARALYSE"
		65536 : "NERVEGAS"
		131072 : "POISON"
		262144 : "RADIATION"
		524288 : "DROWNRECOVER"
		1048576 : "ACID"
		2097152 : "SLOWBURN"
	]
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_class.vmat") = filter_activator_attribute_int :
	"A filter that filters by the mass of the activator."
[
	filterattribute(string) : "Attribute Name" : : "The attribute to filter by. If the filter mode is Allow, only entities who "+
		"have the attribute with a value > 0 will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those who have the attribute with a value > 0 will pass the filter."
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_class.vmat") sphere(filter_radius) sphere(filter_outer_radius) = filter_enemy :
	"A filter that filters a potential enemy entity by a set of criteria."
[
	filtername(string) : "Name/Classname" : : "The classname or entity name to filter by. If the filter mode is Allow, only entities whose "+
		"class name matches the given string will pass the filter. If the filter mode is Disallow, "+
		"all entities EXCEPT those whose class name matches the given string will pass the filter."
		
	filter_radius(float) : "Radius" : 0 : "Radius by which to test the proximity of the enemy.  If the filter mode is Allow, only entities whose "+
		"distance is equal to or closer than the radius will pass the filter. If the filter mode is Disallow, "+
		"all entities outside the radius will pass the filter."

	filter_outer_radius(float) : "Outer Radius" : 0 : "Enemies outside this radius are considered invalid if Allow is set and valid if Disallow is set."
	
	filter_max_per_enemy(integer) : "Max Squadmates Per Enemy" : 0 : "Maximum number of squadmates allowed to target any given entity."
	
	spawnflags(Flags) =
	[
		1 : "Do not lose target if already aquired but filter failed." : 0
	]
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_class.vmat") sphere(filter_radius) = filter_proximity : "A filter that filters a potential entity by proximity from the origin of the filter."
[
	filter_radius(float) : "Radius" : 0 : "Radius by which to test the proximity."
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_class.vmat") = filter_los : "A filter that filters a potential entity by line of sight from the origin of the filter."
[
]

@FilterClass base(BaseFilter) iconsprite("editor/filter_class.vmat") = filter_modifier : "A filter that filters entities by active modifiers applied to them"
[
	filtermodifier(string) : "Modifier Name" : : "The name of the modifier to filter entities by"
]

//-------------------------------------------------------------------------
//
// Point Entities
//
//-------------------------------------------------------------------------

@PointClass base(Targetname, Parentname, EnableDisable) = point_anglesensor :
	"An entity that detects if another entity points in a given direction for a period of time."
[
	target(target_destination) : "Target Entity Name" : : "Name of the entity whose angles will be sensed."
	lookatname(target_destination) : "Look At Entity" : : "The entity we want to check to see if the Target Entity is looking at."
	duration(float) : "Duration" : : "The amount of time the Target Entity must look at the 'Look at Entity' to trigger this entity, in seconds."
	tolerance(integer) : "Tolerance" : : "The tolerance, in degrees, in the checking to determine when the Target Entity is looking at the Look At Entity."

	spawnflags(Flags) =
	[
		1 : "Use target entity's angles (NOT position)" : 0
	]
	
	// Inputs
	input Toggle(void) : "Toggle the sensor between enabled and disabled."
	input Test(void) : "Check to see if the Target Entity is facing the Look At Entity within the specified tolerance, firing either the OnFacingLookat or OnNotFacingLookat output based on the result."
	
	// Outputs
	output TargetDir(vector) : "Fired when the forward direction of the Target Entity changes. Passes the new forward direction as a parameter."
	output OnFacingLookat(void) : "Fired when the Target Entity points at the Look At Entity for more than the specified Duration, or in response to a Test input."
	output OnNotFacingLookat(void) : "Fires in response to a Test input when the Target Entity is not pointing at the Look At Entity."
	output FacingPercentage(float) : "Normalized value (0..1) where 1 is facing directly at target and 0 is at or beyond the angle of tolerance."
]

@PointClass base(Targetname) = point_angularvelocitysensor :
	"An entity that detects if another entity's angular velocity meets or exceeds a threshold value."
[
	target(target_destination) : "Target Entity Name" : : "Name of the entity whose angular velocity will be sensed."
	threshold(float) : "Threshold Velocity" : 0 : "The threshold angular velocity to compare against, in degrees per second."
	fireinterval(float) : "Fire Interval" : "0.2" : "Angular velocity must cross the threshold for at least this long to fire."

	axis(vecline) : "Axis"

	usehelper(boolean) : "Use Axis Helper" : 0 : "Use axis helper to determine rotation values (clockwise/counter-clockwise)."

	// Inputs
	input Test(void) : "Checks to see if the Target Entity's angular velocity meets or exceeds the Threshold Velocity, " +
		"firing either the OnGreaterThanOrEqualTo or OnLessThan output based on the result."

	input TestWithInterval(void) : "Checks to see if the Target Entity's angular velocity meets or exceeds the Threshold Velocity. Once the Fire Interval expires, " +
		"fires the appropriate test result output if the result is stable throughout the Fire Interval."
	
	// Outputs
	output AngularVelocity(float) : "Fired when the Target's Angular Velocity changes, passing the new magnitude of the angular velocity."
	output OnGreaterThan(void) : "Fired when the Target Entity goes from slower than the threshold angular velocity to faster than the threshold angular velocity."
	output OnGreaterThanOrEqualTo(void) : "Fired when the Target Entity goes from slower than the threshold angular velocity to faster than the threshold angular velocity."
	output OnLessThan(void) : "Fired when the Target Entity goes from faster than the threshold angular velocity to slower than the threshold angular velocity."
	output OnLessThanOrEqualTo(void) : "Fired when the Target Entity goes from faster than the threshold angular velocity to slower than the threshold angular velocity."
	output OnEqualTo(void) : "Fired when the Target Entity reaches the threshold angular velocity from a different velocity."
]

@PointClass base(Targetname) = point_velocitysensor :
	"An entity that detects and outputs an entity's velocity."
[
	target(target_destination) : "Target Entity Name" : : "Name of the entity whose velocity will be sensed."
	axis(vecline) : "Measurement Axis"
	enabled(boolean) : "Start Enabled" : 1 : "Whether or not to start enabled and active."
	avginterval(float) : "Averaging interval" : 0 : "Amount of time in seconds over which to average the measured velocity, 0=instantaneous."

	// Outputs
	output Velocity(float) : "Fired when the Target's Velocity changes, passing the new magnitude of the velocity."

	input Enable(void) : "Enable the sensor."
	input Disable(void) : "Disable the sensor."
]

@PointClass base(Targetname, Parentname, EnableDisable) = point_proximity_sensor :
	"An entity that detects another entity's proximity to a target position."
[
	target(target_destination) : "Target Entity Name" : : "Name of the entity whose angles will be sensed."

	spawnflags(Flags) =
	[
		1 : "Test the distance as measured along the axis specified by our direction." : 0
	]
	
	// Inputs
	input Toggle(void) : "Toggle the sensor between enabled and disabled."
	
	// Outputs
	output Distance(float) : "Distance of the target entity away from this entity."
]


@PointClass base(Targetname, Parentname) editormodel("models/editor/axis_helper_thick.vmdl") = point_teleport : 
	"An entity that teleports a target entity to this position and angles. "+
	"If 'Teleport Home' spawn flag is set, teleports the target entity to its spawn position instead." +
	"If object is physically simulated, simulation is turned off when teleported."
[
	target(target_destination) : "Entity To Teleport" : : "Name of the entity that will be teleported."
	spawnflags(flags) =
	[
		1 : "Teleport Home" : 0
		2 : "Into Duck (episodic)" : 0
		4 : "Change View Direction (VR)" : 0
	]
	teleport_parented_entities(boolean) : "Teleport Parented Ents" : "0"
	teleport_use_current_angle(boolean) : "Teleport Uses Current Rotation" : "0"

	// Inputs
	input Teleport(api)
	input TeleportToCurrentPos(api)

	input TeleportEntity(api)
	input TeleportEntityToCurrentPos(api)

]

@PointClass base(Targetname) sphere(DamageRadius) = point_hurt :
	"An entity that does damage to all entities in a radius around itself, with a specified delay." +
	"If 'Target Entity' is specified, the damage is only done to that entity."
[
	DamageTarget(target_destination) : "Target Entity" : "" : "If specified, only this entity will take damage. Otherwise, all entities within the Radius will take damage."
	
	DamageRadius(float) : "Radius" : 256 : "All entities within this radius of this entity will take damage. If a 'Target Entity' is specified, only that entity will take damage."
	Damage(integer) : "Damage" : 5 : "Damage done to all affected entities each time this entity fires."
	DamageDelay(float) : "Delay" : 1 : "Delay between refires, in seconds."
	
	DamageType(choices) : "Damage Type" : 0 : "Type of damage to inflict on entities damaged." =
	[
		0 : "GENERIC"
		1 : "CRUSH"
		2 : "BULLET"
		4 : "SLASH"
		8 : "BURN"
		16 : "FREEZE"
		32 : "FALL"
		64 : "BLAST"
		128 : "CLUB"
		256 : "SHOCK"
		512 : "SONIC"
		1024 : "ENERGYBEAM"
		16384: "DROWN"
		32768 : "PARALYSE"
		65536 : "NERVEGAS"
		131072 : "POISON"
		262144 : "RADIATION"
		524288 : "DROWNRECOVER"
		1048576 : "CHEMICAL"
		2097152 : "SLOWBURN"
		4194304 : "SLOWFREEZE"
	]

	// Inputs
	input Hurt(void) : "Force a single fire, damaging either the Target Entity or all entities within the radius."
	input TurnOn(void) : "Enable this entity. It will start damaging entities everytime it fires, and refire based upon the specified Delay."
	input TurnOff(void) : "Disable this entity. It will stop damaging entities."
	input Toggle(void) : "Toggle this entity between On/Off state."
]

//-------------------------------------------------------------------------
//
//	Physics entities
//
//-------------------------------------------------------------------------


// Inherit from this class if the entity is simulated in game and should 
// particpate in the pre-settle simulation during map compile.
@BaseClass = BasePhysicsSimulated
[
	skipPreSettle(boolean)  [ group="Physics Properties" ] : "Skip pre-settle" : "0" : "If set this entity will not particpate in the physics pre-settle during compile, but will start awake in game."
]

// All physics classes that have one or more attched target entities should derive from this
// Attached entities will be excluded from the physics pre-settle.
@BaseClass = BasePhysicsNoSettleAttached
[
]


@SolidClass base(BreakableBrush,Targetname, RenderFields, Shadow, BasePhysicsSimulated) = func_physbox : 
	"A brush entity that's physically simulated."
[
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	spawnflags(flags) =
	[
		16384 : "Debris - Don't collide with the player or other debris" : 0
		32768 : "Motion Disabled" : 0
		1048576 : "Start Asleep" : 0
		8388608 : "Prevent motion enable on player bump" : 0
		16777216: "Force nav-ignore" : 0
	]

	add_modifier(string) : "Add Modifier" : "" : "Will add this modifier when the entity spawns."
	
	Damagetype(choices) : "Impact Damage Type" : 0 =
	[
		-1: "Disabled"
		0: "Blunt"
		1: "Sharp"
	]
	
	gamemass(integer) [ group = "Physics Properties" ] : "Mass Override" : 0 : "Override the mass of the object instead of calculating it based on the size / shape and material."
	massScale(float) [ group = "Physics Properties" ] : "Mass Scale" : "0" : "A scale multiplier for the object's mass. 0 = use auto-calculated mass based on the object's size / shape and material"
	masscenteroffset(vector) [ group = "Physics Properties" ] : "Center of Mass Offset" : "0 0 0" : "Offset in local space applied to the object's center of mass."
	buoyancyscale(float) [ group = "Physics Properties" ] : "Buoyancy Scale" : "1" : "Scale on the buoyancy forces applied to this object (not including fluid drag)"
	fluiddragscale(float) [ group = "Physics Properties" ] : "Fluid Drag Scale" : "1" : "Scale on fluid forces applied to this object (not including buoyancy)"
	
	damagetoenablemotion(integer) : "Health Level to Override Motion" : 0 : "If specified, this object will start motion disabled. Once its health has dropped below this specified amount, it will enable motion."
	forcetoenablemotion(float) : "Physics Impact Force to Override Motion" : 0 : "If specified, this object will start motion disabled. Any impact that imparts a force greater than this value on the physbox will enable motion."
	enableuseoutput(boolean) : "Enable +Use Output" : 0 : "Enables OnPlayerUse output being fired when this object is used"
	health(integer) : "Strength" : 0 : "Number of points of damage to take before breaking.  0 means don't break."
	hoverposeflags(flags) =
	[
		1: "Position" : 0
		2: "Angles" : 0
	]
	hoverposeposition(vector) : "Player-carry Hover Position" : "0 0 0" : "If the hoverposeflags Position flag is set, this position is the position which the object should move when the player picks it up, with the physgun or +USE."
	hoverposeangles(vector) : "Player-carry Hover Angles" : "0 0 0" : "If the hoverposeflags Angles flag is set, this angle is the angle which the object should orient to when the player picks it up, with the physgun or +USE."
	notsolid(choices) : "Not solid to world" : 0 =
	[
		0: "Solid to World"
		1: "Passes through World"
	]
	
	touchoutputperentitydelay(float) : "Start Touch Per Entity Refire Delay" : 0 : "When set to 0 OnStartTouch events are never sent. Otherwise it's a delay in seconds before another OnStartTouch is sent for the same entity."

	// Inputs
	input Wake(void) : "Wake up this physics object, if it is sleeping."
	input Sleep(void) : "Put this physics object to sleep. It will wake if given the Wake input, or if force is applied to it. Note that physics objects go to sleep automatically after coming to rest for a while, so you don't really need to use this."
	input EnableMotion(void) : "Enable physics motion/collision response."
	input DisableMotion(void) : "Disable physics motion/collision response."
	input ForceDrop(void) : "If this object is being carried by a player, with the physgun or +USE, force it to be dropped."
	
	// Outputs
	output OnDamaged(void) : "Fired when this entity is damaged."
	output OnAwakened(void) : "Fired when this entity becomes awake (collision/force is applied)."
	output OnMotionEnabled(void) : "Fired when motion is enabled due to damage/physcannon/force."
	output OnPlayerUse(void) : "Fired when the player tries to +USE the physbox. This output will fire only if the Generate output on +USE spawnflag is set."
	output OnStartTouch(void) : "Fired when it touches with another entity. Activator is the other entity."
]

@BaseClass base(Targetname, BasePhysicsNoSettleAttached) = TwoObjectPhysics
[
	spawnflags(flags) =
	[
		1: "No Collision until break" : 0
		// 2 is defined independently by subclasses, do not reuse
		4: "Start inactive" : 0
		16: "Do not connect entities until turned on" : 0
	]
	attach1(target_destination) : "Entity 1" : ""
	attach2(target_destination) : "Entity 2" : ""
	attachment1(string) : "Entity 1 Attachment Name" : "" : "If set, we'll attach to the body / location corresponding to this attachment."
	attachment2(string) : "Entity 2 Attachment Name" : "" : "If set, we'll attach to the body / location corresponding to this attachment."

	forcelimit(float) : "Impulse Limit to Break (kg)" : "0" : "The amount of impulse an impact must apply to the constraint to break it. A way of calculating this is to set it to the mass of an object that would break this constraint if it were resting on the constrainted objects."
	torquelimit(float) : "Angular Impulse Limit to Break (kg * distance)" : "0" : "The amount of angular impulse required to break the constraint. A way of calculating this is to multiply any reference mass by the resting distance (from the center of mass of the object) needed to break the constraint."
	breaksound(sound) : "Play Sound on Break" : "" : "A sound played when the constraint is broken."
	teleportfollowdistance(float) : "Follow teleport distance" : "0" : "If one object teleports more than this many units away it will cause the other constrained object to teleport to an appropriate relative position."
	treat_entity1_as_infinite_mass(bool) : "Treat Entity 1 As Infinite Mass" : "0" : "If true, the joint will not affect the motion of Entity 1. Entity 2 will just follow Entity 1."

	// Inputs
	input Break(void) : "Force the constraint to break."
	input TurnOn(void) : "Enable the constraint.  Do this when the objects don't exist when the constraint spawns - or when you have deactivated the constraint.  Broken constraints can NOT be turned on.  They have been deleted."
	input TurnOff(void) : "Disable this constraint." 

	// Outputs
	output OnBreak(void) : "Fired when the constraint breaks."
]
	
@PointClass base(Targetname) tags( Physics ) = phys_keepupright : "A controller that tries to keep an entity facing a particular direction."
[
	spawnflags(flags) =
	[
		1: "Start inactive" : 0
	]

	attach1(target_destination) : "Target Entity" : "" : "The entity to align to the desired angles."
	angularlimit(float) : "Angular Limit" : "15" : "The maximum angular velocity that this controller can compensate for, in degrees per second."
	dampAllRotation(boolean) : "Damp all rotation" : "" : "Forces the upright behavior to have perfect damping, instead of progressively damping."
	// Inputs
	input TurnOn(void) : "Enable the controller."
	input TurnOff(void) : "Disable the controller." 
]

@PointClass base(Targetname, Parentname) tags( Physics ) size(-4 -4 -4, 4 4 4) = info_constraint_anchor : 
	"An entity used to attach constraints to a local position on an entity. Usually constraints will attach to the center of mass of an object. "+
	"Attach the desired constraint to this entity, and then parent this entity to the entity you want the constraint to apply to."
[
	massScale(float) : "Amount to scale the mass of this body in the constraint solver" : "1"
]

@PointClass halfgridsnap  editormodel("models/editor/axis_helper") base(Targetname, BasePhysicsNoSettleAttached) tags( Physics ) = phys_spring : 
	"A physically simulated spring. "+
	"'Length' is what's known as the 'natural spring length'. This is how long the spring would "+
	"be if it was at rest (nothing hanging on it or attached). When you attach something to the "+
	"spring, it will stretch longer than its 'natural length'. The amount of stretch is "+
	"determined by the 'Sprint Frequency'. The larger the spring frequency the less stretch the spring."
[
	spawnflags(flags) =
	[
		1 : "Force only on stretch" : 0
		2 : "Enable collision" : 0
	]
	
	attach1(target_destination) : "Entity 1" : ""
	attach2(target_destination) : "Entity 2" : ""

	springaxis(vecline) : "Spring Axis" : "" : "Use the helper. Drag it out to match the virtual spring."
	length(string) : "Length" : "0" : "How long the spring would be if it was at rest (nothing hanging on it or attached). 0 means the length of the helper."
	lengthscale(float) : "Length Scale" : "1" : "Scale on the rest length. You can use this to easily make the spring start out stretched. e.g. a value of 0.75 here means the spring will spawn stretched by ~25%."
	frequency(string) : "Frequency" : "5" : "The stiffness of the spring.  The larger the number the less the spring will stretch. The maximum should be not more than 30!"
	damping(string) : "Damping Ratio" : "0.7" : "How much energy the spring loses. Values less than one give you an osscilating spring. A value of one makes the spring return without overshooting"
	//breaklength(string) : "Break on Length" : "0" : "If the spring's length ever exceeds this length, the spring breaks."

	// Inputs
	input SetRestLength(float) : "Set the spring rest length."
	input AddRestLength(float) : "Increase the spring rest length by the given amount."
	input RemoveRestLength(float) : "Decrease the spring rest length by the given amount."
	input SetFrequency(float) : "Set the spring frequency (stiffness)."
	input SetDampingRatio(float) : "Set the spring damping ratio."
]


//--------------------------------------------------------------------------------------------------
//
// Physics constraints
//
//--------------------------------------------------------------------------------------------------
@BaseClass = ConstraintSoundInfo
[
	minSoundThreshold(float) : "Minimum Sound Velocity" : "6" : "When travelling below this many units/sec, will not play any sound."
	maxSoundThreshold(float) : "Full Sound Velocity" : "80" : "When travelling at this speed or above, will play sound at full volume."
	slidesoundfwd(sound) : "Travel sound (forward)" : "" : "Play this sound when travelling forward on helper axis"
	slidesoundback(sound) : "Travel sound (backward)" : "" : "Play this sound when travelling backward on helper axis"
	
	reversalsoundthresholdSmall(float) : "Reversal sound threshold (small)" : "0" : "When accelerating by more than this many units/sec^2 opposite to direction of travel, play the small reversal sound." 
	reversalsoundthresholdMedium(float) : "Reversal sound threshold (medium)" : "0" : "When accelerating by more than this many units/sec^2 opposite to direction of travel, play the medium reversal sound."
	reversalsoundthresholdLarge(float) : "Reversal sound threshold (large)" : "0" : "When accelerating by more than this many units/sec^2 opposite to direction of travel, play the large reversal sound."
	
	reversalsoundSmall(sound) : "Reversal sound (small)" : "" : "Play this sound when making a hard reverse over the small threshold but less than medium"
	reversalsoundMedium(sound) : "Reversal sound (medium)" : "" : "Play this sound when making a hard reverse over the medium threshold but less than large"
	reversalsoundLarge(sound) : "Reversal sound (large)" : "" : "Play this sound when making a hard reverse over the large threshold"
]

@PointClass halfgridsnap editormodel("models/editor/axis_helper") arc_range{ axis_key = "hingeaxis" is_local_axis = false min_angle_key = "min_rotation" max_angle_key = "max_rotation" } base(TwoObjectPhysics, ConstraintSoundInfo) tags( Physics ) = phys_hinge : 
	"A physically simulated hinge. Use the helper to define the axis of rotation."
[
	hingefriction(float) : "Friction" : "0" : "Resistance/friction in the hinge. A value of 1 will hold the child object still under gravity"
	min_rotation(float) [ min="-180.0", max="0.0" ]: "Min Rotation Limit" : "0" : "Minimum rotation limit around hinge axis"
	max_rotation(float) [ min="0.0", max="180.0" ]: "Max Rotation Limit" : "0" : "Maximum rotation limit around hinge axis"
	initial_rotation(float) : "Initial rotation" : "0" : "Initial rotation of the hinge (values -1 to 1 where -1 mean open at minimum limit and 1 means open at maximum limit)"
	hingeaxis(vecline) : "Hinge Axis"
	motorfrequency(float) : "Motor frequency" : "10" : "Range 0 - 30 (only used when driving the relative angle through the angle input)"
	motordampingratio(float) : "Motor damping ratio" : "1" : "Range 0 - 1 (only used when driving the relative angle through the angle input)"
	SystemLoadScale(float) : "Load Scale" : "1" : "Scale of the load connected to this hinge (1=just the objects directly connected)"
	AngleSpeedThreshold(float) : "Threshold for move events"
	
	// Inputs
	input SetAngularVelocity(float) : "Set angular velocity around the hinge (motor) in deg/sec"
	input SetHingeFriction(float) : "Set Motor Friction, 0 = no friction, 1 = friction that is about enough to counter gravity"
	input SetMinLimit(float) : "Set the minimum hinge angle (degrees)"
	input SetMaxLimit(float) : "Set the maximum hinge angle (degrees)"
	//input TurnMotorOn(void) : "Turn Motor On, use 0 target velocity to turn on the friction"
	input TurnMotorOff(void) : "Turn Motor Off, will turn all friction off"
	//input SetMotorTorqueFactor(float) : "Set Motor torque factor, dimentionless, alternative to setting torque directly in Newton*meters, 1.0 = resist gravity"
	input SetMotorTargetVelocity(float) : "Set Motor target velocity in deg/sec, use 0 to just turn friction on"
	input SetMotorTargetAngle(float) : "Set Motor target angle, degrees. Exact number depends on constrained bodies reference frames and initial configuration. See constraint limits for reference to sensible range of values."
	//input TurnMotorTargetAngleOn(void) : "Set Motor to Angle mode. When on, motor will attempt to drive to the given target angle with given target velocity, and stop there"
	//input TurnMotorTargetAngleOff(void) : "Set Motor to Velocity mode. When on, motor will attempt to drive at the given velocity/direction, regardless of the current angle of the motor"
	
	// Outputs
	output NotifyMinLimitReached(void) : "The min limit has been reached."
	output NotifyMaxLimitReached(void) : "The max limit has been reached."

	output OnStartMoving(void) : "Fires if the attached objects start rotating around the hinge axis relatively to each other."
	output OnStopMoving(void) : "Fires if the attached objects stip rotating around the hinge axis relatively to each other."
]


@PointClass halfgridsnap editormodel("models/editor/axis_helper") arc_range{ axis_key = "hingeaxis" is_local_axis = true min_angle_key = "min_rotation" max_angle_key = "max_rotation" } base(TwoObjectPhysics, ConstraintSoundInfo) tags( Physics ) = phys_hinge_local : 
	"A physically simulated hinge. Use the helper to define the axis of rotation."
[
	hingefriction(float) : "Friction" : "0" : "Resistance/friction in the hinge"
	min_rotation(float) [ min="-180.0", max="0.0" ]:  "Min Rotation Limit" : "0" : "Minimum rotation limit around hinge axis"
	max_rotation(float) [ min="0.0", max="180.0" ] : "Max Rotation Limit" : "0" : "Maximum rotation limit around hinge axis"
	initial_rotation(float) : "Initial rotation" : "0" : "Initial rotation of the hinge (values -1 to 1 where -1 mean open at minimum limit and 1 means open at maximum limit)"
	hingeaxis(localaxis) : "Local Space Hinge Axis" : "-8 0 0, 8 0 0"
	motorfrequency(float) : "Motor frequency" : "10" : "Range 0 - 30 (only used when driving the relative angle through the angle input)"
	motordampingratio(float) : "Motor damping ratio" : "1" : "Range 0 - 1 (only used when driving the relative angle through the angle input)"
	SystemLoadScale(float) : "Load Scale" : "1" : "Scale of the load connected to this hinge (1=just the objects directly connected)"
	AngleSpeedThreshold(float) : "Threshold for move events"
	
	// Inputs
	input SetAngularVelocity(float) : "Set angular velocity around the hinge (motor) in deg/sec"
	input SetHingeFriction(float) : "Set Motor Friction, 0 = no friction, 1 = friction that is about enough to counter gravity"
	input SetMinLimit(float) : "Set the minimum hinge angle (degrees)"
	input SetMaxLimit(float) : "Set the maximum hinge angle (degrees)"
	//input TurnMotorOn(void) : "Turn Motor On, use 0 target velocity to turn on the friction"
	input TurnMotorOff(void) : "Turn Motor Off, will turn all friction off"
	//input SetMotorTorqueFactor(float) : "Set Motor torque factor, dimentionless, alternative to setting torque directly in Newton*meters, 1.0 = resist gravity"
	input SetMotorTargetVelocity(float) : "Set Motor target velocity in deg/sec, use 0 to just turn friction on"
	input SetMotorTargetAngle(float) : "Set Motor target angle, degrees. Exact number depends on constrained bodies reference frames and initial configuration. See constraint limits for reference to sensible range of values."
	//input TurnMotorTargetAngleOn(void) : "Set Motor to Angle mode. When on, motor will attempt to drive to the given target angle with given target velocity, and stop there"
	//input TurnMotorTargetAngleOff(void) : "Set Motor to Velocity mode. When on, motor will attempt to drive at the given velocity/direction, regardless of the current angle of the motor"
		
	// Outputs
	output NotifyMinLimitReached(void) : "The min limit has been reached."
	output NotifyMaxLimitReached(void) : "The max limit has been reached."

	output OnStartMoving(void) : "Fires if the attached objects start rotating around the hinge axis relatively to each other."
	output OnStopMoving(void) : "Fires if the attached objects stip rotating around the hinge axis relatively to each other."
]


@PointClass editormodel("models/editor/axis_helper") base(TwoObjectPhysics) iconsprite("editor/phys_ballsocket.vmat") tags( Physics ) = phys_ballsocket : 
	"A constraint that keeps the position of two objects fixed, relative to the constraint's origin. You can optionally specify limits for the relative twist and swing rotation."
[
	spawnflags(flags) =
	[
	]

	friction(float) : "Friction" : "0" : "Resistance/friction in the constraint"

	enable_swing_limit(boolean) : "Enable Swing Limit" : 0 : "Limit relative rotation away from the constraint's Z axis"
	swing_limit(float) : "Swing Limit" : "0" : "Maximum swing angle in degrees, if the swing limit is enabled"

	enable_twist_limit(boolean) : "Enable Twist Limit" : 0 : "Limit relative rotation about the Z axis"
	min_twist_angle(float) : "Min Twist Angle" : "0" : "Minimum relative twist angle in degrees, if the twist limit is enabled"
	max_twist_angle(float) : "Max Twist Angle" : "0" : "Maximum relative twist angle in degrees, if the twist limit is enabled"
]


@PointClass base(TwoObjectPhysics) editormodel("models/editor/axis_helper_thick") tags( Physics ) = phys_constraint :
	"Constrain an entity to the world or another entity at a fixed relative position."
[
	bonename1(string) : "Entity 1 Bone Name" : "" : "If set, search for a physics body that corresponds with the given bone."
	bonename2(string) : "Entity 2 Bone Name" : "" : "If set, search for a physics body that corresponds with the given bone."
	linearfrequency(float) : "Linear Frequency" : "0" : "Linear spring frequency (stiffness)."
	lineardampingratio(float) : "Linear Damping Ratio" : "0" : "Linear spring damping ratio."
	angularfrequency(float) : "Angular Frequency" : "0" : "Angular spring frequency (stiffness)."
	angulardampingratio(float) : "Angular Damping Ratio" : "0" : "Angular spring damping ratio."
	enablelinearconstraint(boolean) : "Enable Linear Constraint" : 1
	enableangularconstraint(boolean) : "Enable Angular Constraint" : 1
]


@PointClass base(TwoObjectPhysics) editormodel("models/editor/axis_helper.vmdl") tags( Physics ) = phys_pulleyconstraint : 
	"A constraint that is essentially two length constraints and two points. Imagine it as a virtual rope connected to two objects, each suspended from a pulley above them."+
	"The constraint keeps the sum of the distances between the pulley points and their suspended objects constant."
[
	addlength(float) : "Additional Length" : "0" : "Add (or subtract) this amount to the rest length of the pulley rope."
	gearratio(float) : "Pulley Gear Ratio" : "1" : "Add (or subtract) this amount to the rest length of the pulley rope."
	position2(vecline) : "Pulley Position 2" : : "The position of the pulley for Entity 2. The pulley for Entity 1 is the origin of this constraint entity. Entity 1 is always suspended from pulley point 1, and Entity 2 is always suspended from pulley point 2."
	spawnflags(flags) =
	[
		1: "No Collision until break" : 1
		2: "Keep Rigid" : 0
	]
]

@PointClass halfgridsnap base(TwoObjectPhysics, ConstraintSoundInfo) editormodel("models/editor/axis_helper.vmdl") tags( Physics ) = phys_slideconstraint : 
	"A constraint that constrains an entity along a line segment."
[
	spawnflags(flags) =
	[
		1: "No Collision until break" : 1
		2: "Limit Endpoints" : 0
	]
	slideaxis(vecline) : "Sliding Axis"
	slidefriction(float) : "Set motor friction, 0 = no friction, 1 = friction that is about enough to counter gravity"
	SystemLoadScale(float) : "Load Scale" : "1" : "Scale of the mass load connected to this constraint (1=just the objects directly connected)"
	initialoffset(float) : "Initial Offset" : "0" : "Initial offset in the range from -1 to 1 where -1 means spawn at the min limit, 0 means apply no offset, and 1 means spawn at max limit"
	enablelinearconstraint(boolean) : "Enable Linear Constraint" : 1
	enableangularconstraint(boolean) : "Enable Angular Constraint" : 1
	motorfrequency(float) : "Motor frequency" : "10" : "Range 0 - 30 (only used when driving the relative offset through the offset input)"
	motordampingratio(float) : "Motor damping ratio" : "1" : "Range 0 - 1 (only used when driving the relative offset through the offset input)"
	motormaxforcemultiplier(float) : "Motor max force" : "0" : "Measured in multiples (e.g. 10x) of the mass where zero means NO limit (only used when driving the relative offset through the offset input)"
	useEntityPivot(boolean) : "Force Pivot" : 0 : "Force joint position as constraint pivot"
	
	// Inputs
	input SetOffset(float) : "Normalized input to drive along the slide axis. E.g 0 = min limit and 1 = max limit"
	input SetVelocity(float) : "Set linear velocity along the constraint"
	input SetSlideFriction(float) : "Set motor friction, 0 = no friction, 1 = friction that is about enough to counter gravity"
]

@PointClass base(TwoObjectPhysics) editormodel("models/editor/axis_helper.vmdl") tags( Physics ) = phys_lengthconstraint : 
	"A constraint that preserves the distance between two entities. If the 'Keep Rigid' flag is set, think of it as a rod. If not, think off it as a virtual rope."
[
	addlength(float) : "Additional Length" : "0" : "Add (or subtract) this amount to the rest length of the rope."
	minlength(float) : "Minimum Length" : "0" : "If the constraint is not rigid, this is the minimum length it can be."
	attachpoint(vecline) : "Attached object 2 point" : "0 0 0" : "The position the rope attaches to object 2"
	enablecollision(boolean) : "Enable Collision" : "0" : "Constraints disable collision between the attached entities. In some rare cases we want to enable this collision."
	spawnflags(flags) =
	[
		1: "No Collision until break" : 1
		2: "Keep Rigid" : 0
	]
]

@PointClass base(TwoObjectPhysics) editormodel("models/editor/axis_helper.vmdl") tags( Physics ) = phys_ragdollconstraint : 
	"A constraint that fixes the position of two entities, relative to this constraint's origin. Also allows for limits on the rotation around each axis, in the space of this constraint."
[
	spawnflags(flags) =
	[
		1: "No Collision until break" : 1
		2: "Only limit rotation (free movement)" : 0
	]

	xmin(float) : "X axis min limit" : "-90" : "-180 min and 180 max = no constraint on this axis."
	xmax(float) : "X axis max limit" : "90" : "-180 min and 180 max = no constraint on this axis."
	ymin(float) : "Y axis min limit" : "0" : "-180 min and 180 max = no constraint on this axis."
	ymax(float) : "Y axis max limit" : "0" : "-180 min and 180 max = no constraint on this axis."
	zmin(float) : "Z axis min limit" : "0" : "-180 min and 180 max = no constraint on this axis."
	zmax(float) : "Z axis max limit" : "0" : "-180 min and 180 max = no constraint on this axis."
	xfriction(float) : "X axis friction" : "0"
	yfriction(float) : "Y axis friction" : "0"
	zfriction(float) : "Z axis friction" : "0"
]

@PointClass base(TwoObjectPhysics, Parentname) editormodel("models/editor/axis_helper.vmdl") tags( Physics ) = phys_genericconstraint : 
	"A configurable constraint between two objects."
[
	linear_motion_x(choices) : "Linear Motion X" : "JOINT_MOTION_FREE" =
	[
		"JOINT_MOTION_FREE" : "Free motion"
		"JOINT_MOTION_LOCKED" : "Locked motion"
	]

	linear_frequency_x(float) : "Spring frequency (stiffness)" : "0"
	linear_damping_ratio_x(float) : "Spring damping ratio" : "0" : "0 for no damping and 1 for critical damping"
	forcelimit_x(float) : "Impulse Limit to Break (kg)" : "0" : "The amount of impulse an impact must apply to the constraint to break it. A way of calculating this is to set it to the mass of an object that would break this constraint if it were resting on the constrainted objects."

	notifyforce_x(float) : "Notify when X force reaches" : "0"
	notifyforcemintime_x(float) : "Minimum time between event firing X event (0 disables firing)" : "0"

	breakaftertime_x(float) : "Break after time at threshold on X (time)" : "0"
	breakaftertimethreshold_x(float) : "Break after time threshold on X (threshold)" : "0"

	linear_motion_y(choices) : "Linear Motion Y" : "JOINT_MOTION_FREE" =
	[
		"JOINT_MOTION_FREE" : "Free motion"
		"JOINT_MOTION_LOCKED" : "Locked motion"
	]

	linear_frequency_y(float) : "Spring frequency (stiffness)" : "0"
	linear_damping_ratio_y(float) : "Spring damping ratio" : "0" : "0 for no damping and 1 for critical damping"
	forcelimit_y(float) : "Impulse Limit to Break (kg)" : "0" : "The amount of impulse an impact must apply to the constraint to break it. A way of calculating this is to set it to the mass of an object that would break this constraint if it were resting on the constrainted objects."

	notifyforce_y(float) : "Notify when Y force reaches" : "0"
	notifyforcemintime_y(float) : "Minimum time between event firing Y event (0 disables firing)" : "0"

	breakaftertime_y(float) : "Break after time at threshold on Y (time)" : "0"
	breakaftertimethreshold_y(float) : "Break after time threshold on Y (threshold)" : "0"

	linear_motion_z(choices) : "Linear Motion Z" : "JOINT_MOTION_FREE" =
	[
		"JOINT_MOTION_FREE" : "Free motion"
		"JOINT_MOTION_LOCKED" : "Locked motion"
	]

	linear_frequency_z(float) : "Spring frequency (stiffness)" : "0"
	linear_damping_ratio_z(float) : "Spring damping ratio" : "0" : "0 for no damping and 1 for critical damping"
	forcelimit_z(float) : "Impulse Limit to Break (kg)" : "0" : "The amount of impulse an impact must apply to the constraint to break it. A way of calculating this is to set it to the mass of an object that would break this constraint if it were resting on the constrainted objects."

	notifyforce_z(float) : "Notify when Z force reaches" : "0"
	notifyforcemintime_z(float) : "Minimum time between event firing Z event (0 disables firing)" : "0"

	breakaftertime_z(float) : "Break after time at threshold on Z (time)" : "0"
	breakaftertimethreshold_z(float) : "Break after time threshold on Z (threshold)" : "0"

	angular_motion_x(choices) : "Angular Motion X" : "JOINT_MOTION_FREE" =
	[
		"JOINT_MOTION_FREE" : "Free motion"
		"JOINT_MOTION_LOCKED" : "Locked motion"
	]

	angular_frequency_x(float) : "Spring frequency (stiffness)" : "0"
	angular_damping_ratio_x(float) : "Spring damping ratio" : "0" : "0 for no damping and 1 for critical damping"
	torquelimit_x(float) : "Angular Impulse Limit to Break (kg * distance)" : "0" : "The amount of angular impulse required to break the constraint. A way of calculating this is to multiply any reference mass by the resting distance (from the center of mass of the object) needed to break the constraint."

	angular_motion_y(choices) : "Angular Motion Y" : "JOINT_MOTION_FREE" =
	[
		"JOINT_MOTION_FREE" : "Free motion"
		"JOINT_MOTION_LOCKED" : "Locked motion"
	]

	angular_frequency_y(float) : "Spring frequency (stiffness)" : "0"
	angular_damping_ratio_y(float) : "Spring damping ratio" : "0" : "0 for no damping and 1 for critical damping"
	torquelimit_y(float) : "Angular Impulse Limit to Break (kg * distance)" : "0" : "The amount of angular impulse required to break the constraint. A way of calculating this is to multiply any reference mass by the resting distance (from the center of mass of the object) needed to break the constraint."

	angular_motion_z(choices) : "Angular Motion Z" : "JOINT_MOTION_FREE" =
	[
		"JOINT_MOTION_FREE" : "Free motion"
		"JOINT_MOTION_LOCKED" : "Locked motion"
	]

	angular_frequency_z(float) : "Spring frequency (stiffness)" : "0"
	angular_damping_ratio_z(float) : "Spring damping ratio" : "0" : "0 for no damping and 1 for critical damping"
	torquelimit_z(float) : "Angular Impulse Limit to Break (kg * distance)" : "0" : "The amount of angular impulse required to break the constraint. A way of calculating this is to multiply any reference mass by the resting distance (from the center of mass of the object) needed to break the constraint."

	input SetLinearMotionLockedX(boolean) : ""
	input SetLinearMotionLockedY(boolean) : ""
	input SetLinearMotionLockedZ(boolean) : ""
	input SetLinearFrequencyX(float) : ""
	input SetLinearFrequencyY(float) : ""
	input SetLinearFrequencyZ(float) : ""
	input SetLinearDampingRatioX(float) : ""
	input SetLinearDampingRatioY(float) : ""
	input SetLinearDampingRatioZ(float) : ""

	input SetAngularMotionLockedX(boolean) : ""
	input SetAngularMotionLockedY(boolean) : ""
	input SetAngularMotionLockedZ(boolean) : ""
	input SetAngularFrequencyX(float) : ""
	input SetAngularFrequencyY(float) : ""
	input SetAngularFrequencyZ(float) : ""
	input SetAngularDampingRatioX(float) : ""
	input SetAngularDampingRatioY(float) : ""
	input SetAngularDampingRatioZ(float) : ""

	// Outputs
	output NotifyForceReachedX(void) : "The requested force has been reached on the X axis.  Won't fire if force min time is zero."
	output NotifyForceReachedY(void) : "The requested force has been reached on the Y axis.  Won't fire if force min time is zero."
	output NotifyForceReachedZ(void) : "The requested force has been reached on the Z axis.  Won't fire if force min time is zero."
]

@PointClass base(TwoObjectPhysics) editormodel("models/editor/axis_helper_thick") tags( Physics ) = phys_splineconstraint :
	"Constrain an entity to a spline."
[
	spawnflags(flags) =
	[
	]

	enablelinearconstraint(boolean) : "Enable Lateral Constraint" : 1
	enableverticalconstraint(boolean) : "Enable Vertical Constraint" : 1
	enableangularconstraint(boolean) : "Enable Angular Constraint" : 1
	enablelimit(boolean) : "Enable Limit" : 0 : "Prevents the object from moving off the ends of the spline. Don't use on splines that are meant to loop."

	linearfrequency(float) : "Linear Frequency" : "0" : "Linear spring frequency (stiffness)."
	lineardampingratio(float) : "Linear Damping Ratio" : "0" : "Linear spring damping ratio."
	jointfriction(float) : "Friction" : "0" : "Resistance/friction for movement along the spline"

	transitiontime(float) : "Transition Time" : "0" : "When changing splines (e.g. via SetSplineEntity), we smoothly transition the constraint anchor to the new spline over this time interval."

	fireeventsonpath(bool) : "Fire Events On Path" : "0" : "Notify our path when the attached entity moves along it so it can fire passthrough events, etc."

	input SetTransitionTime(float) : "Set the transition time used when changing splines"
	input SetSplineEntity(string) : "Set the spline to a new entity"
	input EnableLimit(void) : "Enable the limits at the ends of the spline"
	input DisableLimit(void) : "Disable the limits at the ends of the spline"
]

@BaseClass base(Targetname, BasePhysicsNoSettleAttached) = ForceController
[
	spawnflags(flags) =
	[
		// Thrust is on by default (will turn off in forcetime)
		1: "Start On" : 0
		// Apply linear force (if off, torque only)
		2: "Apply Force" : 1
		// Apply rotational force (torque - if off, linear only)
		4: "Apply Torque" : 1
		// Maintain local relationship with the attached object
		8: "Orient Locally" : 1
		// Impulse is independent of object's mass (impulse is acceleration NOT force)
		16: "Ignore Mass" : 0
	]
	attach1(target_destination) : "Attached Object" : "" : "Object to apply the force to."

	forcetime(string) : "Time of Force (0=inf)" : "0" : "Automatic shut-off after this time has passed (0 = stay on forever or until deactivated)"

	input Activate(void) : "Turn the force on"
	input Deactivate(void) : "Turn the force off"
	input Scale(string) : "Set Force Scale"
]

@PointClass base( ForceController) tags( Physics ) = phys_thruster : 
	"An entity used to apply constant acceleration to a physics object. "+
	"The force and torque is calculated using the position and direction of the thruster as an impulse. So moving those off the object's center "+
	"will cause torque as well. Torque can be removed by unchecking the 'apply torque' flag. The position of the thruster can be forced to be "+
	"at the object's center by checking to 'ignore pos' flag."
[
	spawnflags(flags) =
	[
		// Put the thrust at the object center
		32: "Ignore Pos" : 0
	]
	
	force(string) : "Force" : "0" : "Force (will be integrated, units are force kg*in/s^2)"
]

@PointClass halfgridsnap base(ForceController) tags( Physics ) = phys_torque : 
	"An angular thruster. Use it to apply angular force to an entity."
[
	// Angular acceleration (units are degress/s^2)
	force(string) : "Angular Acceleration" : "0"
	axis(vecline) : "Rotation Axis" : ""
]

@PointClass base(Targetname) halfgridsnap size(-8 -8 -8, 8 8 8) tags( Physics ) = phys_motor : 
	"An entity that tries to spin a target entity at a particular speed."
[
	speed(string) : "Rotation Speed" : "0" : "Angular speed (units are degress/second)"
	friction(float) : "Friction" : "0" : "Friction that slows the object's rotation when the motor is disabled. Start with a very small value between 0 and 1, and tune from there."
	spinup(string) : "Spin up time" : "1" : "spin up time in seconds (also affects the rate at which speed changes happen)"
	spindown(string) : "Spin down time" : "1" : "spin down time in seconds (also affects the rate at which speed changes happen)"
	inertiafactor(float) : "System Interia Scale" : "1.0" : "Make this larger if the object being driven is constrained to a set of heavier objects."
	axis(vecline) : "Rotation Axis" : ""

	spawnflags(flags) =
	[
		// starts on by default
		1: "Start On" : 1
		// Disable world collisions on hinges
		2: "No world collision" : 0
		// motor also acts as a hinge constraining the object to this axis
		4: "Hinge Object" : 1
		// Maintain local relationship with the attached object (NOT WORKING YET)
//		8: "Orient Locally" : 1
	]
	attach1(target_destination) : "Attached Object" : "" : "Object to apply the force to"
	attach2(target_destination) : "Anchor Object" : "" : "Object the other side of the motor joint is attached to. If blank, the motor is anchored to the world."

	// Inputs
	input SetSpeed(float) : "Sets target speed"
	input SetSpinUpTime(api)
	input SetSpinDownTime(api)
	input SetFriction(float) : "Sets friction -- only applies when the motor is off"
	input SetSystemInertiaScale(api)
	input TurnOn(void) : "Turns motor on"
	input TurnOff(void) : "Turns motor off"
]

@PointClass base(Targetname, Parentname, Studiomodel) editormodel() tags( Physics ) = phys_magnet : 
	"An entity that acts like a magnet, attaching metallic physics objects to itself when they touch it."
[
	spawnflags(flags) =
	[
		1 : "Start Asleep" : 0
		2 : "Motion Disabled" : 0
		4 : "Suck On Touch" : 0
		8 : "Allow Attached Rotation" : 0
		16: "Coast jeep pickup hack" : 0
	]

	forcelimit(float) : "Impulse Limit to Break (kg)" : "0" : "The amount of impulse necessary to break a stuck object off the magnet. A way of calculating this is to set it to the mass of an object that would break this constraint if it were resting on the magnet."
	torquelimit(float) : "Angular Impulse Limit to Break (kg * distance)" : "0" : "The amount of angular impulse necessary to break a stuck object off the magnet. A way of calculating this is to multiply any reference mass by the resting distance (from the center of mass of the object) needed to break the constraint."

	massScale(float) : "Mass Scale" : "0" : "A scale multiplier for the object's mass."
	maxobjects(integer) : "Maximum Attached Objects" : 0 : "The maximum number of physics objects that can be stuck to the magnet at once. 0 = no limit."

	// Inputs
	input TurnOn(void) : "Turn the magnet on."
	input TurnOff(void) : "The the magnet off. This will detach anything current stuck to the magnet."

	// Outputs
	output OnAttach(void) : "Fired when an entity is grabbed by the magnet."
	output OnDetach(void) : "Fired when an entity is released by the magnet."
]


//-------------------------------------------------------------------------
//
// Props
//
//-------------------------------------------------------------------------

@BaseClass = prop_static_base
[
	model(studio) [report] : "World Model"
	skin(materialgroup) [ group="Render Properties" ] : "Skin" : "default" : "Some models have multiple versions of their textures, called skins."
	solid(choices) : "Collisions" : 6 =
	[
		0: "Not Solid"
		2: "Use axis-aligned box"
		3: "Use oriented Box"
		6: "Use VPhysics"
	]

	disableshadows(choices) [ group="Render Properties" ] : "Cast Shadows" : 0 : "Used to disable shadow casting fromthis entity." = 
	[
		0: "Enabled"
		1: "No Shadows"
		2: "Only Realtime Shadows"
		3: "Only Baked Shadows"
	]

	fademindist(float) [ group="Render Properties" ] : "Start Fade Dist/Pixels" : -1 : "Distance at which the prop starts to fade (<0 = subtract from fademaxdist)."
	fademaxdist(float) [ group="Render Properties" ] : "End Fade Dist/Pixels" : 0 : "Maximum distance at which the prop is visible (0 = don't fade out)."
	visoccluder(boolean) [ group="Render Properties" ] : "Vis Occluder" : 0 : "If true this geometry is used as an occluder for precomputed visibility"	
	renderamt(integer) [ group="Render Properties" ] : "Alpha" : 255 : "Alpha of the fade, where 0 = fully transparent and 255 = fully opaque." 
	rendercolor(color255) : "Color (R G B)" : "255 255 255"
	disablelowviolence(choices) [ group="Render Properties" ] : "Turn Off in Low-Violence" : 0 =
	[
		0: "No"
		1: "Yes"
	]
]

@BaseClass base(Parentname, CanBeClientOnly, Global, BaseAnimGraph2, BreakableProp, RenderFields, Glow) tags( PropDynamic ) = prop_dynamic_base
[
	solid(choices) : "Collisions" : 6 =
	[
		0: "Not Solid"
		2: "Use axis-aligned box"
		3: "Use oriented Box"
		6: "Use VPhysics"
	]

	spawnflags(flags) =
	[
		64 : "Use Hitboxes for Renderbox" : 0
		256 : "Start with collision disabled" : 0
		512 : "Set to Nav Ignore" : 0
		1024 : "Set to Local-Nav Ignore (NPC will not try to avoid this entity)" : 0
	]

	disablelowviolence(choices) : "Turn Off in Low-Violence" : 0 =
	[
		0: "No"
		1: "Yes"
	]

	use_animgraph(boolean) { enabled={ function="ModelHasAnimGraph" } } : "Use Animgraph" : 1 : "Allow the model to use its animgraph it has one. If the model has no animgraph this setting has no effect and is disabled"

	StartingAnim(sequence) { enabled={ function="NotUsingAnimGraph" } is_preview_animation=true preview_animation_priority = 2 } : "Starting Animation" : "" : "The name of a starting animation that this prop will start with when it spawns. After completion, it will switch to the Idle sequence, if it is specified. This setting is ignored for models with an animgraph when Use Animgraph is enabled."
	StartingAnimationLoopMode(choices) : "Start Animation Loop Mode" : "ANIM_LOOP_MODE_NOT_LOOPING" =
	[
		"ANIM_LOOP_MODE_NOT_LOOPING" : "Do Not Loop"
		"ANIM_LOOP_MODE_LOOPING" : "Loop"
	]

	IdleAnim(sequence) { enabled={ function="NotUsingAnimGraph" } is_preview_animation=true } : "Idle Animation" : "" : "The name of the idle animation that this prop will revert to whenever it finishes a random or forced animation. This setting is ignored for models with an animgraph when Use Animgraph is enabled."
	IdleAnimationLoopMode(choices) : "Idle Animation Loop Mode" : "ANIM_LOOP_MODE_NOT_LOOPING" =
	[
		"ANIM_LOOP_MODE_NOT_LOOPING" : "Do Not Loop"
		"ANIM_LOOP_MODE_LOOPING" : "Loop"
	]

	randomizecycle(boolean) : "Randomize cycle" : 0 : "If set, this prop will randomize its cycle when it begins animating. Use this to desynchronize animating props that use the same model."

	LagCompensate(boolean) : "Lag Compensation" : 0 : "Enable to lag compensate this prop, should be use very sparingly!"
	AnimateOnServer(boolean) : "Animate on server in multiplayer" : 0 : "Enable this to animate on the server in multiplayer games, such as for props with triggers parented to attachment points. Use sparingly as there is a performance cost."

	interactAs(string) [ group="Physics Properties" ] : "interactAs" : "" : "comma-separated list of interaction layers to interact as"
	interactWith(string) [ group="Physics Properties" ] : "interactWith" : "" : "comma-separated list of interaction layers to interact with"
	interactExclude(string) [ group="Physics Properties" ] : "interactExclude" : "" : "comma-separated list of interaction layers to not collide with"

	// Inputs
	input SetAnimationLooping(string)			: "Force the prop to play an animation and force it to loop. The parameter should be the name of the animation."
	input SetAnimationNoResetLooping(string)	: "Force the prop to play an animation and force it to loop unless the prop is already playing the animation. The parameter should be the name of the animation."
	input SetIdleAnimationLooping(string)		: "Changes the Idle Animation to the one specified in the parameter and force it to loop."

	input SetAnimationNotLooping(string)		: "Force the prop to play an animation and force it to not loop. The parameter should be the name of the animation."
	input SetAnimationNoResetNotLooping(string) : "Force the prop to play an animation and force it to not loop unless the prop is already playing the animation. The parameter should be the name of the animation."
	input SetIdleAnimationNotLooping(string)	: "Changes the Idle Animation to the one specified in the parameter and force it to not loop."

	input SetPlaybackRate(float) : "Set the playback rate for the animation."
	input SetBodyGroup(string) : "Sets bodygroup. Format is <BodygroupName,index> "
	input TurnOn(void) : "Make the prop visible."
	input TurnOff(void) : "Make the prop invisible."
	input EnableCollision(void) : "Enable collision on the prop."
	input DisableCollision(void) : "Disable collision on the prop."
	input SetNavIgnore(boolean) : "Enable and disable NAVIgnore on the prop."

	// Outputs
	output OnAnimationBegun(void) : "Fired whenever a new animation has begun playing."
	output OnAnimationDone(void) : "Fired whenever an animation is complete."
	output OnAnimationReachedEnd(void) : "Fired whenever a non-looping animation playing forward hits the end (cycle=1)."
	output OnAnimationReachedStart(void) : "Fired whenever a non-looping animation playing backward hits the beginning (cycle=0)."
	output OnAnimationLoopCycleDone(void) : "Fires off an event when the current cycle of a looped animation is complete."

	lightingorigin(target_destination) : "Lighting Origin" : "" : "Select an entity to specify a location to sample lighting from, instead of using this entity's origin."

	renderamt(integer) : "Alpha" : 255 : "Alpha of the fade, where 0 = fully transparent and 255 = fully opaque." 
	rendercolor(color255) : "Color (R G B)" : "255 255 255"

	CreateNavObstacle(boolean) : "Create Nav Obstacle" : "0" : "Create a navigation obstacle to assist NPC pathfinding"

	forcenpcexclude(boolean) : "Force NPC Exclude" : "0" : "If set, NPC movement will ignore this prop"
]

@PointClass base(PosableSkeleton) tags( PropStatic ) color(255 255 0) line(255 0 255, targetname, cubemap) sphere(fademindist, 200 200 200) sphere(fademaxdist, 200, 200, 200) sphere(grass_exclusion_radius, 100 200 100, singleSelect) 
	model
	{
		static = true
		extra_vertex_data = true
	}
	metadata
	{
		model_archetypes = [ "static_prop_model" ]
		entity_tool_name = "Static Prop"
		entity_tool_group = "Content"
		entity_tool_tip = "Adds a static model"
		static_prop = true
		has_static_mesh = true
	}
= prop_static
[
	model(resource:model) [report] : "Model"
	rendercolor(color255) : "Tint Color" : "255 255 255"
	skin(materialgroup) : "Material Group" : "default" : "Some props have multiple matieral variations called Material Groups, here you can see what material groups are available for selection."	

//	Collision
	solid(choices) [ group="Collision" ] : "Collision Type" : 6 =
	[
		0: "Not Solid"
//		2: "Use axis-aligned box"
//		3: "Use oriented Box"
		6: "Use VPhysics"
	]

	collision_override(collision_property) { group="Collision" enabled={ variable="solid" value="6" } } : "Override Collision Property" : "" : "If a value is selected, it will be applied as the collision property to all of the phsyics shapes generated by this instance of the model, overriding any values specified in the model."

	// Lighting	
	bakelighting(choices) [ group="Lighting" ] : "Lighting Type" : -1 : "Selects whether to use lightmapping or lightprobes for this mesh. Note: Selecting light probes will disable mesh merging/batching, creating extra draw calls. To merge lightprobed meshes, enable the Bake to World parameter."=
	[
		-1 : "Default"
		1 : "Lightmapped"
		0 : "Lightprobed"
	]
	disableshadows(choices) [ group="Lighting" ] : "Shadow Type" : 0 : "Selects the type of shadows that should be cast from this prop_static." = 
	[
		0: "Baked & Dynamic"
		3: "Only Baked"
		2: "Only Dynamic"
		1: "None"
	]
	emissive(boolean) [ group = "Lighting" ] : "Emissive" : 1 : "Allow this prop to emit lighting. Note that this only works on materials with Self Illum parameters, and is only visible in the GPU Path Tracing Preview and in the final lightmap bake."
	emissive_lighting_boost(float) { group = "Lighting" min="0.0" max="8.0" enabled={ variable="emissive" value="1"  } } : "Emissive Boost" : "1.0" : "Used to boost emissive lighting from a mesh. Note that boosting emissive on smaller meshes can create more lighting artifacts/noise."
	lightmapscalebias(choices) [ group="Lighting" ] : "Lightmap Scale Bias" : 0 : "Used to scale the resolution of the lightmap for this mesh." =
	[
		-3 : "Scale down by 8"
		-2 : "Scale down by 4"
		-1 : "Scale down by 2"
		0 : "Default (no scale)"
		1 : "Scale up by 2"
		2 : "Scale up by 4"
		3 : "Scale up by 8"
	]
	bakelightdoublesided(boolean) [ group = "Lighting" ] : "Bake As Double-Sided" : 0 : "Bakes the mesh as if it were double-sided geometry in the lightmapper. Useful on geometry with 'Render Backfaces' enabled via it's material (such as foliage). When the lightmapper sees many and/or large backfaces it will invalidate lightmap samples as an optimization, which can lead to lightmap errors/reduced quality in some circumstances."

	// Vis
	visoccluder(boolean) [ group="Precomputed Visibility" ] : "Vis Occluder" : 0 : "If true this geometry is used as an occluder for precomputed visibility. As a rule this geometry should be as simplistic as possible"	

	// Material Override?
	materialoverride(material) [ group="Material Override " ] : "Material Override" : "" : "This will override all materials on a selected mesh with a specific material"

	// Render Properties
	lodlevel(lod_level)  [ group="Render Properties" ] : "Render LOD" : "-1" : "Auto for standard LOD behaviour, or select an explicit LOD to use. Note that LODs take up more room in the lightmap and do not merge, potentially making them less performant if used on many objects (Set to Auto)."
	fademindist(float) [ group="Render Properties" ] : "Start Fade Dist" : -1 : "Distance at which the prop starts to fade (-1 = use fademaxdist)."
	fademaxdist(float) [ group="Render Properties" ] : "End Fade Dist" : 0 : "Maximum distance at which the prop is visible (0 = don't fade out)."
	baketoworld(boolean) [ group="Build Settings" ] : "Force Bake To World" : 0 : "If true mesh will be baked/merged into the world geometry of the map so that the model is not referenced at runtime. Use this if you want light probed static meshes to merge"
	disablemerging(boolean) [ group="Build Settings" ] : "Disable Mesh Merging" : 0 : "If true this will not be merged with other geometry during map compile (reduces rendering efficiency)."
	renderamt(integer) [ group="Render Properties" ] : "Alpha" : 255 : "Alpha of the fade, where 0 = fully transparent and 255 = fully opaque." 
	rendertocubemaps(boolean) [ group="Render Properties" ] : "Render to Cubemaps" : 1 : "If true, this geometry renders into baked cube maps"	
	renderwithdynamic(boolean) [ group="Render Properties" ] : "Render with Dynamic Objects" : 0 : "Render this object with other dynamic objects"
]


@PointClass base(prop_dynamic_base, EnableDisable) sphere(fademindist) sphere(fademaxdist) model()
	metadata
	{
		model_archetypes = [ "animated_model" ]
		entity_tool_name = "Dynamic Prop"
		entity_tool_group = "Content"
		entity_tool_tip = "Adds a dynamic model - use this for models that have animation or movement"
	}
= prop_dynamic :
	"A prop that can be placed in hierarchy and can play animations and/or simulate cloth. It can also be configured to break when it takes enough damage. "+
	"Note that the health of the object will be overridden by the health inside the model, to ensure consistent health game-wide. "+
	"If the model used by the prop is configured to be used as a prop_physics (i.e. it should be physically simulated) then it CANNOT be "+
	"used as a prop_dynamic. Upon level load it will display a warning in the console and remove itself. Use a prop_physics instead."
[
	clothScale(float) : "Cloth Scale" : 1 : "Cloth scale (stretch) relative to model scale. Use to stretch (not scale) the model, e.g. to reuse a single rope model when different lengths of the rope needed."
]

@PointClass base(prop_dynamic_base) model() = prop_dynamic_override :
	"A prop that can be placed in hierarchy and can play animations. It can also be configured to break when it takes enough damage.<br>"+
	"prop_dynamic_override is a prototyping entity only. It will allow the use of models designed to be used as prop_physics."
[
	health(integer) : "Health" : 0 : "Number of points of damage to take before breaking.  0 means don't break."	
]

@BaseClass base(Parentname, Targetname, Global, CanBeClientOnly, BaseAnimGraph2, BreakableProp, Glow) tags( PropPhysics ) = BasePropPhysics
[ 
	spawnflags(flags) [ group="Physics Properties" ] = 
	[
		1 : "Start Asleep" : 0
		2 : "Don't take physics damage" : 0
		4 : "Debris - Don't collide with the player or other debris" : 0
		8 : "Motion Disabled" : 0
		1024: "Prevent motion enable on player bump" : 0
		4096: "Debris with trigger interaction" : 0
		8192: "Force non-solid to players" : 0
	]
	
	minhealthdmg(integer) [ group="Physics Properties" ] : "Min Damage to Hurt" : 0 : "The prop will ignore any damage events if the damage is less than this amount."
	shadowcastdist(integer) [ group="Physics Properties" ] : "Shadow Cast Distance" : 0 : "Use this to override how far this object casts shadows. 0 = default distance."
	physdamagescale(float) [ group="Physics Properties" ] : "Physics Impact Damage Scale" : "0.1" : "Scales damage energy when this object is hit by a physics object. NOTE: 0 means this feature is disabled for backwards compatibility.<br>Set to 1.0 for materials as strong as flesh, smaller numbers indicate stronger materials."
	Damagetype(choices) [ group="Physics Properties" ] : "Impact damage type" : 0 =
	[
		0: "Blunt"
		1: "Sharp"
	]

	nodamageforces(choices) [ group="Physics Properties" ] : "Damaging it Doesn't Push It" : 0 : "Used to determine whether or not damage should cause the brush to move." =
	[
		0: "No"
		1: "Yes"
	]

	acceptdamagefromheldobjects(boolean) : "Accept damage from player held objects" : 0 : "Set to true so the player can bash this with held props."

	inertiaScale(float) [ group="Physics Properties" ] : "Scale Factor For Inertia" : "1.0" : "Scales the angular mass of an object. Used to hack angular damage and collision response."
	massScale(float) [ group="Physics Properties" ] : "Mass Scale" : "0" : "A scale multiplier for the object's mass."
	buoyancyScale(float) [ group="Physics Properties" ] : "Buoyancy Scale" : "1.0" : "Scales how water forces affect this object."
	damagetoenablemotion(integer) [ group="Physics Properties" ] : "Health Level to Override Motion" : 0 : "If specified, this object will start motion disabled. Once its health has dropped below this specified amount, it will enable motion."
	forcetoenablemotion(float) [ group="Physics Properties" ] : "Physics Impact Force to Override Motion" : 0 : "If specified, this object will start motion disabled. Any impact that imparts a force greater than this value on the physbox will enable motion."
	dynamiccontinuouscontactbehavior(choices) [ group="Physics Properties" ] : "Dynamic Continuous Contact Behavior" : 0 =
	[
		0 : "Allow if requested by other body"
		1 : "Always (request continuous contact against other dynamic bodies)"
		2 : "Never (don't use continuous contact against other dynamic bodies even if another body requests it)"
	]

	enableuseoutput(boolean) : "Enable +Use Output" : 0 : "Enables OnPlayerUse output being fired when this object is used"
	puntsound(sound) [ group="Physics Properties" ] : "Sound to make when punted"

	addon(string) [ group="Physics Properties" ] : "AI AddOn" : "" : "If specified this object will use this addon behavior when installed in a composite AI"
	interactAs(string) [ group="Physics Properties" ] : "interactAs" : "" : "comma-separated list of interaction layers"
	forcenavignore(boolean) [ group="Physics Properties" ] : "Force Nav Ignore" : "0" : "If set, NPCs will ignore this prop when navigating."
	forcenpcexclude(boolean) [ group="Physics Properties" ] : "Force NPC Exclude" : "0" : "If set, NPC movement will ignore this prop"
	nonavmeshblocker(boolean) [ group="Physics Properties" ] : "No Navmesh Blocker" : "0" : "If set, don't auto-create a navmesh blocker."
	auto_convert_back_from_debris(boolean) [ group="Physics Properties" ] : "Auto Convert back from Debris" : "1" : "If set, this prop will automatically convert back to interactive debris after coming to rest as Debris."
	updatenavwhenmoving(boolean) [ group="Physics Properties" ] : "Update Nav When Moving" : "0" : "If set, nav mesh will be constantly updated while this obstacle is moving, and not just when this obstacle is settled."
	forcenavcut(boolean) [ group = "Physics Properties" ] : "Force Nav Cut " : "0" : "If set, this obstacle will cut the mesh causing NPC's to avoid it regardless of its mass."
	allowobstacleconvexhullmerging(boolean) [ group = "Physics Properties" ] : "Allow Obstacle Merging" : "1" : "If set, this obstacle will be merged with nearby obstacles to improve performance."

	ammobalancing_removable(choices) [ group="Break Contents" ] : "Removal Allowed for Ammo Balancing" : "0" =
	[
		"0" : "No"
		"1" : "Yes"
	]

	ItemClass1( vdata_choice:scripts/misc.vdata&scripts/grenades.vdata ) [ group="Break Contents" ] : "Item Subclass 1" : "" : "Subclass name of the entity to spawn when the crate is broken"
	ItemCount1(integer) [ group="Break Contents" ] : "Item Count 1" : 1 : "Number of items to emit upon breakage"
	ItemClass2( vdata_choice:scripts/misc.vdata&scripts/grenades.vdata ) [ group="Break Contents" ] : "Item Subclass 2" : "" : "Subclass name of the entity to spawn when the crate is broken"
	ItemCount2(integer) [ group="Break Contents" ] : "Item Count 2" : 1 : "Number of items to emit upon breakage"
	ItemClass3( vdata_choice:scripts/misc.vdata&scripts/grenades.vdata ) [ group="Break Contents" ] : "Item Subclass 3" : "" : "Subclass name of the entity to spawn when the crate is broken"
	ItemCount3(integer) [ group="Break Contents" ] : "Item Count 3" : 1 : "Number of items to emit upon breakage"
	ItemClass4( vdata_choice:scripts/misc.vdata&scripts/grenades.vdata ) [ group="Break Contents" ] : "Item Subclass 4" : "" : "Subclass name of the entity to spawn when the crate is broken"
	ItemCount4(integer) [ group="Break Contents" ] : "Item Count 4" : 1 : "Number of items to emit upon breakage"

	// Inputs
	input Wake(void) : "Wake up this physics object, if it is sleeping."
	input Sleep(void) : "Put this physics object to sleep. It will wake if given the Wake input, or if force is applied to it. Note that physics objects go to sleep automatically after coming to rest for a while, so you don't really need to use this."
	input EnableMotion(void) : "Enable physics motion/collision response."
	input DisableMotion(void) : "Disable physics motion/collision response."
	input EnableGravity(void) : "Enable gravity on physics object"
	input DisableGravity(void) : "Disable gravity on physics object"
	input SetBodyGroup(string) : "Sets bodygroup. Format is <BodygroupName,index> "
	input physdamagescale(float) : "Set the Physics Impact Damage Scale for this character. NOTE: 0 means this feature is disabled for backwards compatibility."
	input EnableDamageForces(void) : "Damaging the entity applies physics forces to it."
	input DisableDamageForces(void) : "Damaging the entity does *not* apply physics forces to it."
	input SetAutoConvertBackFromDebris(boolean) : "Set whether or not this prop should automatically convert back to interactive debris after it comes to rest as debris."
	input AddAttribute(string) : "Add an attribute with a value of 1."
	input RemoveAttribute(string) : "Remove an attribute."

	// Outputs
	output OnMotionEnabled(void) : "Fired when motion is enabled on this prop, either via 'Health Level to Override Motion' or from the EnableMotion input."
	output OnAwakened(void) : "Fired when this entity becomes awake (collision/force is applied to it while it's asleep)."
	output OnPlayerUse(void) : "Fired when the player tries to +USE the prop. This output will fire only if the Generate output on +USE spawnflag is set."
	output OnOutOfWorld(void) : "Fired whenever the prop is out of the allowed world bounds."
]

@PointClass base(BasePropPhysics, BaseFadeProp, BasePhysicsSimulated) model() sphere(fademindist) sphere(fademaxdist) = prop_physics_override :
	"A prop that physically simulates as a single rigid body. It can be constrained to other physics objects using hinges "+
	"or other constraints. It can also be configured to break when it takes enough damage. Health can be overridden on this version."
[
	health(integer) : "Health" : 0 : "Number of points of damage to take before breaking.  0 means don't break."
	propdata_override(string) : "Prop Data Override" : "" : "Prop Data names defined in propdata.vdata are typically defined in the VMDL used by this prop. For prototyping, this allows you to select a specific one and ignore the name in the VMDL."
	
	// Inputs
	input Ignite(void) : "Ignite, burst into flames."
	input IgniteLifetime(float) : "Ignite, with a parameter lifetime."
	input IgniteNumHitboxFires(integer) : "Ignite, with a parameternumber of hitbox fires."
	input IgniteHitboxFireScale(float) : "Ignite, with a parameter hitbox fire scale."
]

@PointClass base(BasePropPhysics, RenderFields, BasePhysicsSimulated) model() sphere(fademindist) sphere(fademaxdist) vecline_local( burstlocation, 255, 200, 200, hideifzero, requires_breakable_model ) text_local( burstlocation, "  Burst Location", 255, 200, 200, hideifzero, requires_breakable_model )
	metadata
	{
		model_archetypes = [ "physics_prop_model", "breakable_prop_model" ]
	}
= prop_physics :
	"A prop that physically simulates as a single rigid body. It can be constrained to other physics objects using hinges "+
	"or other constraints. It can also be configured to break when it takes enough damage. "+
	"Note that the health of the object will be overridden by the health inside the model, to ensure consistent health game-wide. "+
	"If the model used by the prop is configured to be used as a prop_dynamic (i.e. it should not be physically simulated) then it CANNOT be "+
	"used as a prop_physics. Upon level load it will display a warning in the console and remove itself. Use a prop_dynamic instead."
[
	// Inputs
	input Ignite(void) : "Ignite, burst into flames."
	input IgniteLifetime(float) : "Ignite, with a parameter lifetime."
	input IgniteNumHitboxFires(integer) : "Ignite, with a parameternumber of hitbox fires."
	input IgniteHitboxFireScale(float) : "Ignite, with a parameter hitbox fire scale."
]

@PointClass base(prop_physics) model() sphere(fademindist) sphere(fademaxdist) 
	metadata
	{
	entity_tool_name = "Physics Prop"
	entity_tool_group = "Content"
	entity_tool_tip = "Adds a physically simulated model that is affected by gravity and other forces"
	}
= prop_physics_multiplayer :
	"This class is the same as prop_physics, except the runtime collisions use a more bouncy method that avoids " +
	"the prediction errors normal physics objects get."
[
	physicsmode(choices) : "Physics Mode" : 0 =
	[
		0: "Auto Detect"
		1: "Solid, Server-side"
		2: "Non-Solid, Server-side"
		3: "Non-Solid, Client-side"
	]
]


@PointClass base(Targetname, Studiomodel, BaseFadeProp, EnableDisable, PosableSkeleton, BasePhysicsSimulated) tags( PropPhysics ) sphere(fademindist) sphere(fademaxdist) model() = prop_ragdoll :
	"A prop that physically simulates and can be articulated with internal joints. The joint constraints are part of the physics model."
[
	spawnflags(flags) = 
	[
		4 : "Debris - Don't collide with the player or other debris" : 0
		8192 : "Allow Dissolve" : 0
		16384 : "Motion Disabled" : 0
		32768 : "Unused" : 0
		65536 : "Start asleep" : 0
		131072 : "Don't force sleep" : 0
	]
    allowStretch(bool) : "Allow Stretch" : "0" : "Disables rendering fixup on bones that become separated"
	angleOverride(string) : "Override Animation" : "" : "Filled in by the engine via wc_update_entity, do not edit by hand except to clear."
	lightingorigin(target_destination) : "Lighting Origin" : "" : "Select an entity to specify a location to sample lighting from, instead of using this entity's origin."

	massScale(float) [ group = "Physics Properties" ] : "Mass Scale" : "0" : "A scale multiplier for the object's mass. 0 = use auto-calculated mass based on the object's size / shape and material"
	buoyancyscale(float) [ group = "Physics Properties" ] : "Buoyancy Scale" : "1" : "Scale on the buoyancy / fluid forces applied to this object"

	input EnableMotion(void) : "Enable physics motion/collision response."
	input DisableMotion(void) : "Disable physics motion/collision response."
	input FadeAndRemove(float) : "Fade out then remove (kill) self. Parameter override = duration of fade"
]

@PointClass base(prop_dynamic_base) model() = prop_dynamic_ornament :
	"A way to attach one model to another as an ornament. It will render in the way that player/NPC weapons render."
[
	solid(choices) : "Collisions" : 6 =
	[
		0: "Not Solid"
		2: "Use axis-aligned box"
		3: "Use oriented Box"
		6: "Use VPhysics"
	]
	InitialOwner(string) : "Target Entity" : : "Name of the entity that this ornament should attach to, at startup."
	
	// Inputs
	input SetAttached(string) : "Attach the ornament to a different entity. Parameter should be the name of entity to attach to."
	input Detach(string) : "Detach from the Target Entity and become invisible. The ornament can be re-attached with the SetAttached input."
]


//-------------------------------------------------------------------------
// Vehicles.
//-------------------------------------------------------------------------
@BaseClass base(Targetname, Global) = BaseVehicle
[
	subclass_name( subclass_choice:scripts/vehicles.vdata ) : "Vehicle Subclass" : "" : "Subclass of the Vehicle."

	vehicle_locked(boolean) : "Start locked" : 0

	// Outputs
	output PassengerEntered(integer) : "Passenger entered the vehicle (argument is passenger index)"
	output PassengerExited(integer) : "Passenger exited the vehicle (argument is passenger index)"

	input Lock(void) : "Prevent passengers from entering or exiting the vehicle."
	input Unlock(void) : "Re-allow passengers to enter or exit the vehicle."
]

//==================================================================================================
@PointClass base(BaseVehicle) 
	vdata_model{my_key = "subclass_name" vdata_key = "m_sModelName" use_class_when_blank = true}
= vehicle_entityio :
	"Vehicle which does nothing but fire outputs based on IN_BUTTONS, typically used for prototyping."
[
	button1(choices) : "Button 1" : 0 : "The button which fires the Button1-related outputs." =
	[
		0 : "IN_NONE"
		1 : "IN_ATTACK"
		2 : "IN_JUMP"
		4 : "IN_DUCK"
		8 : "IN_FORWARD"
		16 : "IN_BACK"
	//	32 : "IN_CANCEL"
	//	64 : "IN_TURNLEFT"
	//	128 : "IN_TURNRIGHT"
		256 : "IN_MOVELEFT"
		512 : "IN_MOVERIGHT"
		1024 : "IN_ATTACK2"
	//	2048 : "IN_RUN"
		4096 : "IN_RELOAD"
	]

	button2(choices) : "Button 2" : 0 : "The button which fires the Button2-related outputs." =
	[
		0 : "IN_NONE"
		1 : "IN_ATTACK"
		2 : "IN_JUMP"
		4 : "IN_DUCK"
		8 : "IN_FORWARD"
		16 : "IN_BACK"
	//	32 : "IN_CANCEL"
	//	64 : "IN_TURNLEFT"
	//	128 : "IN_TURNRIGHT"
		256 : "IN_MOVELEFT"
		512 : "IN_MOVERIGHT"
		1024 : "IN_ATTACK2"
	//	2048 : "IN_RUN"
		4096 : "IN_RELOAD"
	]

	button3(choices) : "Button 3" : 0 : "The button which fires the Button3-related outputs." =
	[
		0 : "IN_NONE"
		1 : "IN_ATTACK"
		2 : "IN_JUMP"
		4 : "IN_DUCK"
		8 : "IN_FORWARD"
		16 : "IN_BACK"
	//	32 : "IN_CANCEL"
	//	64 : "IN_TURNLEFT"
	//	128 : "IN_TURNRIGHT"
		256 : "IN_MOVELEFT"
		512 : "IN_MOVERIGHT"
		1024 : "IN_ATTACK2"
	//	2048 : "IN_RUN"
		4096 : "IN_RELOAD"
	]

	button4(choices) : "Button 4" : 0 : "The button which fires the Button4-related outputs." =
	[
		0 : "IN_NONE"
		1 : "IN_ATTACK"
		2 : "IN_JUMP"
		4 : "IN_DUCK"
		8 : "IN_FORWARD"
		16 : "IN_BACK"
	//	32 : "IN_CANCEL"
	//	64 : "IN_TURNLEFT"
	//	128 : "IN_TURNRIGHT"
		256 : "IN_MOVELEFT"
		512 : "IN_MOVERIGHT"
		1024 : "IN_ATTACK2"
	//	2048 : "IN_RUN"
		4096 : "IN_RELOAD"
	]

	button5(choices) : "Button 5" : 0 : "The button which fires the Button5-related outputs." =
	[
		0 : "IN_NONE"
		1 : "IN_ATTACK"
		2 : "IN_JUMP"
		4 : "IN_DUCK"
		8 : "IN_FORWARD"
		16 : "IN_BACK"
	//	32 : "IN_CANCEL"
	//	64 : "IN_TURNLEFT"
	//	128 : "IN_TURNRIGHT"
		256 : "IN_MOVELEFT"
		512 : "IN_MOVERIGHT"
		1024 : "IN_ATTACK2"
	//	2048 : "IN_RUN"
		4096 : "IN_RELOAD"
	]

	button6(choices) : "Button 6" : 0 : "The button which fires the Button6-related outputs." =
	[
		0 : "IN_NONE"
		1 : "IN_ATTACK"
		2 : "IN_JUMP"
		4 : "IN_DUCK"
		8 : "IN_FORWARD"
		16 : "IN_BACK"
	//	32 : "IN_CANCEL"
	//	64 : "IN_TURNLEFT"
	//	128 : "IN_TURNRIGHT"
		256 : "IN_MOVELEFT"
		512 : "IN_MOVERIGHT"
		1024 : "IN_ATTACK2"
	//	2048 : "IN_RUN"
		4096 : "IN_RELOAD"
	]

	button7(choices) : "Button 7" : 0 : "The button which fires the Button7-related outputs." =
	[
		0 : "IN_NONE"
		1 : "IN_ATTACK"
		2 : "IN_JUMP"
		4 : "IN_DUCK"
		8 : "IN_FORWARD"
		16 : "IN_BACK"
	//	32 : "IN_CANCEL"
	//	64 : "IN_TURNLEFT"
	//	128 : "IN_TURNRIGHT"
		256 : "IN_MOVELEFT"
		512 : "IN_MOVERIGHT"
		1024 : "IN_ATTACK2"
	//	2048 : "IN_RUN"
		4096 : "IN_RELOAD"
	]

	button8(choices) : "Button 8" : 0 : "The button which fires the Button8-related outputs." =
	[
		0 : "IN_NONE"
		1 : "IN_ATTACK"
		2 : "IN_JUMP"
		4 : "IN_DUCK"
		8 : "IN_FORWARD"
		16 : "IN_BACK"
	//	32 : "IN_CANCEL"
	//	64 : "IN_TURNLEFT"
	//	128 : "IN_TURNRIGHT"
		256 : "IN_MOVELEFT"
		512 : "IN_MOVERIGHT"
		1024 : "IN_ATTACK2"
	//	2048 : "IN_RUN"
		4096 : "IN_RELOAD"
	]

	// Outputs
	output OnButtonStart1(integer) : "Passenger started hitting button 1 (argument is passenger index)"
	output OnButtonEnd1(integer) : "Passenger stopped hitting button 1 (argument is passenger index)"

	output OnButtonStart2(integer) : "Passenger started hitting button 1 (argument is passenger index)"
	output OnButtonEnd2(integer) : "Passenger stopped hitting button 2 (argument is passenger index)"

	output OnButtonStart3(integer) : "Passenger started hitting button 3 (argument is passenger index)"
	output OnButtonEnd3(integer) : "Passenger stopped hitting button 3 (argument is passenger index)"

	output OnButtonStart4(integer) : "Passenger started hitting button 4 (argument is passenger index)"
	output OnButtonEnd4(integer) : "Passenger stopped hitting button 4 (argument is passenger index)"

	output OnButtonStart5(integer) : "Passenger started hitting button 5 (argument is passenger index)"
	output OnButtonEnd5(integer) : "Passenger stopped hitting button 5 (argument is passenger index)"

	output OnButtonStart6(integer) : "Passenger started hitting button 6 (argument is passenger index)"
	output OnButtonEnd6(integer) : "Passenger stopped hitting button 6 (argument is passenger index)"

	output OnButtonStart7(integer) : "Passenger started hitting button 7 (argument is passenger index)"
	output OnButtonEnd7(integer) : "Passenger stopped hitting button 7 (argument is passenger index)"

	output OnButtonStart8(integer) : "Passenger started hitting button 8 (argument is passenger index)"
	output OnButtonEnd8(integer) : "Passenger stopped hitting button 8 (argument is passenger index)"
]

//-------------------------------------------------------------------------
//
// Solid Entities
//
//-------------------------------------------------------------------------

@SolidClass base(BreakableBrush, RenderFields, Shadow) = func_breakable : 
	"A brush entity that can be broken from damage, or an input." 
[
	minhealthdmg(integer) : "Min Damage to Hurt" : 0 : "The prop will ignore any damage events if the damage is less than this amount."
	gamemass(integer) : "Game Mass Override" : 0 : "Set the game mass by hand instead of using the code defaults."

	overrideBlockLOS(choices) : "Block LOS override" : 0 : "Should this entity block or not-block LOS" =
	[
		0 : "use default"
		1 : "Force no block LOS"
		2 : "Force block LOS"
	]

	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	physdamagescale(float) [ group="Physics Properties" ] : "Physics Impact Damage Scale" : "1.0" : "Scales damage energy when this object is hit by a physics object. NOTE: 0 means this feature is disabled for backwards compatibility.<br>Set to 1.0 for materials as strong as flesh, smaller numbers indicate stronger materials."
]

@SolidClass base(Targetname, Parentname, RenderFields, Shadow) = func_illusionary : 
	"Legacy support. Use func_brush instead." 
[
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
]

@SolidClass base(Trigger)
	metadata
	{
		auto_apply_material = "materials/tools/toolsprecipitation.vmat"
	}

= func_precipitation :
	"A brush entity that creates precipitation inside its volume."
[
	spawnflags(flags) = 
	[
		1: "Clients" : 1
		2: "NPCs" : 0
		4: "Pushables": 0
		8: "Physics Objects" : 0
		16: "Only player ally NPCs" : 0
		32: "Only clients in vehicles" : 0
		64: "Everything (not including physics debris)" : 1
		512: "Only clients *not* in vehicles" : 0
		1024: "Physics debris" : 0
		2048: "Only NPCs in vehicles (respects player ally flag)" : 0
		4096: "Correctly account for object mass (trigger_push used to assume 100Kg) and multiple component physobjs (car, blob...)" : 1
		8192: "Ignore client's hands" : 0
	]
	subclass_name( subclass_choice:scripts/precipitation.vdata ) : "Precipitation Subclass" : "" : "The Type of Precipitation."
	renderamt(integer) : "Density (0-100%)" : 100	
]

@SolidClass base(Targetname, Parentname) = func_precipitation_blocker : 
	"A brush entity that prevents rain and snow inside its volume."
[
]


@SolidClass base(Targetname, Parentname) = func_detail_blocker : 
	"A Hammer-only brush entity that prevents detail sprites from being placed inside its volume."
[
]


@SolidClass base(func_wall) = func_wall_toggle : 
	"A brush entity that can be toggled on/off. When off, the brush will be non-solid and invisible. Does not cast lightmap shadows." 
[
	spawnflags(flags) =
	[
		1 : "Starts Invisible" : 0
	]

	// Inputs
	input  Toggle(void) : "Toggle the brush on/off. When off, the brush will be non-solid and invisible." 
]

@SolidClass base(Targetname, Parentname, RenderFields, Global) = func_guntarget :
	"This is a moving target that moves along a path of path_tracks. It can be shot and killed."
[
	speed(integer) : "Speed (units per second)" : 100 : "The speed at which the target moves along its path."
	target(target_destination) : "First stop target" : : "The name of the first path_track entity in the path that this target should follow."
	health(integer) : "Damage to Take" : 0 : "The amount of damage taken before this target is killed."
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	
	// Inputs
	input Start(void) : "Start the target moving."
	input Stop(void) : "Stop the target from moving."
	input Toggle(void) : "Toggle the target between moving and stopped."
	
	// Outputs
	output OnDeath(void) : "Fires when the target is killed."
]

@PointClass = func_fish_pool : "Creates a school of interactive fish that swim near this entity."
[
	model(studio) : "World model" : "models/Junkola.vmdl"
	fish_count(integer) : "Fish Count" : 10 : "Number of Fish in this Pool"
	max_range(float) : "Max Range" : 150 : "How far away a Fish can wander (max 255)"
]


//-------------------------------------------------------------------------
//
// Trains and Tracks
//
//-------------------------------------------------------------------------

@BaseClass = PlatSounds 
[
	movesnd(choices) : "Move Sound" : 0 : "The sound played whenever the platform starts moving." = 
	[
		0: "No Sound"
		1: "big elev 1"
		2: "big elev 2"
		3: "tech elev 1"
		4: "tech elev 2"
		5: "tech elev 3"
		6: "freight elev 1"
		7: "freight elev 2"
		8: "heavy elev"
		9: "rack elev"
		10: "rail elev"
		11: "squeek elev"
		12: "odd elev 1"
		13: "odd elev 2"
	]
	stopsnd(choices) : "Stop Sound" : 0 : "The sound played when the platform stops moving." = 
	[
		0: "No Sound"
		1: "big elev stop1"
		2: "big elev stop2"
		3: "freight elev stop"
		4: "heavy elev stop"
		5: "rack stop"
		6: "rail stop"
		7: "squeek stop"
		8: "quick stop"
	]
	volume(string) : "Sound Volume 0.0 - 1.0" : "0.85"
]

@BaseClass base(Targetname, Parentname, RenderFields, Global, PlatSounds) = Trackchange
[
	height(integer) : "Travel Altitude" : 0 : "The vertical height above the track that the train moves. Negative values moves the train below."
	spawnflags(flags) =
	[
		1: "Auto Activate train" : 0
		2: "Relink track" : 0
		8: "Start at Bottom" : 0
		16: "Rotate Only" : 0
		64: "X Axis" : 0
		128: "Y Axis" : 0
	]
	rotation(integer) : "Spin amount" : 0 : "The amount this platform should rotate as it moves, in degrees."
	train(target_destination) : "Train to Switch"			// NEEDHELP
	toptrack(target_destination) : "Top Track"				// NEEDHELP
	bottomtrack(target_destination) : "Bottom Track"		// NEEDHELP
	speed(integer) : "Move/Rotate Speed" : 0				// NEEDHELP
]

@BaseClass base(Targetname, Parentname, RenderFields, Global, Shadow) = BaseTrain
[
	spawnflags(flags) =
	[
		1 : "No Pitch (X-rot)" : 0
		2 : "No User Control" : 0
		8 : "Passable" : 0
		16 : "Fixed Orientation" : 0
		128 : "HL1 Train" : 0
		256 : "Use max speed for pitch shifting move sound" : 0
		512 : "Is unblockable by player" : 0
	]
	
	target(target_destination) : "First Stop Target" : "" : "The name of the first path_track in the train's path. The train " +
		"will spawn at this path_track. It will also turn to face direction indicated by the 'Orientation Type' setting."
	
	startspeed(integer) : "Max Speed (units / second)" : 100 : "The maximum speed that this train can move. "+
		"Any speeds applied to this train, such as by path_tracks or SetSpeed inputs, will be clipped to this maximum value."
	
	speed(integer) : "Initial Speed (units / second)" : 0 : "The speed that the train will move at after it spawns, 0 = stopped."
	
	velocitytype(choices) : "Change Velocity" : 0 : "The method through which this train changes its velocity as it moves along the path." =
	[
		0 : "Instantaneously"
		1 : "Linear blend"
		2 : "Ease in/ease out"
	]
	
	orientationtype(choices) : "Change angles" : 1 : "The method through which this train changes its orientation as it moves along the path." =
	[
		0 : "Never (fixed orientation)"
		1 : "Near path_tracks"
		2 : "Linear blend"
		3 : "Ease in/ease out"
	]
	
	wheels(integer) : "Distance Between the Wheels" : 50 : "Used for turning and stopping."
	height(integer) : "Height above track" : 4 : "The height above the track that this train moves."
	bank(string) : "Bank Angle on Turns" : "0"			// NEEDHELP
	
	dmg(integer) : "Damage on Crush" : 0 : "The amount of damage this train does to entities that block it."
	
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."

	MoveSound(sound) : "Move Sound" : "" : "A sound that is played (and looped) while the train is moving."
	MovePingSound(sound) : "Move Ping Sound" : "" : "A sound that is played more frequently as the train speeds up."
	StartSound(sound) : "Start Sound" : "" : "A sound played when the train starts moving."
	StopSound(sound) : "Stop Sound" : "" : "A sound played when the train stops moving."
	volume(integer) : "Volume (10 = loudest)" : 10
	MoveSoundMinPitch(integer) : "Min pitch (1-255, > 100 = higher)" : 60 : "The sound pitch value that the train will approach as it comes to a stop."
	MoveSoundMaxPitch(integer) : "Max pitch (1-255, > 100 = higher)" : 200 : "The sound pitch value that the train will approach as it approaches its "+
		"max speed (or 1000 inches/second if the 'Use max speed for pitch shifting move sound' flag is not set)."
	MoveSoundMinTime(float) : "Min move sound interval" : 0 : "Minimum interval at which to play the move ping sound."
	MoveSoundMaxTime(float) : "Max move sound interval" : 0 : "Maximum interval at which to play the move ping sound."

	// Inputs
	input SetSpeed(float) : "Set the speed of the train, as a ratio of max speed [0, 1]"
	input SetSpeedDir(float) : "Set the speed of the train, as a ratio of max speed. Negative values reverse the direction [-1, 1]"
	input SetSpeedReal(float) : "Set the speed of the train. Must be a positive value from 0 to max speed."
	input Stop(void) : "Stop the train."
	input StartForward(void) : "Start the train moving forward."
	input StartBackward(void) : "Start the train moving backward."
	input Resume(void) : "Resume the train moving in the current direction after it was stopped via the 'Stop' or 'Toggle' input."
	input Reverse(void) : "Reverse the direction of the train."
	input Toggle(void) : "Toggle the train between start and stop."
]

@SolidClass base(Trackchange) = func_trackautochange : 
	"An entity that works as a rotating/moving platform that will carry a train to a new track. "+
	"It must be larger in X-Y planar area than the train, since it must contain the train within "+
	"these dimensions in order to operate when the train is near it."
[
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
	
	// Inputs
	input Trigger(void) : "Trigger the track change."
]

@SolidClass base(Trackchange) = func_trackchange : 
	"An entity that works as a rotating/moving platform that will carry a train to a new track. "+
	"It must be larger in X-Y planar area than the train, since it must contain the train within "+
	"these dimensions in order to operate when the train is near it."
[
	_minlight(string) : "Minimum Light Level" : : "The minimum level of ambient light that hits this brush."
]

@SolidClass base(BaseTrain) = func_tracktrain :
	"A moving platform that the player can ride. It follows a path of path_track entities.<br>" +
	"NOTE: Build your train so that the front of the train is facing down the X axis. " +
	"When it spawns it will automatically rotate to face the next path_track on the path."
[

	// Inputs
	input MoveToPathNode(string) : "Start moving to a destination and stop when you get there. This must be in the same path."
	input TeleportToPathNode(string) : "Teleport to a destination and stop there. This can be in a new path."
	input LockOrientation(void) : "Lock the current orientation of the train."
	input UnlockOrientation(void) : "Unlock the current orientation of the train."

	input SetMaxSpeed(float) : "Set a new max speed for the train."

	// Outputs
	output OnStart(void) : "Fired when the train starts moving in either direction."
	output OnNext(string) : "Fires when this train picks a new point to move towards (and just after OnStart)."
	
	output OnArrivedAtDestinationNode(void) : "Fired when this train arrives at a destination that was specified by the MoveToPathNode Input."	
]

@SolidClass base(BaseTrain) = func_tanktrain :
	"A moving train that follows a path of path_track entities, shoots at the player, and can be killed.<br>" + 
	"NOTE: Build your train so that the front of the train is facing down the X axis. " +
	"When it spawns it will automatically rotate to face the next path_track on the path."
[
	health(integer) : "Health" : 100
	
	// Outputs
	output OnDeath(void) : "Fired when the tank is killed."
]

@SolidClass base(Parentname,Global) = func_traincontrols :
	"When used by the player, this entity overrides the player's controls to let them drive a train."
[
	target(target_destination) : "Train Name" : : "The target train to control when the player uses these controls."
]

@PointClass base(Targetname) iconsprite("editor/tanktrain_aitarget.vmat") = tanktrain_aitarget : 
	"An entity that changes the target of a tanktrain_ai entity."
[
	target(target_destination) : "Tank AI Entity" : : "The tanktrain_ai entity to change the target of."
	newtarget(target_destination) : "New Target Entity" : : "The entity to tell the tanktrain_ai to target."
]

@PointClass base(Targetname) iconsprite("editor/tanktrain_ai.vmat") = tanktrain_ai : 
	"Train chase AI"			// NEEDHELP
[
	target(target_destination) : "Train Name"
	startsound(sound) : "Start Moving Sound" : "vehicles/diesel_start1.wav"
	enginesound(sound) : "Engine Loop Sound" : "vehicles/diesel_turbo_loop1.wav"
	movementsound(sound) : "Vehicle Movement Sound" : "vehicles/tank_treads_loop1.wav"
]

@PointClass base(Targetname, Parentname) cylinder(255 255 255, targetname, target, radius, targetname, targetname, radius) drawangles{} line(255 255 255, targetname, target, targetname, targetname) color(255 192 0) size(16 16 16) = path_track : 
	"An entity used to build paths for other entities to follow. Each path_track is a node on the path, each holding the name of the next path_track in the path."
[
	spawnflags(Flags) =
	[
		1:  "Disabled" : 0
		2:  "Fire once" : 0
		4:  "Branch Reverse" : 0
		8:  "Disable train" : 0
		16: "Teleport to THIS path track" : 0
	]
	
	target(target_destination) : "Next Stop Target" : : "The next path_track in the path."
	altpath(target_destination) : "Branch Path" : : "An alternative path_track to be the next node in the path. Useful for making branching paths. Use the ToggleAlternatePath / EnableAlternatePath inputs to make the alternative path active."
	speed(float) : "New Train Speed" : 0 : "When the train reaches this path_track, it will set its speed to this speed. "+
		"This speed must be a positive value that is less than the train's max speed. A value of 0 will cause no change in the train's speed."
	radius(float) : "Path radius" : 0 : "Used by NPCs who follow track paths (attack chopper/gunship). This tells them the maximum distance they're allowed to be from the path at this node."

	orientationtype(choices) : "Orientation Type" : 1 : "The way that the path follower faces as it moves through this path track." =
	[
		0 : "No change"
		1 : "Face direction of motion"
		2 : "Face this path_track's angles"
	]

	// Inputs
	input ToggleAlternatePath(void) : "Cause the track to toggle to/from its alternate path."
	input EnableAlternatePath(void) : "Enable the alternate path of the track."
	input DisableAlternatePath(void) : "Disable the alternate path of the track."

	input TogglePath(void) : "Cause the track to toggle on/off/"
	input EnablePath(void) : "Enable the track."
	input DisablePath(void) : "Disable the track."

	// Outputs
	output OnPass(void) : "Fired when any entity following this path passes this path_track node."
]


//-------------------------------------------------------------------------
//
// Test Entities
//
//-------------------------------------------------------------------------
@PointClass size(-16 -16 -16, 16 16 16) color(255 255 255) = test_traceline : 
	"A debugging tool for testing tracelines."
[
]


//-------------------------------------------------------------------------
//
// Triggers
//
//-------------------------------------------------------------------------

@SolidClass base(Targetname) tags( Trigger )
	metadata
	{
		auto_apply_material = "materials/tools/toolstrigger.vmat"
	}
= trigger_autosave : 
	"A trigger volume that autosaves when the player touches it."
[
	master(string) : "Master" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."
	NewLevelUnit(boolean) : "Force New Level Unit" : 0 : "If set, the save will discard any savedata from previous levels, for the purpose of keeping savegame filesizes down. Can only be safely used if there is no way for the player to return to previous levels."

	DangerousTimer(float) : "Dangerous Timer" : 0 : "The number of seconds the player must survive before this autosave takes effect."
	
	MinimumHitPoints(integer): "Minumum Hit Points" : 0 : "Don't save dangerous when player has less than this many hitpoints."
]

@SolidClass base(EnableDisable) tags( Trigger )
	metadata
	{
		auto_apply_material = "materials/tools/toolstrigger.vmat"
	}
= trigger_changelevel : 
	"An entity that triggers a level change.<br><br>" +
	"Place an info_landmark in both maps in the PVS of the transition region that marks the 'same' location in each map.<br><br>"+
	"<b>TIPS & TRICKS:</b><br>To fire events in the next level, use the OnLevelChange output to turn on "+
	"an env_global in the current level.  Create a logic_auto in the next level that checks "+
	"for the state set by the env_global.<br><br>"+
	"To control which entities go through the level transition, create one or more trigger_transitions and "+
	"give them the same name as the landmark. Any entities within the trigger_transition(s) will go to the next map."
[
	targetname(target_source) : "Name"
	map(string) : "New Map Name"
	landmark(target_destination) : "Landmark Name"
	spawnflags(flags) =
	[
		2: "Disable Touch" : 0
		4: "To Previous Chapter" : 0
	]
	
	// Inputs
	input ChangeLevel(void) : "Cause the level change. Use this when triggering the level change with a button, etc."
	
	// Outputs
	output OnChangeLevel(void) : "Fired when the level changes."
]

@SolidClass base(Trigger) = trigger_gravity : 
	"A trigger volume that changes the gravity on any entity that touches it."
[
	gravity(integer) : "Gravity (0-1)" : 1
]

// NEEDHELP
@SolidClass base(Trigger) = trigger_soundscape : 
	"Soundscape trigger. " +
	"It is not necessary to create outputs for this trigger. It automatically will trigger the " +
	"soundscape referred to by its 'Soundscape' property."
[
	soundscape(target_destination) : "Soundscape" 
]

@SolidClass base(Trigger, Targetname) = trigger_hurt :
	"A trigger volume that damages entities that touch it."
[
	master(string) : "Master (Obsolete)" : : "Legacy support: The name of a master entity. If the master hasn't been activated, this entity will not activate."
	damage(integer) : "Damage" : 10 : "The amount of damage done to entities that touch this trigger. The damage is done every half-second. See also 'Damage Model' for extra details on how damage can be dealt."
	damagecap(integer) : "Damage Cap" : 20 : "Maximum damage dealt per second. This field is only used if you select the Doubling w/Forgiveness damage model, via the spawnflag."
	damagetype(choices) : "Damage Type" : 0 =
	[
		0 : "GENERIC"
		1 : "CRUSH"
		2 : "BULLET"
		4 : "SLASH"
		8 : "BURN"
		16 : "VEHICLE"
		32 : "FALL"
		64 : "BLAST"
		128 : "CLUB"
		256 : "SHOCK"
		512 : "SONIC"
		1024 : "ENERGYBEAM"
		16384: "DROWN"
		32768 : "PARALYSE"
		65536 : "NERVEGAS"
		131072 : "POISON"
		262144 : "RADIATION"
		524288 : "DROWNRECOVER"
		1048576 : "CHEMICAL"
		2097152 : "SLOWBURN"
		67108864 : "DISSOLVE"
		1114112 : "SPORE"
	]

	damagemodel(choices) : "Damage Model" : 0 : "How damage is dealt. Normal always does the specified amount of damage each half second. Doubling starts with the specified amount and doubles it each time it hurts the toucher. Forgiveness means that if the toucher gets out of the trigger the damage will reset to the specified value. Good for making triggers that are deadly over time without having to cause massive damage on each touch." =
	[
		0 : "Normal"
		1 : "Doubling w/forgiveness"
	]
	forgivedelay(float) : "Forgiveness delay" : 3 : "When doubling with forgiveness, how many seconds the trigger must go without hurting anything before the damage is reset."
	
	nodmgforce(boolean) : "Zero Damage Force" : 0 : "Should the damaged entity receive no physics force from this trigger."
	damageforce(vector) : "Damage Force Override"
	thinkalways(boolean) : "Always think every frame" : 0 : "Normally triggers think every half second, in some cases you may need to request it to damage every frame.  This is expensive!"
	
	// Inputs
	input SetDamage(float) : "Set a new amount of damage for this trigger."
	
	// Outputs
	output OnHurt(void) : "Fired whenever this trigger hurts something other than a player."
	output OnHurtPlayer(void) : "Fired whenever this trigger hurts a player."
]

@SolidClass base(Trigger, Targetname) = trigger_remove : 
	"A trigger volume that removes any entities that touch it. Be careful, removing some entities can cause instability. "+
	"This is not the same as killing entities. i.e. NPCs removed in this manner will not fire their OnKilled outputs."
[
	// Outputs
	output OnRemove(void) : "Fired whenever an entity is removed."
]

@SolidClass base(Trigger) = trigger_multiple :
	"A trigger volume that can be triggered multiple times."
[
	wait(float) : "Delay Before Reset" : 1 : "Amount of time, in seconds, after the trigger_multiple has triggered before it can be triggered again. If set to -1, it will never trigger again (in which case you should just use a trigger_once)."
	 
	// Inputs
	input TouchTest(void) : "Tests if the trigger is being touched and fires an output based on whether the value is true or false." 
	
	 
	// Outputs
	output OnTrigger(void) : "Fired whenever the trigger is activated."
	output OnTouching(void) : "Fired when the TestTouch input is true (something is touching the trigger.)"
	output OnTouchingEachEntity(void) : "Fires for each entity inside the trigger when the TestTouch input is true. Each call provides the individual entity as the activator."
	output OnNotTouching(void) : "Fired when the TestTouch input is not true (nothing is touching the trigger.)"
]

@SolidClass base(TriggerOnce) = trigger_once :
	"A trigger volume that removes itself after it is triggered once."
[
	// Outputs
	output OnTrigger(void) : "Fired whenever the trigger is activated."
]


@SolidClass base(Trigger) tags( Sound ) = trigger_snd_sos_opvar :
	"A trigger volume that sets the value of an snd_sos opvar."
[
	wait(float) : "Update Rate" : "0.2" : "The rate, in seconds, that the trigger updates the OpVar"  
	minimum_value(float) : "Minimum Value" : "0.0" : "The minimum value the opvar will be set to"
	maximum_value(float) : "Maximum Value" : "1.0" : "The maximum value the opvar will be set to"
	stackname(string) : "Stack Name" : "system_globals" : "The name of the stack the operator is in"
	operatorname(string) : "Operator Name" : "test_opvars" : "The name of the operator the OpVar is in"
	opvarname(string) : "OpVar Name" : "none" : "The name of the OpVar to change"
	centersize(float) : "Volume Center Size" : "0.0" : "The size of the center portion of the trigger volume." 
	is2d(boolean) : "Use the trigger in 2D mode" : 1 : "In 2D mode the trigger only measures position along the x and y axes, not the z."
]



@SolidClass base(Trigger) = trigger_look :
	"An entity used to trigger something when the player looks at something. It fires 'OnTrigger' when the player "+
	"looks at a target entity for the given amount of time, while within the trigger volume. If the player leaves "+
	"the trigger or looks away from the target entity the clock resets. If the 'Use Velocity instead of facing' spawnflag " +
	"is checked, the trigger uses the player's velocity instead of the player's view, so it determines whenever the player "+
	"is moving toward the target entity. Useful for triggering when players are driving a vehicle at something."+
	"NOTE: Only designed for single-player game. "
[
	spawnflags(flags) = 
	[ 
		128: "Fire Once" : 1 
		256: "Use Velocity instead of facing" : 0
	]
	
	target(target_destination) : "Look Target" : : "The name of the entity to be looked at."
	LookTime(string) : "Look Time" : "0.5" : "The time, in seconds, that the player must look the target before firing the output. Resets if player leaves trigger, or looks outside the Field of View threshold."
	FieldOfView(string) : "Field Of View" : "0.9" : "How close the player has to be looking at the target.<br><br> 1.0 = straight ahead<br> 0.0 = +/- 90 degrees<br> -1.0 = all directions"
	FOV2D(boolean) : "Use 2D Field Of View" : "0" : "In 2D mode the look angle FOV is only checked along the x and y axes, not the z."
	Timeout(float) : "Timeout" : "0" : "The time, in seconds, to wait after player enters the trigger before firing the OnTimeout output, 0 = never. NOTE: When the timeout expires, the OnTrigger output does NOT fire!"
	test_occlusion(boolean) : "Test occlusion" : "0" : "If set, player must have clear LOS to the target (ignoring dynamic entities)."
	test_visible_occlusion(boolean) : "Test All Visible Occlusion" : "0" : "If set, player must have clear LOS to the target (all visible collision)."

	// Output
	output OnTrigger(void) : "Fired when the trigger is activated. Does NOT fire if the timeout expires."
	output OnTimeout(void) : "Fired after the timeout interval expires if the player never looked at the target. OnTrigger does NOT fire in this case."
	output OnStartLook(void) : "Fired once when the player looks until they have unlooked/untouched."
	output OnEndLook(void) : "Fired when the player was looking and unlooked while still touching."
]

@SolidClass base(Trigger) drawangles_local{ angles_key = "pushdir" } = trigger_push : 
	"A trigger volume that pushes entities that touch it."
[
	pushdir(angle) : "Push Direction (Pitch Yaw Roll)" : "0 0 0" : "Angles indicating the direction to push touched entities."

	spawnflags(flags) = 
	[ 
		128: "Once Only" : 0
		256: "Affects Ladders (Half-Life 2)" : 0 
	]

	speed(integer) : "Speed of Push" : 40 : "The speed at which to push entities away, in inches / second."

	triggeronstarttouch(boolean) : "Trigger on Start Touch" : 0 : "Trigger on start touch instead of on touch."
	
	// Inputs
	input SetPushSpeed(integer) : "Set the push speed in inches / second."
	input SetPushDirection(vector) : "Sets the angles indicating the direction to push touched entities."
]

@SolidClass base(Trigger) = trigger_wind : 
	"A trigger volume that pushes physics objects that touch it."
[
	Speed(integer) : "Speed" : 200   : "The baseline for how hard the wind blows."
	SpeedNoise(integer) : "Speed Noise" : 0 : "Noise added to wind speed +/-"
	DirectionNoise(integer) : "Direction Noise" : 10 : "Noise added to wind direction."
	HoldTime(integer) : "Hold Time" : 0 : "Baseline for how long to wait before changing wind."
	HoldNoise(integer) : "Hold Noise" : 0 : "Noise added to how long to wait before changing wind."

	// Inputs
	input SetSpeed(integer) : "Set the baseline for how hard the wind blows."
]

@SolidClass base(Targetname) 
	metadata
	{
		physics_only_model = true
	}
	= trigger_impact : 
	"A trigger volume that can be told to push all physics objects that are inside of it in the direction specified by this trigger's angles.<br>"+
	"Also outputs the force at the time of impact for anyone else that wants to use it."
[
	Magnitude(float) : "Magnitude" : 200    : "The strength of the impact. Negative values reverse the direction."
	noise(float) : "Noise" : "0.1" : "The amount of directional noise (0-1). 0 = no noise, 1 = random direction."
	viewkick(float) : "Viewkick" : "0.05" : "The amount to kick player's view if the player is in the trigger.  Proportional to magnitude (0-1)."

	// Inputs
	input Impact(float) : "Fire the impact, pushing all entities within the volume."
	input SetMagnitude(float) : "Set the magnitude of the impact."

	// Outputs
	output ImpactForce(string) : "Fired after an impact. The parameter passed along is the force of the impact that was generated."
]

@SolidClass base(Trigger) = trigger_proximity :
	"Measures the distance of the player within the trigger volume from a given point (and within " +
	"a given radius). The NearestPlayerDistance output will be 0 when the player is at the center point, " +
	"and 1 when the player is at the radius."
[
	measuretarget(target_destination) : "Point to Measure From" : : "The name of a target entity who's origin is the point to measure the player's distance from."
	radius(string) : "Radius to measure within" : 256 : "The radius to which the distance should be mapped. If the player is outside the radius he will be ignored."
	
	// Outputs
	output NearestEntityDistance(integer) : "Fired continuously when entities are touching the trigger volume. The output parameter is the distance from the "+
						"Point to Measure From to the nearest entity that passed the trigger filters. The distance is mapped to the radius distance, "+
						"so it will be 0 when the entity is on the point, and 1 when the entity is at the edge of the radius."
]

@SolidClass base(Trigger) = trigger_teleport : 
	"A trigger volume that teleports entities that touch it. Entities are teleported to the Remote Destination, and have their angles "+
	"set to that of the Remote Destination's. If a Local Destination Landmark is specified, teleported entities are offset from the target "+
	"by their initial offset from the landmark, and their angles are left alone."
[
	target(target_destination) : "Remote Destination" : : "The entity specifying the point to which entities should be teleported."
	landmark(target_destination) : "Local Destination Landmark" : : "If specified, then teleported entities are offset from the target by their initial offset from the landmark."
	use_landmark_angles(boolean) : "Use Landmark Orientations" : 0 : "Rotate around landmark by relative landmark orientations"
	mirror_player(boolean) : "Mirror Player" : 0 : "Mirror the player teleport position through the plane defined by the trigger's origin and up vector"
	check_if_dest_clear_for_player(boolean) : "Only Spawn-Valid Destinations" : 0 : "Only teleport if there is a clear teleport destination."
]

@SolidClass base(Targetname) tags( Trigger ) 
	metadata
	{
		auto_apply_material = "materials/tools/toolstrigger.vmat"
	}
= trigger_transition : 
	"A volume that's used to control which entities go through the level transition. Create one or more trigger_transitions and "+
	"give them the same name as the changelevel landmark. Any entities within the trigger_transition(s) will go to the next map."+
	"See trigger_changelevel for more info."
[
	filtername(filterclass) : "Filter Name" : : "Filter to use to see if activator triggers me. See filter_activator_name for more explanation."
]

@SolidClass base(Targetname)
	metadata
	{
		physics_only_model = true
	}
	= trigger_serverragdoll : 
	"A volume that forces any NPC inside it to create a server side ragdoll instead of a client one."
[
]




//-------------------------------------------------------------------------
// Water LOD control
//-------------------------------------------------------------------------

@PointClass base(Targetname) iconsprite("editor/waterlodcontrol.vmat") = water_lod_control : 
	"An entity used to control the LOD behavior of any water in the map. If your map has water, this entity is required."
[
	cheapwaterstartdistance(float) : "Start Transition to Cheap Water" : 1000 : "This is the distance from the camera that water will start transitioning to cheap water, in inches."
	cheapwaterenddistance(float) : "End Transition to Cheap Water" : 2000 : "This is the distance from the camera that water will finish transitioning to cheap water, in inches."

	// Inputs
	input SetCheapWaterStartDistance(float) : "Set the distance that water starts transitioning to cheap water."
	input SetCheapWaterEndDistance(float) : "Set the distance that water finishes transitioning to cheap water."
]


//-------------------------------------------------------------------------
// Camera entity
//-------------------------------------------------------------------------
@PointClass base(Parentname, Targetname, CanBeClientOnly) frustum( FOV, ZNear, ZFar, rendercolor ) editormodel("models/editor/camera.vmdl") = point_camera : "Camera"
[
	spawnflags(Flags) =
	[
		1 : "Start Off" : 0 
	]

	FOV(float) : "FOV" : 90 : "Field of view in degrees"
	ZNear(float) : "ZNear" : 4 : "Distance to the near plane"
	ZFar(float) : "ZFar" : 10000 : "Distance to the far plane"
//	resolution(float) : "resolution" : 256 : "width/height of the render target for the camera"
	UseScreenAspectRatio(boolean) : "Screen Aspect Ratio" : 0
	aspectRatio(float) : "Aspect Ratio" : 1
	fogEnable(boolean) : "Fog Enable" : 0
	fogColor(color255) : "Fog Color" : "0 0 0"
	fogStart(float) : "Fog Start" : 2048 : "The near fog plane."
	fogEnd(float) : "Fog End" : 4096 : "The far fog/clipping plane."
	fogMaxDensity(float) : "Fog Max Density [0..1]" : 1 : "The maximum fog density. 0=no fog, 1=full fog."
 	rendercolor(color255) : "Color (R G B)" : "128 128 128"
	hltvUsable(boolean) : "HLTV Usable" :  0

	// Inputs
	input ChangeFOV(string) : "Changes camera's FOV over time"
	input SetOnAndTurnOthersOff(void) : "Turn the camera on, and turn all other cameras off."
	input SetOn(void) : "Turn the camera on."
	input SetOff(void) : "Turn the camera off."
	input EnableDOF(void) : "Enable Depth of Field."
	input DisableDOF(void) : "Disable Depth of Field."
	input SetDOFNearBlurry(float) : "Set DOF Near Blurry Range."
	input SetDOFNearCrisp(float) : "Set DOF Near Crisp Range."
	input SetDOFFarCrisp(float) : "Set DOF Far Crisp Range."
	input SetDOFFarBlurry(float) : "Set DOF Far Blurry Range."
	input SetDOFTiltToGround(float) : "Set DOF Tilt to Ground Amount (0..1)."
]

//-------------------------------------------------------------------------
// Camera entity
//-------------------------------------------------------------------------
@PointClass base(Parentname, Targetname, CanBeClientOnly) editormodel("models/editor/axis_helper_thick") = point_orient : "Orient Towards"
[
	orient_towards(target_destination) : "Orient Towards" : : "Which entity should I orient towards?"

	goal_direction_type(choices) : "Goal Direction Type" : "eAbsOrigin" : "How to determine what the goal forward direction is" =
	[
		"eAbsOrigin" : "Point At Origin"
		"eCenter" : "Point At Center"
		"eHead" : "Point At Head"
		"eForward" : "Align To Forward Direction"
		"eEyesForward" : "Align To Look Direction"
	]

	constraint_type(choices) : "Orientation Constraints" : "eNone" : "Should the orientation be constrained?" =
	[
		"eNone" : "No constraints"
		"ePreserveUpAxis" : "Preserve Up Axis"
	]

	max_turn_rate(float) : "Maximum Turn Rate" : 0 : "Max turn rate, 0 means instantaneously point toward the target"

	start_active(choices) : "Initial State" : 1 = 
	[
		0 : "Inactive"
		1 : "Active"
	]

	// Inputs
	input SetActive( bool ) : "Activates / deactivates orientation toward the target"
	input SetTarget( target_destination ) : "Sets the target to orient toward"
]

//-------------------------------------------------------------------------
// Camera entity vertical FOV for panorama panels
//-------------------------------------------------------------------------
@PointClass base(Parentname, Targetname, CanBeClientOnly)  frustum( VerticalFOV, ZNear, ZFar, rendercolor ) editormodel("models/editor/camera.vmdl")  = point_camera_vertical_fov : "Camera Vertical FOV"
[
	VerticalFOV(float) : "VerticalFOV" : 90 : "Vertical Field of view in degrees"
	ZNear(float) : "ZNear" : 4 : "Distance to the near plane"
	ZFar(float) : "ZFar" : 10000 : "Distance to the far plane"
	
	aspectRatio(float) : "Aspect Ratio" : 1
	rendercolor(color255) : "Color (R G B)" : "128 128 128"
]

//-------------------------------------------------------------------------
// Used to allow entities to mimic the motions of other entities
//-------------------------------------------------------------------------

@PointClass base(Targetname) tags( Logic ) = logic_measure_movement :
	"An entity that can measure the movement of an entity relative to another entity " +
	"and apply that movement to a third entity."
[
	MeasureTarget(target_destination) : "Entity to Measure" : "" : "Entity whose movement you want to measure."
	MeasureReference(target_destination) : "Measure Reference" : "" : "The movement of Entity to Measure will be measured relative to this entity."
	Target(target_destination) : "Entity to Move" : "" : "This entity will be moved to mimic the motions of Entity to Measure."
	TargetReference(target_destination) : "Movement Reference" : "" : "The Entity to Move will move relative to this entity."
	TargetScale(float) : "Movement scale" : "1" : "A scale to divide the measured movements by, before applying those movements to the Entity to Move. 1 = target entity moves as much as the measured entity, 2 = target entity moves half as far as the measured entity, and 0.5 = target entity moves twice as far as the measured entity."
	MeasureType(choices) : "Measurement Type" : 0 =
	[
		0 : "Position"
		1 : "Eye position"
	]
	
	// Inputs
	input SetMeasureTarget(string) : "Set the Entity to Measure, whose movement should be measured."
	input SetMeasureReference(string) : "Set the Measure Reference entity."
	input Target(string) : "Set the Entity to Move, which will be moved to mimic the measured entity."
	input SetTargetReference(string) : "Set the Movement Reference entity."
	input SetTargetScale(float) : "Set the scale to divide the measured movements by."
	input Enable(void) : "Enable the logic_measure_movement."
	input Disable(void) : "Disable the logic_measure_movement."
]


//-------------------------------------------------------------------------
// Misc
//-------------------------------------------------------------------------

// This entity is not used in L4D, use env_outtro_stats instead.
@PointClass base(Targetname) size(-8 -8 -8, 8 8 8) = env_credits : 
	"An entity to control the rolling credits."
[
	// Inputs
	input RollCredits(void) : "Start the intro credits rolling."
	input RollOutroCredits(void) : "Start the outro credits rolling."
	input ShowLogo(void) : "Show the HL2 logo."
	
	// Outputs
	output OnCreditsDone(void)  : "Fired when the credits having finished rolling."
]


//-------------------------------------------------------------------------
// Devshot camera
//	- Used by the -makedevshots system, which automatically takes screenshots
//	  at the position of every devshot camera in the level.
//-------------------------------------------------------------------------

@PointClass
	editormodel("models/editor/camera")
	frustum(FOV) = point_devshot_camera : 
	"An entity used by the -makedevshots system, which automatically takes screenshots at the position of every devshot camera in the level."
[
	cameraname(string) : "Camera Name" : "" : "Used as the name of the directory to store screenshots from this camera. Must be unique within the level."
	FOV(integer) : "Camera FOV" : 75 : "FOV of this camera."
]


@PointClass base(Targetname, DamageFilter) tags( Logic ) size(-8 -8 -8, 8 8 8) = logic_playerproxy :
	"An entity that is used to relay inputs/ouputs to the player and back to the world."
[
	output OnStartSlowingTime(void)			: "Fired when a Portal player initiates slow time."
	output OnStopSlowingTime(void)			: "Fired when a Portal player stops slowing time."

	// Outputs
	output OnFlashlightOn(float) 			: "Fired when the player turns on his flashlight. This output has the value of how much energy the player had when this happened [0..1]."
	output OnFlashlightOff(float) 			: "Fired when the player turns off his flashlight. This output has the value of how much energy the player had when this happened [0..1]."
	input RequestPlayerHealth(void) 		: "Requests the current player's health from the proxy. This will fire the PlayerHealth output with the value."
	output PlayerHealth(integer)			: "The player's current health value."
	output PlayerMissedAR2AltFire(void)		: "Player fired an AR2 combine ball that didn't kill any enemies."

	input SetFlashlightSlowDrain(void)		: "Puts the player's flashlight in slow-power-drain mode (for Episodic darkness)"
	input SetFlashlightNormalDrain(void)		: "Puts the player's flashlight to default power drain"

	input SetPlayerHealth(integer)			: "Sets the player's health to this value."
	
	input RequestAmmoState(void)			: "Request the ammo state of the player. It will fire PlayerHasAmmo or PlayerHasNoAmmo outputs."
	output PlayerHasAmmo(void) 				: "Fired by request if the player has any ammo."
	output PlayerHasNoAmmo(void) 			: "Fired by request if the player doesn't have any ammo."
	
	output PlayerDied(void) 				: "Fires when the player dies."

	input LowerWeapon(void)					: "Lowers the players weapon."
	
	input EnableCappedPhysicsDamage(void) :	 "Cause player to take less damage from physics objects, and never more than 30 points from any individual strike."
	input DisableCappedPhysicsDamage(void) : "Undo effects of EnableCappedPhysicsDamage"
	input SetLocatorTargetEntity(string) : "Set the entity that the HUD locator should track. (Usually a vehicle)"
	
]

@PointClass base(Targetname, Parentname) overlay() editormodel("models/editor/axis_helper_thick.vmdl", nobounds) = env_decal :
	"Simple projected decal entity"
[
	material(material) : "Decal Material" : ""

	width(float) : "Decal Width" : "256.0"
	height(float) : "Decal Height" : "256.0"
	depth(float) : "Decal Depth" : "256.0"
	sequence(string) : "Sequence" : "0"

	RenderOrder(integer)		: "Render Order" : "0"
	projectonworld(boolean)		: "Project on World" : "1"
	projectoncharacters(boolean)	: "Project on Characters" : "1"
	projectonwater(boolean)		: "Project on Water" : "1"
]


@SolidClass base(func_brush) = func_reflective_glass :
	"Used to produce perfectly reflective glass that renders world + entities. " +
	"Typically, you want your glass brush to have nodraw on all non-reflective surfaces " +
	"and you want to use a shader like lightmappedreflective in your material applied " +
	"to the non-nodraw surfaces. See hl2/materials/glass/reflectiveglass001.vmat for an example. " +
	"NOTE: currently, you cannot use reflective glass in scenes with water, and you can only " +
	"have 1 reflective glass in your view frustum ( + pvs ) at a time."
[
]

@PointClass base(Targetname, EnableDisable) size(-2 -2 -2, 2 2 2) color(0 255 0) = point_gamestats_counter : "Generic game statistics counter."
[
	Name(string) 		: "Name of statistic counter"

	input SetName(string)  : "Changes name of statistic counter"
	input Increment(float) : "Increments named statistic counter by specified value"
]


@PointClass base(Targetname, Parentname, RenderFields) editormodel("models/editor/cone_helper.vmdl") = beam_spotlight : 
	"An entity to draw a spotlight. Will draw a beam when the player views it side on, and a halo when it's facing towards the player. "+
	"Unless the 'No Dynamic Light' spawnflag is checked, it will also create a dynamic light wherever the end of the spotlight rests." +
	"This spotlight is entirely client side, it is not sync'd across clients."
[
	spawnflags(Flags) = 
	[
		1 : "Start On" : 1
		2 : "No Dynamic Light" : 0
		4 : "Start rotation on" : 0
		8 : "Reverse Direction" : 0
		16 : "X Axis"  : 0
		32 : "Y Axis"  : 0
		64 : "No Fog" : 0
	]

	maxspeed(integer) : "Max Rotation Speed" : 100 : "The maximum rotation speed of the spotlight, in degrees per second."

	spotlightlength(integer) : "Spotlight Length" : 500 : "Length of the spotlight beam."
	spotlightwidth(integer) : "Spotlight Width" : 50 : "Width of the spotlight beam."
	rendercolor(color255) : "Color (R G B)" : "255 255 255"
	HDRColorScale(float) : "HDR color scale." : "0.7" : "float value to multiply sprite color by when running in HDR mode."
	
	// Inputs
	input LightOn(void) : "Turn the spotlight on."
	input LightOff(void) : "Turn the spotlight off"
	input Start(void) : "Start the rotator rotating."
	input Stop(void) : "Stop the rotator from rotating."
	input Reverse(void) : "Reverse the direction of rotation of the rotator."
	
	// outputs
	output OnLightOn(void) : "Fires when light turns on."
	output OnLightOff(void) : "Fires when light turns off."
]


@PointClass instance() = func_instance : 
	"An entity for placing an instance of a prefab map file.  You may translate and rotate this entity. " +
	"You can use the replace keys to do parameter changes on the instance contents.  In a $ at the " +
	"beginning of a variable name.  Then just use the $variable name inside of the instance contents on any "+
	"value portion of a key/value pair."
[
	targetname(target_source) : "Fix Up Name" : : "The name that all entities will be fixed up with based upon the fix up style."
	file(instance_file) : "VMAP Filename" : : "This indicates a map file relative to the map's file name"
	fixup_style(Choices) : "Entity Name Fix Up" : 0 : "Fixup style for instanced entity names.  Uses the 'Fix Up Name' field." =
	[
		0 : "Prefix"
		1 : "Postfix"
		2 : "None"
	]

	replace01(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
	replace02(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
	replace03(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
	replace04(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
	replace05(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
	replace06(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
	replace07(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
	replace08(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
	replace09(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
	replace10(instance_variable) : "Replace" : : "This is a replacement parameter.  It goes in the form of $variable value.  All entities inside of that instance that have $variable somewhere will be replaced with the value contents.  Example: $color 255 0 0"
]

@PointClass base(Targetname) iconsprite("editor/env_instructor_hint.vmat") = env_instructor_hint : "An entity that allows for creation and control of instructor lessons by map logic"
[
	hint_replace_key(string) : "Replace Key" : : "Unique name so that messages with the same key will replace each other."
	hint_target(target_destination) : "Target Entity" : : "The entity to show this hint on top of. The entity used must exist on the client, info_target_instructor_hint can be parented to server only entities for this purpose."
	hint_static(Choices) : "Positioning" : 0 : "Either show at the position of the Target Entity. Or show the hint directly on the hud at a fixed position." =
	[
		0 : "Follow the Target Entity"
		1 : "Show on the hud"
	]
	
	hint_allow_nodraw_target(Choices) : "Allow invisible target" : 1 : "Do we allow the hint to follow entites with nodraw set?" =
	[
		0 : "End immediately on nodraw"
		1 : "Yes"
	]
	
	hint_caption(string) : "Caption" : : "The text of your hint."
	hint_activator_caption(string) : "Activator Caption" : : "The text of your hint shown to only the activating player."
	hint_color(color255) : "Caption Color" : "255 255 255" : "The color of the caption text"
	hint_forcecaption(Choices) : "Force caption" : 0 : "Do we show the caption text even if the hint is occluded by a wall?" =
	[
		0 : "No"
		1 : "Show when occluded"
	]
	
	hint_icon_onscreen(Choices) : "Onscreen Icon" : "icon_tip" : "The icon to use when the hint is within the player's view." =
	[
		"icon_bulb" : "icon_bulb"
		"icon_caution" : "icon_caution"
		"icon_tip" : "icon_tip"
		"icon_info" : "icon_info"
		"icon_shield" : "icon_shield"
		"icon_alert" : "icon_alert"
		"icon_alert_red" : "icon_alert_red"
		"icon_tip" : "icon_tip"
		"icon_skull" : "icon_skull"
		"icon_no" : "icon_no"
		"icon_run" : "icon_run"
		"icon_interact" : "icon_interact"
		"icon_button" : "icon_button"
		"icon_door" : "icon_door"
		"icon_arrow_plain" : "icon_arrow_plain"
		"icon_arrow_plain_white_dn" : "icon_arrow_plain_white_dn"
		"icon_arrow_plain_white_up" : "icon_arrow_plain_white_up"
		"icon_arrow_up" : "icon_arrow_up"
		"icon_arrow_right" : "icon_arrow_right"
		"icon_fire" : "icon_fire"
		"icon_present" : "icon_present"
		"use_binding" : "show key bindings"
	]
	
	hint_icon_offscreen(Choices) : "Offscreen Icon" : "icon_tip" : "The icon to use when the hint is outside the player's view." =
	[
		"icon_bulb" : "icon_bulb"
		"icon_caution" : "icon_caution"
		"icon_tip" : "icon_tip"
		"icon_info" : "icon_info"
		"icon_shield" : "icon_shield"
		"icon_alert" : "icon_alert"
		"icon_alert_red" : "icon_alert_red"
		"icon_tip" : "icon_tip"
		"icon_skull" : "icon_skull"
		"icon_no" : "icon_no"
		"icon_run" : "icon_run"
		"icon_interact" : "icon_interact"
		"icon_button" : "icon_button"
		"icon_door" : "icon_door"
		"icon_arrow_plain" : "icon_arrow_plain"
		"icon_arrow_plain_white_dn" : "icon_arrow_plain_white_dn"
		"icon_arrow_plain_white_up" : "icon_arrow_plain_white_up"
		"icon_arrow_up" : "icon_arrow_up"
		"icon_arrow_right" : "icon_arrow_right"
		"icon_fire" : "icon_fire"
		"icon_present" : "icon_present"
	]
	
	hint_nooffscreen(Choices) : "Show offscreen" : 0 : "When the hint is offscreen, do we show an icon and arrow?" =
	[
		0 : "Show"
		1 : "Don't show"		
	]
	
	hint_binding(string) : "Bound Command" : : "If using 'show key bindings' for the onscreen icon, this field should be the command we want to show bindings for"
	hint_icon_offset(float) : "Icon Height Offset" : 0 : "A height offset from the target entity's origin to display the hint"
	hint_pulseoption(Choices) : "Size Pulsing" : 0 : "The icon size can pulsate" =
	[
		0 : "No Pulse"
		1 : "Slow Pulse"
		2 : "Fast Pulse"
		3 : "Urgent Pulse"
	]
	
	hint_alphaoption(Choices) : "Alpha Pulsing" : 0 : "The icon alpha can pulsate" =
	[
		0 : "No Pulse"
		1 : "Slow Pulse"
		2 : "Fast Pulse"
		3 : "Urgent Pulse"
	]
	
	hint_shakeoption(Choices) : "Shaking" : 0 : "The icon can shake" =
	[
		0 : "No Shaking"
		1 : "Narrow Shake"
		2 : "Wide Shake"
	]

	hint_local_player_only(boolean) : "Only Local Player" : "No" : "The hint will only be shown to the local player."
	hint_timeout(integer) : "Timeout" : 0 : "The automatic timeout for the hint. 0 will persist until stopped with EndHint."
	hint_range(float) : "Display Range" : 0 : "The visible range of the hint. 0 will show it at any distance."
	
	hint_auto_start(boolean) : "Show on First Sight" : 1 : "When the player first sees it, it will automatically show for them."
	
	input ShowHint(string) : "Start showing the hint. If an entity name is passed as a parameter, the hint is shown only to that entity."	
	input EndHint(void) : "Stop showing the hint if it hasn't already timed out."
]


@PointClass base(Targetname,Parentname) tags( Info ) = info_target_instructor_hint : "A generic target that gets replicated to the client for hud hint targeting"
[

]

@PointClass base(Targetname) iconsprite("editor/env_instructor_hint.vmat") = env_instructor_vr_hint : "An entity that allows for creation and control of VR Based instructor lessons by map logic"
[
	hint_caption(string) : "Caption" : : "The text of your hint."
	
	hint_start_sound(string) : "Start Sound" : "Instructor.StartLesson" : "Sound to play when the lesson starts"

	hint_timeout(integer) : "Timeout" : 0 : "The automatic timeout for the hint. 0 will persist until stopped with EndHint."
	
	hint_layoutfiletype(Choices) : "Layout Type" : 0 : "Panorama Layout file to be used.  Generic Hand, World or Custom.  Custom requires specifying .xml file" =
	[
		0 : "Default"
		// 1 : "Default" // 1 is deprecated
		2 : "Custom"
	]
	hint_custom_layoutfile(string) : "Custom Layout File" : : "Custom Path to a xml file ie - file://{resources}/layout/custom_hint.xml"

	hint_vr_panel_type(Choices) : "Panel Attach Type" : 0 : "Attach Type for the Panorama Panel" =
	[
		0 : "None"
		1 : "Dominant Hand"
		2 : "Off Hand"
		3 : "Entity"
		4 : "HMD"
		5 : "Large Entity"
	]
	hint_target(target_destination) : "Target Entity" : : "The entity to show this hint on top of. The entity used must exist on the client, info_target_instructor_hint can be parented to server only entities for this purpose. Set hint_vr_panel_type"
	hint_vr_height_offset(float) : "Height Offset" : 0 : "Height offset from the target entities root the panel should be displayed at."

	input ShowHint(string) : "Start showing the hint. If an entity name is passed as a parameter, the hint is shown only to that entity."	
	input EndHint(void) : "Stop showing the hint if it hasn't already timed out."
]

@PointClass base(Targetname) iconsprite("editor/env_instructor_hint.vmat") tags( Logic ) = point_instructor_event : "An entity that fires simple game events from map logic for game instructor"
[
	hint_name(string) : "Lesson Name" : : "Name of the lesson to fire.  Matches name in instructor_lessons.txt."
	hint_target(target_destination) : "Target Entity" : : "Entity to attach this hint to if required by lesson"

	input ShowHint(string) : "Start showing the hint. If an entity name is passed as a parameter, the hint is shown only to that entity."	
	input EndHint(void) : "Stop showing the hint if it hasn't already timed out."
	input SetTargetPlayerToActivator( void ) : "Set the player that should receive this hint to the activator of this input. Only necessary to use this if the player isn't the activator of the ShowHint input. You shouldn't use !player for this, because that only works in singleplayer, and the point of this is to handle multiple players. Instead, fire this input from an output of the entity that the target player activated to initiate the series of events that caused you to want to show them this hint."
]

@PointClass base(Targetname) = func_timescale :
	"Adjust the time scale of the server and client."
[
	desiredTimescale(float) : "Desired timescale." : "1.0" : "Time scale to blend towards, this is a multiplicative value where 1.0 is normal time, 0.5 is half speed, 2.0 is double speed."
	acceleration(float) : "Acceleration per second" : "0.05" : "How quickly the change per second goes up to the max."
	minBlendRate(float) : "Minimum blend per second" : "0.1" : "Minimum change per second when blending from the current timescale to the desired."
	blendDeltaMultiplier(float) : "Perframe delta multiplier" : "3.0" : "The per frame delta between desired and current is multiplied by this to get the maximum change per second."

	input Start(void) : "Start blending to the desired timescale."
	input Stop(void) : "Stop and blend back to the default timescale (1.0f)."
	input Reset(void) : "Reset immediately to normal timescale (1.0f)."
]


@PointClass base(Targetname, Parentname, RenderFields) editormodel("models/editor/axis_helper_thick") externalHelper( ToolObjects/point_worldtext ) color(20 140 20) = point_worldtext : 
	"3D text in the world" 
[
	message(text_block) : "Message"
	enabled(boolean) : "Start Enabled" : "1"
	fullbright(boolean) : "Draw Fullbright" : "0"
	color(color255alpha) : "Color" : "0 0 0 255"
	world_units_per_pixel(float) : "World Units Per Pixel" : "0.25"
	font_size(float) : "Font Size" : "20"
	font_name(string) : "Font Name" : "Arial Black"

	justify_horizontal(choices) : "Horizontal Justify" : 0 =
	[
		0: "Left"
		1: "Center"
		2: "Right"
	]

	justify_vertical(choices) : "Vertical Justify" : 0 =
	[
		0: "Bottom"
		1: "Center"
		2: "Top"
	]

	reorient_mode(choices) : "Reorient Mode" : 0 =
	[
		0: "None"
		1: "Rotate Around Up"
	]

	depth_render_offset(float) : "Depth Offset" : "0.125"
	
	// Inputs
	input Enable(void) : "Enable rendering."
	input Disable(void) : "Disable rendering."
	input Toggle(void) : "Toggle rendering."
	input SetMessage(string) : "Change the text."
	input SetIntMessage(integer) : "Set the text to an integer value."
]


@SolidClass base( Targetname, EnableDisable ) tags( Lighting ) = fog_volume : "An entity to control the fog in the map."
[
	FogName(target_destination) : "Fog Name" : : "The name of the fog entity associated with this volume."
	PostProcessName(target_destination) : "Postprocess Name" : : "The name of the postprocess entity associated with this volume."
	ColorCorrectionName(target_destination) : "ColorCorrection Name" : : "The name of the color_correction entity associated with this volume."
]

@PointClass base(Targetname) editormodel("models/editor/axis_helper_thick") = point_workplane :
	"A dummy entity used to bookmark a frequently used workplane origin and angles. Not compiled into the map."
[
	editor_only(boolean) : "Editor only" : 1
]

@PointClass base(Targetname, Parentname) size(16 16 16) line(255 255 255, targetname, target) drawangles{} color(247 181 82) = path_corner : "Generic path point"
[
	spawnflags(Flags) =
	[
		1: "Wait for retrigger" : 0
		2: "Teleport to THIS path_corner" : 0
	]
	target(target_destination) : "Next stop target"
	wait(integer) : "Wait here (secs)" : 0
	speed(integer) : "Speed" : 0
	yaw_speed(integer) : "New Train rot. Speed" : 0
	radius(float) : "Radius" : 0

	// Inputs 
	input SetNextPathCorner(string) : "Sets next pathcorner"

	// Outputs
	output OnPass(void) : "Fires when a path follower passes this point"
]

@PointClass base(Targetname, EnableDisable) editormodel("models/editor/axis_helper_thick.vmdl") = point_value_remapper
[
	updateOnClient(boolean) : "Update On Client" : 1

	inputType(choices) : "Input Position" : 0 =
	[
		0: "Player Shoot Position"
		1: "Player Shoot Position Around Axis"
	]

	remapLineStart(target_destination) : "Remap Line Start"
	remapLineEnd(target_destination) : "Remap Line End"

	customOutputValue(float) : "Custom Output Value" : "-1.0"

	maximumChangePerSecond(float) : "Max Interp Change Per Second" : "1000.0"
	maximumDistanceFromLine(float) : "Disengage Max Distance" : "1000.0"
	engageDistance(float) : "Engage Distance" : "1000.0"
	requiresUseKey(choices) : "Requires Use Key" : 0 =
	[
		0: "No"
		1: "Yes"
	]

	outputType(choices) : "Output Type" : 0 =
	[
		0: "Animation Cycle"
		1: "Rotation X"
		2: "Rotation Y"
		3: "Rotation Z"
	]

	outputEntity(target_destination) : "Output Entity"
	outputEntity2(target_destination) : "Output Entity 2"
	outputEntity3(target_destination) : "Output Entity 3"
	outputEntity4(target_destination) : "Output Entity 4"

	hapticsType(choices) : "Haptics Type" : 0 =
	[
		0: "Default"
		1: "None"
	]

	momentumType(choices) : "Momentum Type" : 0 =
	[
		0: "None"
		1: "Friction"
		2: "Spring Toward Snap Value"
		3: "Spring Away From Snap Value"
	]

	momentumModifier(float) : "Momentum Modifier" : "0.0"
	snapValue(float) : "Snap Value" : "0.0"

	ratchetType(choices) : "Ratchet Type" : 0 =
	[
		0: "Absolute"
		1: "Each Engage"
	]

	inputOffset(float) : "Input Offset" : "0.0"

	soundEngage(sound): "Engage Sound" : "" : "Name of the GameSound entry to play when remapper starts getting valid inputs."
	soundDisengage(sound): "Disengage Sound" : "" : "Name of the GameSound entry to play when remapper stops getting valid inputs."
	soundReachedValueZero(sound): "Value Zero Sound" : "" : "Name of the GameSound entry for the sound to play when reaching 0.0 interp value."
	soundReachedValueOne(sound): "Value One Sound" : "" : "Name of the GameSound entry for the sound to play when reaching 1.0 interp value."
	soundMovingLoop(sound): "Moving Loop Sound" : "" : "Name of the GameSound entry to update while moving between 0.0 and 1.0."

	input SetMomentumType(integer) : "Sets momentum type"
	input SetMomentumModifier(float) : "Sets momentum modifier"
	input SetSnapValue(float) : "Sets snap value"
	input SetEngageDistance(float) : "Sets engage distance"
	input SetDisengageistance(float) : "Sets disengage distance"

	// Outputs
	output Position(float) : "Fires when the interp value changes, passing the new position [0.0 .. 1.0]"
	output PositionDelta(float) : "Fires when the interp value changes, passing the change in position [-1.0 .. 1.0]"
	output OnReachedValueZero(void) : "Fires when the interp value hits 0.0"
	output OnReachedValueOne(void) : "Fires when the interp value hits 1.0"
	output OnReachedValueCustom(void) : "Fires when the interp value hits a custom specified value"
	output OnEngage(void) : "Fires when engaged due to enering the Engage Distance (and pressing USE if needed)"
	output OnDisengage(void) : "Fires when disengaged due to going beyond the Disengage Max Distance (or releasing USE if needed)"
]

@PointClass editormodel() = prop_magic_carpet
[
	model(studio) : "Model" : "models/editor/sky_helper.vmdl"

	max_ride_speed(float) : "Max Ride Speed" : "50"
]

@BaseClass base(Targetname) = base_clientui_ent 
[ 
	dialog_layout_name(string) : "Layout XML"
	panel_class_name(string) : "Panel Class"
	panel_id(string) : "Panel ID"

	// Inputs
	input Enable(void) : "Enable the UI."
	input Disable(void) : "Disable the UI (may hide it)."

	// Outputs
	output CustomOutput0(void) : ""
	output CustomOutput1(void) : ""
	output CustomOutput2(void) : ""
	output CustomOutput3(void) : ""
	output CustomOutput4(void) : ""
	output CustomOutput5(void) : ""
	output CustomOutput6(void) : ""
	output CustomOutput7(void) : ""
	output CustomOutput8(void) : ""
	output CustomOutput9(void) : ""
]

@PointClass base(base_clientui_ent) model() = point_clientui_dialog
[
	model(studio) : "World model"
	StartEnabled(boolean) : "Start Enabled" : "1" : "Start Enabled"
]

@PointClass base(base_clientui_ent, Parentname) orientedwidthheight( width, height ) = point_clientui_world_panel
[
	width(float) : "Width" : "32"
	height(float) : "Height" : "32"
	panel_dpi(float) : "DPI" : "32"
	ignore_input(boolean) : "Ignore Input" : "0"
	interact_distance(float) : "Interact Distance" : "8"
	lit(boolean) : "Lit" : "0"
	css_class(string) : "Css Class(es)" : ""
	horizontal_align(Choices) =
	[
		0: "Left"
		1: "Center"
		2: "Right"
	]
	vertical_align(Choices) =
	[
		0: "Bottom"
		1: "Center"
		2: "Top"
	]
	orientation(Choices) =
	[
		0: "Default"
		1: "Face User"
		2: "Face User Upright"
	]

	// Inputs
	input IgnoreUserInput(void) : "Ignore user input."
	input AcceptUserInput(void) : "Accept user input."
	input AddCSSClass(string) : "Add a CSS class to the panel."
	input RemoveCSSClass(string) : "Remove a CSS class from the panel."
	input LocalPlayerAddCSSClass(string) : "Add a CSS class to the panel only for local player."
	input LocalPlayerRemoveCSSClass(string) : "Remove a CSS class from the panel only for local player. "
]

@PointClass base(point_clientui_world_panel, Parentname) size(-1 -1 0, 1 1 2) externalHelper( ToolObjects/point_clientui_world_text_panel ) color(20 140 20) = point_clientui_world_text_panel
[
	message(string) [important] : "Message"
	enabled(boolean) [important] : "Start Enabled" : "1"
	dialog_layout_name(string) [important] : "Layout XML" : "file://{resources}/layout/worldui_text.xml"
	width(float) : "Width" : "128"
	height(float) : "Height" : "24"
	enable_offscreen_indicator(boolean) : "Enable Offscreen Indicator" : "0"

	horizontal_align(Choices) : "Horizontal Align" : 1 =
	[
		0: "Left"
		1: "Center"
		2: "Right"
	]

	vertical_align(Choices) : "Vertical Align" : 0 =
	[
		0: "Bottom"
		1: "Center"
		2: "Top"
	]

	orientation(Choices) : "Orientation" : 2 =
	[
		0: "Default"
		1: "Face User"
		2: "Face User Upright"
	]

	// Input
	input SetMessage(string) : "Change the text."
	input SetIntMessage(integer) : "Set the text to an integer value."
	input Toggle(void) : "Toggle rendering."
]

@PointClass base(Targetname) tags( Info ) iconsprite("editor/info_target.vmat") = info_spawngroup_landmark : 
       "Used by info_spawngroup_load to specify a landmark between two spawngroups to load"
[
]

@PointClass base(Targetname, Parentname, EnableDisable) iconsprite("editor/env_sky.vmat") skybox() 
	metadata
	{
	entity_tool_name = "Skybox"
	entity_tool_group = "Fog & Sky"
	entity_tool_tip = "Adds a 2D skybox"
	}
= env_sky : 
	"Controls the sky."
[
	skyname(resource:material) { report=true initial_filter_string="materials/skybox/" } : "Sky Material" : "materials/dev/default_sky.vmat"
	tint_color(color255) : "Skybox Tint Color" : "255 255 255" : "Tint the skybox"
	brightnessscale(float) : "Brightness Scale" : "1.0" : "Scale brightness by this amount"

	fog_type(choices) : "Fog Type" : 1 =
	[
		0: "None"
		1: "Distance Based"
		2: "Angular"
	]

	angular_fog_max_end( float ) : "Fog Max Angle End" : "35.0"
	angular_fog_max_start( float ) : "Fog Max Angle Start" : "25.0"
	angular_fog_min_start( float ) : "Fog Min Angle Start" : "-25.0"
	angular_fog_min_end( float ) : "Fog Min Angle End" : "-35.0"
]


@SolidClass base(PhysicsTypeOverride_Mesh, Targetname, Parentname, Global, EnableDisable, Shadow) = func_shatterglass : "A procedurally-shattering glass panel." 
[
	input Hit(void) : "Damages the panel"
	input Shatter(void) : "Completely breaks the panel"
	input Restore(void) : "Restore the panel"

	output OnBroken(void) : "Fires when the panel first breaks."

	GlassNavIgnore(boolean) : "Nav Ignore" : "1" : "Nav Ignore"
	GlassThickness(float) : "Thickness" : "0.6"
	GlassInFrame(boolean) : "Is in a frame" : "1" : "Is in a frame"
	SpawnInvulnerability(float) : "Spawn Invulnerability" : "3"
	StartBroken(boolean) : "Start Broken" : "0" : "Spawn in a broken state"
	BreakShardless(boolean) : "Start Break Shardless" : "0" : "If starting broken, have no shards"
	DamageType(choices) : "Damage Type" : 1 =
	[
		0: "Bullet"
		1: "Melee"
		2: "Thrown"
		3: "Script"
		4: "Explosive"
	]
	DamagePositioningEntity(target_destination) : "Damage Position 01" : : "If set, this helper position is used for Hit input damage."
	DamagePositioningEntity02(target_destination) : "Damage Position 02" : : "If set, this helper position is used for Hit input damage."
	DamagePositioningEntity03(target_destination) : "Damage Position 03" : : "If set, this helper position is used for Hit input damage."
	DamagePositioningEntity04(target_destination) : "Damage Position 04" : : "If set, this helper position is used for Hit input damage."
	
	DamagedMaterial(material) : "Damaged Material" : "" : "Material to swap to when damaged (optional)"
]

@PointClass base(Targetname, Parentname, EnableDisable) tags( Lighting ) sphere() 
	volumetric_fog_controller( box_mins, box_maxs )
= env_volumetric_fog_controller : "Controller for volumetric fogging - bounds are extents of fog irradiance volume (for indirect)"
[
	IsMaster( bool )  : "Master Fog Controller" : "0" : "Use this as the active fog if there are more than one"
	
	FogStrength( float ) : "Fog strength" : "1.0" : "Technically the scattering value. Higher values make denser fog."
    TintColor( color255 ) : "Tint Color" : "255 255 255" : "Tint color for fog."
	DrawDistance( float ) : "Draw distance" : "600.0" : "Maximum distance to draw fog - WARNING! Changing from default will make fog blockier." 

    volume_depth_override( int ) { group="Resolution" min="0" max="256" } : "Volume Depth" : "0" : "Sets the number of slices in the fog volume.  Increasing from default (128) will increase resolution at the expense of GPU time and memory"
    volume_first_slice_thickness( float ) { group="Resolution" min="0" max="8" } : "Resolution at Camera" : "0" : "Thickness of the first slice in the volume at the camera.  The remaining slices will be warped to maintain this resolution as the draw distance is increased"

	FadeInStart( float ) : "Fade-in start" : "20.0" : "Distance from the eye at which fog starts to fade in." 
	FadeInEnd( float ) : "Fade-in end" : "100.0" : "Distance from the eye at which fog finishes fading in and is at full strength." 
	FadeSpeed( float ) : "Fade time" : "2.0" : "Sets fade in or out time (in seconds)."

	IndirectEnabled( bool ) [ group="Indirect Lighting" ] : "Enable indirect lighting" : "0"
	IndirectStrength( float ) [ group="Indirect Lighting" ] : "Indirect light strength" : "1.0" 
	IndirectVoxelDim(choices) [ group="Indirect Lighting" ] : "Indirect Lighting Dimension" : "256.0" : "" = 
	[
		"512.0" : "Very High Resolution (512x)"
		"256.0" : "High Resolution (256x)"
		"128.0" : "Medium Resolution (128x)"
		"64.0" : "Low Resolution (64x)"
	]

	// Map compiler will automatically populate this and we do not want it shown in the UI.
	//fogirradiancevolume(resource:texture) [ group="Indirect Lighting" ] : "Fog Irradiance Texture" : "" : "Name of the fog irradiance texture"

	// Disabled in shader currently.
	//Anisotropy( float ) : "Anisotropy" : "1.0" : "How much the fog should get brighter when you stare directly at the light." 

	NoiseSpeed( float ) { group="Noise" min="0.0" } : "Noise Speed" : "0.0" : "Speed of noise function change"
	NoiseStrength( float ) { group="Noise" min="0.0" max="1.0" } : "Noise Strength" : "0.0" : "How much noise to add to fog density"
	NoiseScale( vector ) { group="Noise" } : "Noise Scale" : ".01 .01 .01" : "Scale of noise (smaller - smoother, larger - more detailed)"

    WindSpeed( float ) { group="Wind" min="-1.0" max="1.0" } : "Wind Speed" : "0.0"
    WindDirection( vector ) { group="Wind" } : "Wind Direction" : "0.0 0.0 0.0"

	input SetToDefaults(void) : "Resets scattering and anisotropy to default values"
	input SetFogStrength(float) : "Set overall fog strength"
	//input SetAnisotropy(float) : "Set anisotropy value"
	input SetFadeSpeed(float) : "Set fade in/out speed"
	input SetDrawDistance(float) : "Set draw distance"
	input ForceRefresh(void) : "Forces the fog volume to update if a light's state has changed"
	input EnableIndirect( bool ) : "Turns on/off indirect fogging"
]


@PointClass base(Targetname, Parentname, EnableDisable) tags( Lighting ) sphere() 
	box_oriented
	{
		box_min = "box_mins"
		box_max = "box_maxs"
		auto_center = false
		toggle_faces_with_selection_overlay = true
	}
	iconsprite( "materials/editor/fog_volume.vmat" )
= env_volumetric_fog_volume : "Sets a user bounding volume for volumetric fog - if one of these are in the map then all fog will get clamped to it. More than one then fog gets rendered if it's inside any of them."
[
	box_mins(vector) : "Box Mins" : "-64 -64 -64"
	box_maxs(vector) : "Box Maxs" : "64 64 64"
	FogStrength( float ) : "Fog strength" : "1.0" : "Technically the scattering value. Higher values make denser fog."
	FalloffExponent( float ) : "Falloff Exponent" : "1.0" : "Controls the fall off curve for the fog at the edges"
	Shape(choices) : "Falloff Shape" : "0" : "" = 
	[
		"0" : "Linear (Box) Falloff"
		"1" : "Radial (Sphere) Falloff"
		"2" : "Height (Box) Falloff"
	]

    OverrideTintColor(bool) : "Override Tint Color" : "0" : "Override the global tint color in this fog volume."
    TintColor( color255 ) { enabled={variable="OverrideTintColor" value="1" } } : "Tint Color" : "255 255 255" : "Tint color for fog."

	HeightFogDepth(float) { min="12.0" enabled={ variable="Shape" value="2" } } : "Height Fog Vertical Depth" : 48 : "Vertical depth before height fog is maximum intensity"
	HeightFogEdgeWidth(float) { min="12.0" enabled={ variable="Shape" value="2" } } : "Height Fog Edge Width" : 96 : "Horizonal fade width of height fog"

	IndirectUseLPVs(bool) : "Indirect lighting uses LPVs" : "0" : "Use LPVs for indirect lighting: higher resolution, but will not honor fog lighting enable/disable on lights"
	OverrideFogIndirectStrength(bool) : "Override Fog Indirect Lighting Strength" : "0"
	FogIndirectStrength(float) { min="0.0" enabled={ variable="OverrideFogIndirectStrength" value="1" } } : "Fog Indirect Lighting Strength" : "1.0" : "Volume-local scalar for indirect lighting strength"

	OverrideFogSunLightStrength(bool) : "Override Fog Sun Light Strength" : "0"
	FogSunLightStrength(float) { min="0.0" enabled={ variable="OverrideFogSunLightStrength" value="1" } } : "Fog Sun Light Strength" : "1.0" : "Volume-local scalar for sun (light_environment) light strength"

	OverrideFogNoiseStrength(bool) : "Override Fog Noise Strength" : "0"
	FogNoiseStrength(float) { min="0.0" enabled={ variable="OverrideFogNoiseStrength" value="1" } } : "Fog Noise Strength" : "1.0" : "Volume-local fog noise strength"
]

@PointClass tags( Info, VisPreview ) iconsprite( "materials/editor/visibility_hint.vmat" ) 
box_world_aligned
{
	box_min = "box_mins"
	box_max = "box_maxs"
	toggle_faces_with_selection_overlay = true
}
= visibility_hint
[
	box_mins(vector) : "Box Mins" : "-64 -64 -64"
	box_maxs(vector) : "Box Maxs" : "64 64 64"
	hintType(choices) : "Hint Type" : 3 =
	[
		0: "Use High Resolution (8 unit grid)"
		1: "Use Normal Resolution (8 unit grid)"
		10: "Use Reduced Resolution (16 unit grid)"
		2: "Use Medium Resolution (32 unit grid)"
		3: "Use Low Resolution (64 unit grid)"
		8: "Use Lower Resolution (64 unit grid, fewer intial clusters)"
		9: "Use Lowest Resolution (256 unit grid, fewest initial clusters)"
		4: "X-axis split"
		5: "Y-axis split"
		6: "Z-axis split"
	]
]


@PointClass base(Targetname, EnableDisable) tags( Info ) iconsprite( "materials/editor/info_visibility_box.vmat" ) 
centered_box_oriented
{
	box_size = "box_size"
	toggle_faces_with_selection_overlay = true
}
= info_visibility_box : "A dynamic visibility culling box which can be used to hide objects at runtime and can be toggled on and off by entity I/O."
[
	box_size(vector) : "Box Size" : "128 128 128"
	cull_mode(choices) : "Mode" : "0" : "Should the box hide objects inside or outside of its bounds. If inside is selected, any objects fully inside the box will be hidden. If outside is selected, all active visibility boxes are considered, and objects not intersecting any visibility boxes will be hidden."=
	[
		0: "Hide objects inside"
		1: "Hide objects outside"
	]
]

@PointClass tags( Info ) iconsprite( "materials/editor/info_cull_triangles.vmat" ) centered_box_oriented( box_size )
= info_cull_triangles : "A static (compile-time) volume that will delete geometry inside it as part of map compile."
[
	box_size(vector) : "Box Size" : "128 128 128"
	limit_to_world(bool) : "Limit to Prefab" : "0" : "Limit the box to culling triangles objects in the prefab to which it belongs."
	targets(node_id_List) : "Target Objects" : "" : "Limit the box to culling triangles from the specified target objects."
	geometry_type(choices) : "Apply To" : "0" : "Spcifies the type of geometry which can be culled by the box" =
	[
		"0" : "Everything"
		"1" : "Only Static Props"
		"2" : "Only World Geometry"
	]
]


@PathNodeClass
	metadata
	{
		editor_only = true
	}
= path_node_generic
[
]


@PathClass tags( PathLogical )
	metadata
	{
		editor_only = true
		path_node_class = "path_node_generic"
		supports_loop = true
	}
= path_generic
[
]


@PathClass base(Targetname) tags( PathLogical )
	metadata
	{
		path_node_class = "path_node_generic"
		supports_loop = true
		entity_tool_tip = "Specifies a path that will be exported to game and can be referenced by other entities"
	}
	= path_simple : "Specifies a path that will be exported to game and can be referenced by other entities"
[
]

@PathNodeClass
	metadata
	{
		editor_only = true
	}
= path_node_particle_rope
[
	node_name(string) : "Node Name" : "" : "A name to assign to the node that can be used to refer to the node on the path to toggle pinning on specific path nodes via entity I/O."
	radius_scale(float) : "Radius Scale" : "1.0" : "Radius multiplier value"
	color_tint(color255) : "Color Tint" : "255 255 255"
	pin_enabled(bool) { write_to_path_key = "pathNodePinsEnabled" } : "Pin Enabled" : "1" : "If enabled, the rope simulation treats this node a locaiton to which the rope is attached."
]

@BaseClass base(Targetname) tags( Particles )
	metadata
	{
		default_interpolation = "linear"
		path_node_class = "path_node_particle_rope"
		supports_loop = true
	}
= PathParticleRopeBase
[
	effect_name(particlesystem) [report] : "Particle System Name" : "particles/entity/path_particle_cable_default.vpcf"
	start_active(boolean) : "Start Active" : 1 : "Will the particle system be visible on spawn"
	max_simulation_time(float) : "Max Time To Simulate" : 0 : "Max number of seconds to run the particle simulation for. A value of 0 means run the simulation indefinitely."
	particle_spacing(float) : "Spacing" : 32 : "Units between the individual partcles in the rope simulation."
	slack(float) : "Slack" : "0.5" : "Controls the amount the rope will drop between path nodes. Generally between 0.0 and 1.0, the value is a multiplier on the distance that particles on path can seperate relative to their initial distance."
	radius(float) : "Radius" : "4.0" : "Radius of the rope."
	static_collision( bool ) : "Create Static Collision" : "0" : "Create a static physics representation of the path. Note the collision is generated based on the path, movement applied by the particle system will not be included."
	surface_properties(surface_properties) : "Surface Properties" : "" : "Surface properties to apply to the static collision if generated"
	color_tint(color255) : "Color Tint" : "255 255 255"
]


@PathClass base(PathParticleRopeBase) tags( PathVisible ) particle_rope() 
	metadata
	{
		always_hit_test = true
	}
= path_particle_rope
[
	// Inputs
	input Start(void) : "Tell the particle system to start emitting."
	input Stop(void) : "Tell the particle system to stop emitting."
	input StopPlayEndCap(void) : "Tell the particle system to stop emitting and play its End Cap Effect."
	input DestroyImmediately(void) : "Destroy the particle system and remove all particles immediately."
	input SetRadius( float ) : "Set the radius parameter provided the particle system"
	input SetSlack( float ) : "Set the slack parameter which may be used by the particle system to determine how much the rope droops."
	input DisablePin( string ) : "Disable the contraint which pins a particle to the specified path node."
]


@PathClass base(PathParticleRopeBase) tags( PathVisible ) particle_rope() 
	metadata
	{	
		always_hit_test = true
		class_game_keys =
		[
			{ key = "clientSideEntity" value = 1 }
		]
	}
= path_particle_rope_clientside
[
]


@PathNodeClass
	metadata
	{
		editor_only = true
	}
= path_node_cable
[
	radius_scale(float) : "Radius Scale" : "1.0" : "Radius multiplier value"
	color_tint(color255) : "Color Tint" : "255 255 255"
]


@CableClass
	metadata
	{
		editor_only = true
		path_node_class = "path_node_cable"
		supports_loop = true
		has_static_mesh = true
	}
= cable_static
[

]


@CableClass base( Targetname, Parentname, Global, RenderFields, Glow, EnableDisable) sphere(fademindist) sphere(fademaxdist)
	metadata
	{
		path_node_class = "path_node_cable"
		supports_loop = true
	}
= cable_dynamic
[
	spawnflags(flags) =
	[
		512 : "Set to Nav Ignore" : 0
		1024 : "Set to Local-Nav Ignore (NPC will not try to avoid this entity)" : 0
	]

	secondary_material(material) : "Secondary Material" : "" : "Optional secondary material, can be selected using Skin(1)"
	lightingorigin(target_destination) [ group="Render Properties" ] : "Lighting Origin" : "" : "Select an entity to specify a location to sample lighting from, instead of using this entity's origin."
	disableshadows(choices) [ group="Render Properties" ] : "Cast Shadows" : 0 : "Used to disable shadow casting from this entity." = 
	[
		0: "Enabled"
		1: "No Shadows"
		2: "Only Realtime Shadows"
		3: "Only Baked Shadows"
	]

	// Inputs
	input TurnOn(void) : "Make the prop visible."
	input TurnOff(void) : "Make the prop invisible."
	input Skin(integer) : "Changes the model skin to the specified number."
	input EnableCollision(void) : "Enable collision on the prop."
	input DisableCollision(void) : "Disable collision on the prop."
	input SetNavIgnore(boolean) : "Enable and disable NAVIgnore on the prop."
	input DisableShadow(void) : "Turn shadow off."
	input EnableShadow(void) : "Turn shadow on."
	input AlternativeSorting(bool) : "Used to attempt to fix sorting problems when rendering. True activates, false deactivates"
	input SetRenderAttribute(string) : "Set the value of a render attribute used in material dynamic expressions. Examples: $myfloat=0.25 $myfloat4=1.0,0.0,1.0,1.0"
	input ClearRenderAttribute(string) : "Remove a render attribute previously set by SetRenderAttribute, restoring it to its previous value."
]


@PointClass base(Targetname) iconsprite("editor/haptic_relay.vmat") = haptic_relay :
	"Takes Eventoutput and translates them to a Haptic Event (VR / Controller Target)"
[
	Frequency(float) : "Frequency" : "50" : "Frequency of the Haptic pulse (0 - 100)"
	Amplitude(float) : "Amplitude" : "0.5" : "Amplitude of haptic pulse (0.0 - 1.0)"
	Duration(float) : "Duration" : "0.1" : "Duration of the haptic pulse in seconds"
	
	// Inputs
	input OnHandEvent(void) : "Trigger the relay with an input that has the player as activator and HandID as value"
]

//==================================================================================================
// Commentary entities.

@PointClass base( Targetname ) tags( Logic ) iconsprite("editor/commentary_auto.vmat") = commentary_auto : "Fires outputs when a map spawns in commentary mode."
[
	// Outputs
	output OnCommentaryNewGame(void) : "Fired when the map was loaded in commentary mode."
	output OnCommentaryMidGame(void) : "Fired when commentary mode was turned on mid-way through a map."
	// output OnCommentaryMultiplayerSpawn(void) : "Fired when a player joins the map in multiplayer."
]

@PointClass base(Targetname, Parentname) model() = point_commentary_node :
	"Defines the position and data of a commentary node."
[
	model(studio) : "Model" : "models/props/commentary_node.vmdl" : "Model to use."
	commentaryfile(sound) [report] : "Commentary Audio" : "" : "Name of the sound event that contains the commentary audio for this node."
	title(string) : "Title" : "" : "Title of this commentary node."
	speakers(string) : "Speaker(s) Names" : "" : "Name(s) of the speaker(s) in the commentary audio for this node."
	node_id(integer) : "Node ID" : 0 : "The unique number of this node in the current level. If left at 0, the first unused Node ID will be calculated at runtime."
	precommands(string) : "Pre Commands" : "" : "A set of console commands, separated by semi-colon, that should be issued when this node starts playing."
	postcommands(string) : "Post Commands" : "" : "A set of console commands, separated by semi-colon, that should be issued when this node stops playing (due to completion or interruption)."
	viewtarget(target_destination) : "View Target Entity" : "" : "Optional name of an entity that the player's view will be forced to look at when listening to this node."
	viewposition(target_destination) : "View Origin Entity" : "" : "Optional name of an entity that the player's view should move to when listening to this node."
	teleport_origin(world_point) : "Teleport Target" : "" : "Teleport position associated with this node. If players use Mouse2 to jump to the next node, they'll be moved to that node's corresponding teleport position."
	prevent_movement(choices) : "Prevent Movement?" : 0 : "If set, the player will be unable to move while this node is playing." =
	[
		0 : "No"
		1 : "Yes"
	]
	start_disabled(choices) : "Start Disabled?" : 0 : "If set, this node will be disabled on startup, and will require the Enable input to be fired before it will be visible to the player." =
	[
		0 : "No"
		1 : "Yes"
	]

	// Inputs
	input StartCommentary(string) : "Forces a node to start playing."
	input StartUnstoppableCommentary(string) : "Forces a node to start playing, and prevents the player from stopping the playback until it has completed."
	input Enable(void) : "Enable this node, making it visible to the player."
	input Disable(void) : "Disable this node, making it invisible to the player."
	input SetNewOrigin(target_destination) : "Set a new origin for this commentary node. If it's not in use, it'll teleport to this location immediately. If it's currently being listened to, it'll return to this location when it finishes playing."
	
	output OnCommentaryStarted(void) : "Fired when this node starts playback."
	output OnCommentaryStopped(void) : "Fired when this node stops playback."
]

//==================================================================================================

@PointClass base(Targetname)
	iconsprite("editor/nav_walkable.vmat")
	= point_nav_walkable :
	"Causes nav mesh to be generated here and at all points that are reachable via ground movement from here."
[
]


